/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uri-js";
exports.ids = ["vendor-chunks/uri-js"];
exports.modules = {

/***/ "(rsc)/./node_modules/uri-js/dist/es5/uri.all.js":
/*!*************************************************!*\
  !*** ./node_modules/uri-js/dist/es5/uri.all.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    function merge() {\n        for(var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++){\n            sets[_key] = arguments[_key];\n        }\n        if (sets.length > 1) {\n            sets[0] = sets[0].slice(0, -1);\n            var xl = sets.length - 1;\n            for(var x = 1; x < xl; ++x){\n                sets[x] = sets[x].slice(1, -1);\n            }\n            sets[xl] = sets[xl].slice(1);\n            return sets.join(\"\");\n        } else {\n            return sets[0];\n        }\n    }\n    function subexp(str) {\n        return \"(?:\" + str + \")\";\n    }\n    function typeOf(o) {\n        return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n    }\n    function toUpperCase(str) {\n        return str.toUpperCase();\n    }\n    function toArray(obj) {\n        return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [\n            obj\n        ] : Array.prototype.slice.call(obj) : [];\n    }\n    function assign(target, source) {\n        var obj = target;\n        if (source) {\n            for(var key in source){\n                obj[key] = source[key];\n            }\n        }\n        return obj;\n    }\n    function buildExps(isIRI) {\n        var ALPHA$$ = \"[A-Za-z]\", CR$ = \"[\\\\x0D]\", DIGIT$$ = \"[0-9]\", DQUOTE$$ = \"[\\\\x22]\", HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"), //case-insensitive\n        LF$$ = \"[\\\\x0A]\", SP$$ = \"[\\\\x20]\", PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)), //expanded\n        GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\", SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\", //subset, excludes bidi control characters\n        IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\", //subset\n        UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"), DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$), //relaxed parsing rules\n        IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + \"{1,4}\"), LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n        IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n        IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n        IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n        IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n        IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n        IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n        IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n        IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"), //[ *6( h16 \":\" ) h16 ] \"::\"\n        IPV6ADDRESS$ = subexp([\n            IPV6ADDRESS1$,\n            IPV6ADDRESS2$,\n            IPV6ADDRESS3$,\n            IPV6ADDRESS4$,\n            IPV6ADDRESS5$,\n            IPV6ADDRESS6$,\n            IPV6ADDRESS7$,\n            IPV6ADDRESS8$,\n            IPV6ADDRESS9$\n        ].join(\"|\")), ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"), //RFC 6874\n        IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$), //RFC 6874\n        IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$), //RFC 6874, with relaxed parsing rules\n        IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"), IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"), //RFC 6874\n        REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"), HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$), PORT$ = subexp(DIGIT$$ + \"*\"), AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"), PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")), SEGMENT$ = subexp(PCHAR$ + \"*\"), SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"), PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"), PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"), //simplified\n        PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), //simplified\n        PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), //simplified\n        PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\", PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"), FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"), HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"), GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\", SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n        return {\n            NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n            NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n            NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n            ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n            OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n            PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n            IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n            IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n        };\n    }\n    var URI_PROTOCOL = buildExps(false);\n    var IRI_PROTOCOL = buildExps(true);\n    var slicedToArray = function() {\n        function sliceIterator(arr, i) {\n            var _arr = [];\n            var _n = true;\n            var _d = false;\n            var _e = undefined;\n            try {\n                for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                    _arr.push(_s.value);\n                    if (i && _arr.length === i) break;\n                }\n            } catch (err) {\n                _d = true;\n                _e = err;\n            } finally{\n                try {\n                    if (!_n && _i[\"return\"]) _i[\"return\"]();\n                } finally{\n                    if (_d) throw _e;\n                }\n            }\n            return _arr;\n        }\n        return function(arr, i) {\n            if (Array.isArray(arr)) {\n                return arr;\n            } else if (Symbol.iterator in Object(arr)) {\n                return sliceIterator(arr, i);\n            } else {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n            }\n        };\n    }();\n    var toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n            for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];\n            return arr2;\n        } else {\n            return Array.from(arr);\n        }\n    };\n    /** Highest positive signed 32-bit float value */ var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n    /** Bootstring parameters */ var base = 36;\n    var tMin = 1;\n    var tMax = 26;\n    var skew = 38;\n    var damp = 700;\n    var initialBias = 72;\n    var initialN = 128; // 0x80\n    var delimiter = \"-\"; // '\\x2D'\n    /** Regular expressions */ var regexPunycode = /^xn--/;\n    var regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\n    var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n    /** Error messages */ var errors = {\n        \"overflow\": \"Overflow: input needs wider integers to process\",\n        \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n        \"invalid-input\": \"Invalid input\"\n    };\n    /** Convenience shortcuts */ var baseMinusTMin = base - tMin;\n    var floor = Math.floor;\n    var stringFromCharCode = String.fromCharCode;\n    /*--------------------------------------------------------------------------*/ /**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */ function error$1(type) {\n        throw new RangeError(errors[type]);\n    }\n    /**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */ function map(array, fn) {\n        var result = [];\n        var length = array.length;\n        while(length--){\n            result[length] = fn(array[length]);\n        }\n        return result;\n    }\n    /**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */ function mapDomain(string, fn) {\n        var parts = string.split(\"@\");\n        var result = \"\";\n        if (parts.length > 1) {\n            // In email addresses, only the domain name should be punycoded. Leave\n            // the local part (i.e. everything up to `@`) intact.\n            result = parts[0] + \"@\";\n            string = parts[1];\n        }\n        // Avoid `split(regex)` for IE8 compatibility. See #17.\n        string = string.replace(regexSeparators, \".\");\n        var labels = string.split(\".\");\n        var encoded = map(labels, fn).join(\".\");\n        return result + encoded;\n    }\n    /**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */ function ucs2decode(string) {\n        var output = [];\n        var counter = 0;\n        var length = string.length;\n        while(counter < length){\n            var value = string.charCodeAt(counter++);\n            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // It's a high surrogate, and there is a next character.\n                var extra = string.charCodeAt(counter++);\n                if ((extra & 0xFC00) == 0xDC00) {\n                    // Low surrogate.\n                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                    // It's an unmatched surrogate; only append this code unit, in case the\n                    // next code unit is the high surrogate of a surrogate pair.\n                    output.push(value);\n                    counter--;\n                }\n            } else {\n                output.push(value);\n            }\n        }\n        return output;\n    }\n    /**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */ var ucs2encode = function ucs2encode(array) {\n        return String.fromCodePoint.apply(String, toConsumableArray(array));\n    };\n    /**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */ var basicToDigit = function basicToDigit(codePoint) {\n        if (codePoint - 0x30 < 0x0A) {\n            return codePoint - 0x16;\n        }\n        if (codePoint - 0x41 < 0x1A) {\n            return codePoint - 0x41;\n        }\n        if (codePoint - 0x61 < 0x1A) {\n            return codePoint - 0x61;\n        }\n        return base;\n    };\n    /**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */ var digitToBasic = function digitToBasic(digit, flag) {\n        //  0..25 map to ASCII a..z or A..Z\n        // 26..35 map to ASCII 0..9\n        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    };\n    /**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */ var adapt = function adapt(delta, numPoints, firstTime) {\n        var k = 0;\n        delta = firstTime ? floor(delta / damp) : delta >> 1;\n        delta += floor(delta / numPoints);\n        for(; delta > baseMinusTMin * tMax >> 1; k += base){\n            delta = floor(delta / baseMinusTMin);\n        }\n        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    };\n    /**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */ var decode = function decode(input) {\n        // Don't use UCS-2.\n        var output = [];\n        var inputLength = input.length;\n        var i = 0;\n        var n = initialN;\n        var bias = initialBias;\n        // Handle the basic code points: let `basic` be the number of input code\n        // points before the last delimiter, or `0` if there is none, then copy\n        // the first basic code points to the output.\n        var basic = input.lastIndexOf(delimiter);\n        if (basic < 0) {\n            basic = 0;\n        }\n        for(var j = 0; j < basic; ++j){\n            // if it's not a basic code point\n            if (input.charCodeAt(j) >= 0x80) {\n                error$1(\"not-basic\");\n            }\n            output.push(input.charCodeAt(j));\n        }\n        // Main decoding loop: start just after the last delimiter if any basic code\n        // points were copied; start at the beginning otherwise.\n        for(var index = basic > 0 ? basic + 1 : 0; index < inputLength;)/* no final expression */ {\n            // `index` is the index of the next character to be consumed.\n            // Decode a generalized variable-length integer into `delta`,\n            // which gets added to `i`. The overflow checking is easier\n            // if we increase `i` as we go, then subtract off its starting\n            // value at the end to obtain `delta`.\n            var oldi = i;\n            for(var w = 1, k = base;; k += base){\n                if (index >= inputLength) {\n                    error$1(\"invalid-input\");\n                }\n                var digit = basicToDigit(input.charCodeAt(index++));\n                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                    error$1(\"overflow\");\n                }\n                i += digit * w;\n                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                if (digit < t) {\n                    break;\n                }\n                var baseMinusT = base - t;\n                if (w > floor(maxInt / baseMinusT)) {\n                    error$1(\"overflow\");\n                }\n                w *= baseMinusT;\n            }\n            var out = output.length + 1;\n            bias = adapt(i - oldi, out, oldi == 0);\n            // `i` was supposed to wrap around from `out` to `0`,\n            // incrementing `n` each time, so we'll fix that now:\n            if (floor(i / out) > maxInt - n) {\n                error$1(\"overflow\");\n            }\n            n += floor(i / out);\n            i %= out;\n            // Insert `n` at position `i` of the output.\n            output.splice(i++, 0, n);\n        }\n        return String.fromCodePoint.apply(String, output);\n    };\n    /**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */ var encode = function encode(input) {\n        var output = [];\n        // Convert the input in UCS-2 to an array of Unicode code points.\n        input = ucs2decode(input);\n        // Cache the length.\n        var inputLength = input.length;\n        // Initialize the state.\n        var n = initialN;\n        var delta = 0;\n        var bias = initialBias;\n        // Handle the basic code points.\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n            for(var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var _currentValue2 = _step.value;\n                if (_currentValue2 < 0x80) {\n                    output.push(stringFromCharCode(_currentValue2));\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        var basicLength = output.length;\n        var handledCPCount = basicLength;\n        // `handledCPCount` is the number of code points that have been handled;\n        // `basicLength` is the number of basic code points.\n        // Finish the basic string with a delimiter unless it's empty.\n        if (basicLength) {\n            output.push(delimiter);\n        }\n        // Main encoding loop:\n        while(handledCPCount < inputLength){\n            // All non-basic code points < n have been handled already. Find the next\n            // larger one:\n            var m = maxInt;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n            try {\n                for(var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){\n                    var currentValue = _step2.value;\n                    if (currentValue >= n && currentValue < m) {\n                        m = currentValue;\n                    }\n                }\n            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n            // but guard against overflow.\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally{\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n            var handledCPCountPlusOne = handledCPCount + 1;\n            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                error$1(\"overflow\");\n            }\n            delta += (m - n) * handledCPCountPlusOne;\n            n = m;\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n            try {\n                for(var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){\n                    var _currentValue = _step3.value;\n                    if (_currentValue < n && ++delta > maxInt) {\n                        error$1(\"overflow\");\n                    }\n                    if (_currentValue == n) {\n                        // Represent delta as a generalized variable-length integer.\n                        var q = delta;\n                        for(var k = base;; k += base){\n                            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                            if (q < t) {\n                                break;\n                            }\n                            var qMinusT = q - t;\n                            var baseMinusT = base - t;\n                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                            q = floor(qMinusT / baseMinusT);\n                        }\n                        output.push(stringFromCharCode(digitToBasic(q, 0)));\n                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                        delta = 0;\n                        ++handledCPCount;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally{\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n            ++delta;\n            ++n;\n        }\n        return output.join(\"\");\n    };\n    /**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */ var toUnicode = function toUnicode(input) {\n        return mapDomain(input, function(string) {\n            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n        });\n    };\n    /**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */ var toASCII = function toASCII(input) {\n        return mapDomain(input, function(string) {\n            return regexNonASCII.test(string) ? \"xn--\" + encode(string) : string;\n        });\n    };\n    /*--------------------------------------------------------------------------*/ /** Define the public API */ var punycode = {\n        /**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */ \"version\": \"2.1.0\",\n        /**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */ \"ucs2\": {\n            \"decode\": ucs2decode,\n            \"encode\": ucs2encode\n        },\n        \"decode\": decode,\n        \"encode\": encode,\n        \"toASCII\": toASCII,\n        \"toUnicode\": toUnicode\n    };\n    /**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */ /**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */ var SCHEMES = {};\n    function pctEncChar(chr) {\n        var c = chr.charCodeAt(0);\n        var e = void 0;\n        if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n        else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n        else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n        else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n        return e;\n    }\n    function pctDecChars(str) {\n        var newStr = \"\";\n        var i = 0;\n        var il = str.length;\n        while(i < il){\n            var c = parseInt(str.substr(i + 1, 2), 16);\n            if (c < 128) {\n                newStr += String.fromCharCode(c);\n                i += 3;\n            } else if (c >= 194 && c < 224) {\n                if (il - i >= 6) {\n                    var c2 = parseInt(str.substr(i + 4, 2), 16);\n                    newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n                } else {\n                    newStr += str.substr(i, 6);\n                }\n                i += 6;\n            } else if (c >= 224) {\n                if (il - i >= 9) {\n                    var _c = parseInt(str.substr(i + 4, 2), 16);\n                    var c3 = parseInt(str.substr(i + 7, 2), 16);\n                    newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n                } else {\n                    newStr += str.substr(i, 9);\n                }\n                i += 9;\n            } else {\n                newStr += str.substr(i, 3);\n                i += 3;\n            }\n        }\n        return newStr;\n    }\n    function _normalizeComponentEncoding(components, protocol) {\n        function decodeUnreserved(str) {\n            var decStr = pctDecChars(str);\n            return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n        }\n        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n        if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        return components;\n    }\n    function _stripLeadingZeros(str) {\n        return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n    }\n    function _normalizeIPv4(host, protocol) {\n        var matches = host.match(protocol.IPV4ADDRESS) || [];\n        var _matches = slicedToArray(matches, 2), address = _matches[1];\n        if (address) {\n            return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n        } else {\n            return host;\n        }\n    }\n    function _normalizeIPv6(host, protocol) {\n        var matches = host.match(protocol.IPV6ADDRESS) || [];\n        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];\n        if (address) {\n            var _address$toLowerCase$ = address.toLowerCase().split(\"::\").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];\n            var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n            var lastFields = last.split(\":\").map(_stripLeadingZeros);\n            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n            var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n            var lastFieldsStart = lastFields.length - fieldCount;\n            var fields = Array(fieldCount);\n            for(var x = 0; x < fieldCount; ++x){\n                fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || \"\";\n            }\n            if (isLastFieldIPv4Address) {\n                fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n            }\n            var allZeroFields = fields.reduce(function(acc, field, index) {\n                if (!field || field === \"0\") {\n                    var lastLongest = acc[acc.length - 1];\n                    if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                        lastLongest.length++;\n                    } else {\n                        acc.push({\n                            index: index,\n                            length: 1\n                        });\n                    }\n                }\n                return acc;\n            }, []);\n            var longestZeroFields = allZeroFields.sort(function(a, b) {\n                return b.length - a.length;\n            })[0];\n            var newHost = void 0;\n            if (longestZeroFields && longestZeroFields.length > 1) {\n                var newFirst = fields.slice(0, longestZeroFields.index);\n                var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n                newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n            } else {\n                newHost = fields.join(\":\");\n            }\n            if (zone) {\n                newHost += \"%\" + zone;\n            }\n            return newHost;\n        } else {\n            return host;\n        }\n    }\n    var URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\n    var NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\n    function parse(uriString) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var components = {};\n        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n        if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n        var matches = uriString.match(URI_PARSE);\n        if (matches) {\n            if (NO_MATCH_IS_UNDEFINED) {\n                //store each component\n                components.scheme = matches[1];\n                components.userinfo = matches[3];\n                components.host = matches[4];\n                components.port = parseInt(matches[5], 10);\n                components.path = matches[6] || \"\";\n                components.query = matches[7];\n                components.fragment = matches[8];\n                //fix port number\n                if (isNaN(components.port)) {\n                    components.port = matches[5];\n                }\n            } else {\n                //IE FIX for improper RegExp matching\n                //store each component\n                components.scheme = matches[1] || undefined;\n                components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n                components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n                components.port = parseInt(matches[5], 10);\n                components.path = matches[6] || \"\";\n                components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n                components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n                //fix port number\n                if (isNaN(components.port)) {\n                    components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n                }\n            }\n            if (components.host) {\n                //normalize IP hosts\n                components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n            }\n            //determine reference type\n            if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n                components.reference = \"same-document\";\n            } else if (components.scheme === undefined) {\n                components.reference = \"relative\";\n            } else if (components.fragment === undefined) {\n                components.reference = \"absolute\";\n            } else {\n                components.reference = \"uri\";\n            }\n            //check for reference errors\n            if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n                components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n            }\n            //find scheme handler\n            var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n            //check if scheme can't handle IRIs\n            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n                //if host component is a domain name\n                if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                    //convert Unicode IDN -> ASCII IDN\n                    try {\n                        components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                    } catch (e) {\n                        components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                    }\n                }\n                //convert IRI -> URI\n                _normalizeComponentEncoding(components, URI_PROTOCOL);\n            } else {\n                //normalize encodings\n                _normalizeComponentEncoding(components, protocol);\n            }\n            //perform scheme specific parsing\n            if (schemeHandler && schemeHandler.parse) {\n                schemeHandler.parse(components, options);\n            }\n        } else {\n            components.error = components.error || \"URI can not be parsed.\";\n        }\n        return components;\n    }\n    function _recomposeAuthority(components, options) {\n        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n        var uriTokens = [];\n        if (components.userinfo !== undefined) {\n            uriTokens.push(components.userinfo);\n            uriTokens.push(\"@\");\n        }\n        if (components.host !== undefined) {\n            //normalize IP hosts, add brackets and escape zone separator for IPv6\n            uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {\n                return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n            }));\n        }\n        if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n            uriTokens.push(\":\");\n            uriTokens.push(String(components.port));\n        }\n        return uriTokens.length ? uriTokens.join(\"\") : undefined;\n    }\n    var RDS1 = /^\\.\\.?\\//;\n    var RDS2 = /^\\/\\.(\\/|$)/;\n    var RDS3 = /^\\/\\.\\.(\\/|$)/;\n    var RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n    function removeDotSegments(input) {\n        var output = [];\n        while(input.length){\n            if (input.match(RDS1)) {\n                input = input.replace(RDS1, \"\");\n            } else if (input.match(RDS2)) {\n                input = input.replace(RDS2, \"/\");\n            } else if (input.match(RDS3)) {\n                input = input.replace(RDS3, \"/\");\n                output.pop();\n            } else if (input === \".\" || input === \"..\") {\n                input = \"\";\n            } else {\n                var im = input.match(RDS5);\n                if (im) {\n                    var s = im[0];\n                    input = input.slice(s.length);\n                    output.push(s);\n                } else {\n                    throw new Error(\"Unexpected dot segment condition\");\n                }\n            }\n        }\n        return output.join(\"\");\n    }\n    function serialize(components) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n        var uriTokens = [];\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //perform scheme specific serialization\n        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n        if (components.host) {\n            //if host component is an IPv6 address\n            if (protocol.IPV6ADDRESS.test(components.host)) {} else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n        }\n        //normalize encoding\n        _normalizeComponentEncoding(components, protocol);\n        if (options.reference !== \"suffix\" && components.scheme) {\n            uriTokens.push(components.scheme);\n            uriTokens.push(\":\");\n        }\n        var authority = _recomposeAuthority(components, options);\n        if (authority !== undefined) {\n            if (options.reference !== \"suffix\") {\n                uriTokens.push(\"//\");\n            }\n            uriTokens.push(authority);\n            if (components.path && components.path.charAt(0) !== \"/\") {\n                uriTokens.push(\"/\");\n            }\n        }\n        if (components.path !== undefined) {\n            var s = components.path;\n            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n                s = removeDotSegments(s);\n            }\n            if (authority === undefined) {\n                s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n            }\n            uriTokens.push(s);\n        }\n        if (components.query !== undefined) {\n            uriTokens.push(\"?\");\n            uriTokens.push(components.query);\n        }\n        if (components.fragment !== undefined) {\n            uriTokens.push(\"#\");\n            uriTokens.push(components.fragment);\n        }\n        return uriTokens.join(\"\"); //merge tokens into a string\n    }\n    function resolveComponents(base, relative) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var skipNormalization = arguments[3];\n        var target = {};\n        if (!skipNormalization) {\n            base = parse(serialize(base, options), options); //normalize base components\n            relative = parse(serialize(relative, options), options); //normalize relative components\n        }\n        options = options || {};\n        if (!options.tolerant && relative.scheme) {\n            target.scheme = relative.scheme;\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n                //target.authority = relative.authority;\n                target.userinfo = relative.userinfo;\n                target.host = relative.host;\n                target.port = relative.port;\n                target.path = removeDotSegments(relative.path || \"\");\n                target.query = relative.query;\n            } else {\n                if (!relative.path) {\n                    target.path = base.path;\n                    if (relative.query !== undefined) {\n                        target.query = relative.query;\n                    } else {\n                        target.query = base.query;\n                    }\n                } else {\n                    if (relative.path.charAt(0) === \"/\") {\n                        target.path = removeDotSegments(relative.path);\n                    } else {\n                        if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                            target.path = \"/\" + relative.path;\n                        } else if (!base.path) {\n                            target.path = relative.path;\n                        } else {\n                            target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                        }\n                        target.path = removeDotSegments(target.path);\n                    }\n                    target.query = relative.query;\n                }\n                //target.authority = base.authority;\n                target.userinfo = base.userinfo;\n                target.host = base.host;\n                target.port = base.port;\n            }\n            target.scheme = base.scheme;\n        }\n        target.fragment = relative.fragment;\n        return target;\n    }\n    function resolve(baseURI, relativeURI, options) {\n        var schemelessOptions = assign({\n            scheme: \"null\"\n        }, options);\n        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n    }\n    function normalize(uri, options) {\n        if (typeof uri === \"string\") {\n            uri = serialize(parse(uri, options), options);\n        } else if (typeOf(uri) === \"object\") {\n            uri = parse(serialize(uri, options), options);\n        }\n        return uri;\n    }\n    function equal(uriA, uriB, options) {\n        if (typeof uriA === \"string\") {\n            uriA = serialize(parse(uriA, options), options);\n        } else if (typeOf(uriA) === \"object\") {\n            uriA = serialize(uriA, options);\n        }\n        if (typeof uriB === \"string\") {\n            uriB = serialize(parse(uriB, options), options);\n        } else if (typeOf(uriB) === \"object\") {\n            uriB = serialize(uriB, options);\n        }\n        return uriA === uriB;\n    }\n    function escapeComponent(str, options) {\n        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n    }\n    function unescapeComponent(str, options) {\n        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n    }\n    var handler = {\n        scheme: \"http\",\n        domainHost: true,\n        parse: function parse(components, options) {\n            //report missing host\n            if (!components.host) {\n                components.error = components.error || \"HTTP URIs must have a host.\";\n            }\n            return components;\n        },\n        serialize: function serialize(components, options) {\n            var secure = String(components.scheme).toLowerCase() === \"https\";\n            //normalize the default port\n            if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n                components.port = undefined;\n            }\n            //normalize the empty path\n            if (!components.path) {\n                components.path = \"/\";\n            }\n            //NOTE: We do not parse query strings for HTTP URIs\n            //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n            //and not the HTTP spec.\n            return components;\n        }\n    };\n    var handler$1 = {\n        scheme: \"https\",\n        domainHost: handler.domainHost,\n        parse: handler.parse,\n        serialize: handler.serialize\n    };\n    function isSecure(wsComponents) {\n        return typeof wsComponents.secure === \"boolean\" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n    }\n    //RFC 6455\n    var handler$2 = {\n        scheme: \"ws\",\n        domainHost: true,\n        parse: function parse(components, options) {\n            var wsComponents = components;\n            //indicate if the secure flag is set\n            wsComponents.secure = isSecure(wsComponents);\n            //construct resouce name\n            wsComponents.resourceName = (wsComponents.path || \"/\") + (wsComponents.query ? \"?\" + wsComponents.query : \"\");\n            wsComponents.path = undefined;\n            wsComponents.query = undefined;\n            return wsComponents;\n        },\n        serialize: function serialize(wsComponents, options) {\n            //normalize the default port\n            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n                wsComponents.port = undefined;\n            }\n            //ensure scheme matches secure flag\n            if (typeof wsComponents.secure === \"boolean\") {\n                wsComponents.scheme = wsComponents.secure ? \"wss\" : \"ws\";\n                wsComponents.secure = undefined;\n            }\n            //reconstruct path from resource name\n            if (wsComponents.resourceName) {\n                var _wsComponents$resourc = wsComponents.resourceName.split(\"?\"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];\n                wsComponents.path = path && path !== \"/\" ? path : undefined;\n                wsComponents.query = query;\n                wsComponents.resourceName = undefined;\n            }\n            //forbid fragment component\n            wsComponents.fragment = undefined;\n            return wsComponents;\n        }\n    };\n    var handler$3 = {\n        scheme: \"wss\",\n        domainHost: handler$2.domainHost,\n        parse: handler$2.parse,\n        serialize: handler$2.serialize\n    };\n    var O = {};\n    var isIRI = true;\n    //RFC 3986\n    var UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\n    var HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\n    var PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n    //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n    //const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n    //const WSP$$ = \"[\\\\x20\\\\x09]\";\n    //const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n    //const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n    //const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n    //const WSP$$ = \"[\\\\x20\\\\x09]\";\n    //const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n    //const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n    //const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n    //const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\n    var ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n    var QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\n    var VCHAR$$ = merge(QTEXT$$, '[\\\\\"\\\\\\\\]');\n    var SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\n    var UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\n    var PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\n    var NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\n    var NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\n    var NOT_HFVALUE = NOT_HFNAME;\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(UNRESERVED) ? str : decStr;\n    }\n    var handler$4 = {\n        scheme: \"mailto\",\n        parse: function parse$$1(components, options) {\n            var mailtoComponents = components;\n            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n            mailtoComponents.path = undefined;\n            if (mailtoComponents.query) {\n                var unknownHeaders = false;\n                var headers = {};\n                var hfields = mailtoComponents.query.split(\"&\");\n                for(var x = 0, xl = hfields.length; x < xl; ++x){\n                    var hfield = hfields[x].split(\"=\");\n                    switch(hfield[0]){\n                        case \"to\":\n                            var toAddrs = hfield[1].split(\",\");\n                            for(var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x){\n                                to.push(toAddrs[_x]);\n                            }\n                            break;\n                        case \"subject\":\n                            mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                            break;\n                        case \"body\":\n                            mailtoComponents.body = unescapeComponent(hfield[1], options);\n                            break;\n                        default:\n                            unknownHeaders = true;\n                            headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                            break;\n                    }\n                }\n                if (unknownHeaders) mailtoComponents.headers = headers;\n            }\n            mailtoComponents.query = undefined;\n            for(var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2){\n                var addr = to[_x2].split(\"@\");\n                addr[0] = unescapeComponent(addr[0]);\n                if (!options.unicodeSupport) {\n                    //convert Unicode IDN -> ASCII IDN\n                    try {\n                        addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                    } catch (e) {\n                        mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                    }\n                } else {\n                    addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n                }\n                to[_x2] = addr.join(\"@\");\n            }\n            return mailtoComponents;\n        },\n        serialize: function serialize$$1(mailtoComponents, options) {\n            var components = mailtoComponents;\n            var to = toArray(mailtoComponents.to);\n            if (to) {\n                for(var x = 0, xl = to.length; x < xl; ++x){\n                    var toAddr = String(to[x]);\n                    var atIdx = toAddr.lastIndexOf(\"@\");\n                    var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                    var domain = toAddr.slice(atIdx + 1);\n                    //convert IDN via punycode\n                    try {\n                        domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                    } catch (e) {\n                        components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                    }\n                    to[x] = localPart + \"@\" + domain;\n                }\n                components.path = to.join(\",\");\n            }\n            var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n            if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n            if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n            var fields = [];\n            for(var name in headers){\n                if (headers[name] !== O[name]) {\n                    fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n                }\n            }\n            if (fields.length) {\n                components.query = fields.join(\"&\");\n            }\n            return components;\n        }\n    };\n    var URN_PARSE = /^([^\\:]+)\\:(.*)/;\n    //RFC 2141\n    var handler$5 = {\n        scheme: \"urn\",\n        parse: function parse$$1(components, options) {\n            var matches = components.path && components.path.match(URN_PARSE);\n            var urnComponents = components;\n            if (matches) {\n                var scheme = options.scheme || urnComponents.scheme || \"urn\";\n                var nid = matches[1].toLowerCase();\n                var nss = matches[2];\n                var urnScheme = scheme + \":\" + (options.nid || nid);\n                var schemeHandler = SCHEMES[urnScheme];\n                urnComponents.nid = nid;\n                urnComponents.nss = nss;\n                urnComponents.path = undefined;\n                if (schemeHandler) {\n                    urnComponents = schemeHandler.parse(urnComponents, options);\n                }\n            } else {\n                urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n            }\n            return urnComponents;\n        },\n        serialize: function serialize$$1(urnComponents, options) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = urnComponents.nid;\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            if (schemeHandler) {\n                urnComponents = schemeHandler.serialize(urnComponents, options);\n            }\n            var uriComponents = urnComponents;\n            var nss = urnComponents.nss;\n            uriComponents.path = (nid || options.nid) + \":\" + nss;\n            return uriComponents;\n        }\n    };\n    var UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n    //RFC 4122\n    var handler$6 = {\n        scheme: \"urn:uuid\",\n        parse: function parse(urnComponents, options) {\n            var uuidComponents = urnComponents;\n            uuidComponents.uuid = uuidComponents.nss;\n            uuidComponents.nss = undefined;\n            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n                uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n            }\n            return uuidComponents;\n        },\n        serialize: function serialize(uuidComponents, options) {\n            var urnComponents = uuidComponents;\n            //normalize UUID\n            urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n            return urnComponents;\n        }\n    };\n    SCHEMES[handler.scheme] = handler;\n    SCHEMES[handler$1.scheme] = handler$1;\n    SCHEMES[handler$2.scheme] = handler$2;\n    SCHEMES[handler$3.scheme] = handler$3;\n    SCHEMES[handler$4.scheme] = handler$4;\n    SCHEMES[handler$5.scheme] = handler$5;\n    SCHEMES[handler$6.scheme] = handler$6;\n    exports1.SCHEMES = SCHEMES;\n    exports1.pctEncChar = pctEncChar;\n    exports1.pctDecChars = pctDecChars;\n    exports1.parse = parse;\n    exports1.removeDotSegments = removeDotSegments;\n    exports1.serialize = serialize;\n    exports1.resolveComponents = resolveComponents;\n    exports1.resolve = resolve;\n    exports1.normalize = normalize;\n    exports1.equal = equal;\n    exports1.escapeComponent = escapeComponent;\n    exports1.unescapeComponent = unescapeComponent;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n}); //# sourceMappingURL=uri.all.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXJpLWpzL2Rpc3QvZXM1L3VyaS5hbGwuanMiLCJtYXBwaW5ncyI6IkFBQUEsNEZBQTRGLEdBQzNGLFVBQVVBLE1BQU0sRUFBRUMsT0FBTztJQUN6QixLQUFpRCxHQUFjQSxRQUFRQyxXQUN2RSxDQUN3QztBQUN6QyxHQUFFLElBQUksRUFBRyxTQUFVQSxRQUFPO0lBQUk7SUFFOUIsU0FBU0s7UUFDTCxJQUFLLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBT0MsTUFBTUosT0FBT0ssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO1lBQ2pGRixJQUFJLENBQUNFLEtBQUssR0FBR0osU0FBUyxDQUFDSSxLQUFLO1FBQ2hDO1FBRUEsSUFBSUYsS0FBS0QsTUFBTSxHQUFHLEdBQUc7WUFDakJDLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLENBQUNHLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDNUIsSUFBSUMsS0FBS0osS0FBS0QsTUFBTSxHQUFHO1lBQ3ZCLElBQUssSUFBSU0sSUFBSSxHQUFHQSxJQUFJRCxJQUFJLEVBQUVDLEVBQUc7Z0JBQ3pCTCxJQUFJLENBQUNLLEVBQUUsR0FBR0wsSUFBSSxDQUFDSyxFQUFFLENBQUNGLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDaEM7WUFDQUgsSUFBSSxDQUFDSSxHQUFHLEdBQUdKLElBQUksQ0FBQ0ksR0FBRyxDQUFDRCxLQUFLLENBQUM7WUFDMUIsT0FBT0gsS0FBS00sSUFBSSxDQUFDO1FBQ3JCLE9BQU87WUFDSCxPQUFPTixJQUFJLENBQUMsRUFBRTtRQUNsQjtJQUNKO0lBQ0EsU0FBU08sT0FBT0MsR0FBRztRQUNmLE9BQU8sUUFBUUEsTUFBTTtJQUN6QjtJQUNBLFNBQVNDLE9BQU9DLENBQUM7UUFDYixPQUFPQSxNQUFNQyxZQUFZLGNBQWNELE1BQU0sT0FBTyxTQUFTRSxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDTCxHQUFH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LFVBQVVyRixNQUFNLENBQUMsR0FBR3FGO0lBQzVCeEcsT0FBTyxDQUFDMkcsVUFBVXhGLE1BQU0sQ0FBQyxHQUFHd0Y7SUFDNUIzRyxPQUFPLENBQUMrRyxVQUFVNUYsTUFBTSxDQUFDLEdBQUc0RjtJQUM1Qi9HLE9BQU8sQ0FBQ3dILFVBQVVyRyxNQUFNLENBQUMsR0FBR3FHO0lBQzVCeEgsT0FBTyxDQUFDK0ksVUFBVTVILE1BQU0sQ0FBQyxHQUFHNEg7SUFDNUIvSSxPQUFPLENBQUNzSixVQUFVbkksTUFBTSxDQUFDLEdBQUdtSTtJQUU1QmpZLFNBQVEyTyxPQUFPLEdBQUdBO0lBQ2xCM08sU0FBUTRPLFVBQVUsR0FBR0E7SUFDckI1TyxTQUFRZ1AsV0FBVyxHQUFHQTtJQUN0QmhQLFNBQVFxUyxLQUFLLEdBQUdBO0lBQ2hCclMsU0FBUTBULGlCQUFpQixHQUFHQTtJQUM1QjFULFNBQVE4VCxTQUFTLEdBQUdBO0lBQ3BCOVQsU0FBUWtVLGlCQUFpQixHQUFHQTtJQUM1QmxVLFNBQVFzVSxPQUFPLEdBQUdBO0lBQ2xCdFUsU0FBUTBVLFNBQVMsR0FBR0E7SUFDcEIxVSxTQUFRNFUsS0FBSyxHQUFHQTtJQUNoQjVVLFNBQVErVSxlQUFlLEdBQUdBO0lBQzFCL1UsU0FBUWdWLGlCQUFpQixHQUFHQTtJQUU1QjNULE9BQU8rVyxjQUFjLENBQUNwWSxVQUFTLGNBQWM7UUFBRXFJLE9BQU87SUFBSztBQUUzRCxJQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lhdG9vbHMtbmV4dC8uL25vZGVfbW9kdWxlcy91cmktanMvZGlzdC9lczUvdXJpLmFsbC5qcz9lN2ZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBVUkkuanMgdjQuNC4xIChjKSAyMDExIEdhcnkgQ291cnQuIExpY2Vuc2U6IGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC91cmktanMgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5VUkkgPSBnbG9iYWwuVVJJIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc2V0cyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBzZXRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChzZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2V0c1swXSA9IHNldHNbMF0uc2xpY2UoMCwgLTEpO1xuICAgICAgICB2YXIgeGwgPSBzZXRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIHggPSAxOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgc2V0c1t4XSA9IHNldHNbeF0uc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHNldHNbeGxdID0gc2V0c1t4bF0uc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBzZXRzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXRzWzBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YmV4cChzdHIpIHtcbiAgICByZXR1cm4gXCIoPzpcIiArIHN0ciArIFwiKVwiO1xufVxuZnVuY3Rpb24gdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gdW5kZWZpbmVkID8gXCJ1bmRlZmluZWRcIiA6IG8gPT09IG51bGwgPyBcIm51bGxcIiA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zcGxpdChcIiBcIikucG9wKCkuc3BsaXQoXCJdXCIpLnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvVXBwZXJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCA/IG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gb2JqIDogdHlwZW9mIG9iai5sZW5ndGggIT09IFwibnVtYmVyXCIgfHwgb2JqLnNwbGl0IHx8IG9iai5zZXRJbnRlcnZhbCB8fCBvYmouY2FsbCA/IFtvYmpdIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKSA6IFtdO1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gICAgdmFyIG9iaiA9IHRhcmdldDtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gYnVpbGRFeHBzKGlzSVJJKSB7XG4gICAgdmFyIEFMUEhBJCQgPSBcIltBLVphLXpdXCIsXG4gICAgICAgIENSJCA9IFwiW1xcXFx4MERdXCIsXG4gICAgICAgIERJR0lUJCQgPSBcIlswLTldXCIsXG4gICAgICAgIERRVU9URSQkID0gXCJbXFxcXHgyMl1cIixcbiAgICAgICAgSEVYRElHJCQgPSBtZXJnZShESUdJVCQkLCBcIltBLUZhLWZdXCIpLFxuICAgICAgICAvL2Nhc2UtaW5zZW5zaXRpdmVcbiAgICBMRiQkID0gXCJbXFxcXHgwQV1cIixcbiAgICAgICAgU1AkJCA9IFwiW1xcXFx4MjBdXCIsXG4gICAgICAgIFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKSxcbiAgICAgICAgLy9leHBhbmRlZFxuICAgIEdFTl9ERUxJTVMkJCA9IFwiW1xcXFw6XFxcXC9cXFxcP1xcXFwjXFxcXFtcXFxcXVxcXFxAXVwiLFxuICAgICAgICBTVUJfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCZcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw9XVwiLFxuICAgICAgICBSRVNFUlZFRCQkID0gbWVyZ2UoR0VOX0RFTElNUyQkLCBTVUJfREVMSU1TJCQpLFxuICAgICAgICBVQ1NDSEFSJCQgPSBpc0lSSSA/IFwiW1xcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXQsIGV4Y2x1ZGVzIGJpZGkgY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgSVBSSVZBVEUkJCA9IGlzSVJJID8gXCJbXFxcXHVFMDAwLVxcXFx1RjhGRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXRcbiAgICBVTlJFU0VSVkVEJCQgPSBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcLVxcXFwuXFxcXF9cXFxcfl1cIiwgVUNTQ0hBUiQkKSxcbiAgICAgICAgU0NIRU1FJCA9IHN1YmV4cChBTFBIQSQkICsgbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSArIFwiKlwiKSxcbiAgICAgICAgVVNFUklORk8kID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikpICsgXCIqXCIpLFxuICAgICAgICBERUNfT0NURVQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiWzEtOV1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBESUdJVCQkKSxcbiAgICAgICAgREVDX09DVEVUX1JFTEFYRUQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMD9bMS05XVwiICsgRElHSVQkJCkgKyBcInwwPzA/XCIgKyBESUdJVCQkKSxcbiAgICAgICAgLy9yZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICBJUFY0QUREUkVTUyQgPSBzdWJleHAoREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkKSxcbiAgICAgICAgSDE2JCA9IHN1YmV4cChIRVhESUckJCArIFwiezEsNH1cIiksXG4gICAgICAgIExTMzIkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiICsgSDE2JCkgKyBcInxcIiArIElQVjRBRERSRVNTJCksXG4gICAgICAgIElQVjZBRERSRVNTMSQgPSBzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Nn1cIiArIExTMzIkKSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICA2KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MyJCA9IHN1YmV4cChcIlxcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezV9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIFwiOjpcIiA1KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MzJCA9IHN1YmV4cChzdWJleHAoSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns0fVwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgICAgICAgICAgICAgICBoMTYgXSBcIjo6XCIgNCggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7M31cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Mn1cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoyKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMiggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNiQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsM31cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCArIFwiXFxcXDpcIiArIExTMzIkKSxcbiAgICAgICAgLy9bICozKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgaDE2IFwiOlwiICAgbHMzMlxuICAgIElQVjZBRERSRVNTNyQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNH1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjQoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgbHMzMlxuICAgIElQVjZBRERSRVNTOCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCksXG4gICAgICAgIC8vWyAqNSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBoMTZcbiAgICBJUFY2QUREUkVTUzkkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDZ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiksXG4gICAgICAgIC8vWyAqNiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiXG4gICAgSVBWNkFERFJFU1MkID0gc3ViZXhwKFtJUFY2QUREUkVTUzEkLCBJUFY2QUREUkVTUzIkLCBJUFY2QUREUkVTUzMkLCBJUFY2QUREUkVTUzQkLCBJUFY2QUREUkVTUzUkLCBJUFY2QUREUkVTUzYkLCBJUFY2QUREUkVTUzckLCBJUFY2QUREUkVTUzgkLCBJUFY2QUREUkVTUzkkXS5qb2luKFwifFwiKSksXG4gICAgICAgIFpPTkVJRCQgPSBzdWJleHAoc3ViZXhwKFVOUkVTRVJWRUQkJCArIFwifFwiICsgUENUX0VOQ09ERUQkKSArIFwiK1wiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWiQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgXCJcXFxcJTI1XCIgKyBaT05FSUQkKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWl9SRUxBWEVEJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFpPTkVJRCQpLFxuICAgICAgICAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIElQVkZVVFVSRSQgPSBzdWJleHAoXCJbdlZdXCIgKyBIRVhESUckJCArIFwiK1xcXFwuXCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpICsgXCIrXCIpLFxuICAgICAgICBJUF9MSVRFUkFMJCA9IHN1YmV4cChcIlxcXFxbXCIgKyBzdWJleHAoSVBWNkFERFJaX1JFTEFYRUQkICsgXCJ8XCIgKyBJUFY2QUREUkVTUyQgKyBcInxcIiArIElQVkZVVFVSRSQpICsgXCJcXFxcXVwiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIFJFR19OQU1FJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCkpICsgXCIqXCIpLFxuICAgICAgICBIT1NUJCA9IHN1YmV4cChJUF9MSVRFUkFMJCArIFwifFwiICsgSVBWNEFERFJFU1MkICsgXCIoPyFcIiArIFJFR19OQU1FJCArIFwiKVwiICsgXCJ8XCIgKyBSRUdfTkFNRSQpLFxuICAgICAgICBQT1JUJCA9IHN1YmV4cChESUdJVCQkICsgXCIqXCIpLFxuICAgICAgICBBVVRIT1JJVFkkID0gc3ViZXhwKHN1YmV4cChVU0VSSU5GTyQgKyBcIkBcIikgKyBcIj9cIiArIEhPU1QkICsgc3ViZXhwKFwiXFxcXDpcIiArIFBPUlQkKSArIFwiP1wiKSxcbiAgICAgICAgUENIQVIkID0gc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBdXCIpKSxcbiAgICAgICAgU0VHTUVOVCQgPSBzdWJleHAoUENIQVIkICsgXCIqXCIpLFxuICAgICAgICBTRUdNRU5UX05aJCA9IHN1YmV4cChQQ0hBUiQgKyBcIitcIiksXG4gICAgICAgIFNFR01FTlRfTlpfTkMkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcQF1cIikpICsgXCIrXCIpLFxuICAgICAgICBQQVRIX0FCRU1QVFkkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXCIgKyBTRUdNRU5UJCkgKyBcIipcIiksXG4gICAgICAgIFBBVEhfQUJTT0xVVEUkID0gc3ViZXhwKFwiXFxcXC9cIiArIHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpICsgXCI/XCIpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX05PU0NIRU1FJCA9IHN1YmV4cChTRUdNRU5UX05aX05DJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX1JPT1RMRVNTJCA9IHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX0VNUFRZJCA9IFwiKD8hXCIgKyBQQ0hBUiQgKyBcIilcIixcbiAgICAgICAgUEFUSCQgPSBzdWJleHAoUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBRVUVSWSQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFwiICsgbWVyZ2UoXCJbXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCkpICsgXCIqXCIpLFxuICAgICAgICBGUkFHTUVOVCQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFtcXFxcL1xcXFw/XVwiKSArIFwiKlwiKSxcbiAgICAgICAgSElFUl9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBVUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuICAgICAgICBSRUxBVElWRV9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBSRUxBVElWRSQgPSBzdWJleHAoUkVMQVRJVkVfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG4gICAgICAgIFVSSV9SRUZFUkVOQ0UkID0gc3ViZXhwKFVSSSQgKyBcInxcIiArIFJFTEFUSVZFJCksXG4gICAgICAgIEFCU09MVVRFX1VSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiKSxcbiAgICAgICAgR0VORVJJQ19SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBSRUxBVElWRV9SRUYkID0gXCJeKCl7MH1cIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIEFCU09MVVRFX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgU0FNRURPQ19SRUYkID0gXCJeXCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgQVVUSE9SSVRZX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPyRcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICBOT1RfU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIiksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1VTRVJJTkZPOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0hPU1Q6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXFtcXFxcXVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEg6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcOlxcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEhfTk9TQ0hFTUU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9RVUVSWTogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0ZSQUdNRU5UOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiKSwgXCJnXCIpLFxuICAgICAgICBFU0NBUEU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIFVOUkVTRVJWRUQ6IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIiksXG4gICAgICAgIE9USEVSX0NIQVJTOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBSRVNFUlZFRCQkKSwgXCJnXCIpLFxuICAgICAgICBQQ1RfRU5DT0RFRDogbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKSxcbiAgICAgICAgSVBWNEFERFJFU1M6IG5ldyBSZWdFeHAoXCJeKFwiICsgSVBWNEFERFJFU1MkICsgXCIpJFwiKSxcbiAgICAgICAgSVBWNkFERFJFU1M6IG5ldyBSZWdFeHAoXCJeXFxcXFs/KFwiICsgSVBWNkFERFJFU1MkICsgXCIpXCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBcIihcIiArIFpPTkVJRCQgKyBcIilcIikgKyBcIj9cXFxcXT8kXCIpIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgfTtcbn1cbnZhciBVUklfUFJPVE9DT0wgPSBidWlsZEV4cHMoZmFsc2UpO1xuXG52YXIgSVJJX1BST1RPQ09MID0gYnVpbGRFeHBzKHRydWUpO1xuXG52YXIgc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gIH1cbn07XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblxudmFyIG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xudmFyIGJhc2UgPSAzNjtcbnZhciB0TWluID0gMTtcbnZhciB0TWF4ID0gMjY7XG52YXIgc2tldyA9IDM4O1xudmFyIGRhbXAgPSA3MDA7XG52YXIgaW5pdGlhbEJpYXMgPSA3MjtcbnZhciBpbml0aWFsTiA9IDEyODsgLy8gMHg4MFxudmFyIGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xudmFyIHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xudmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXDAtXFx4N0VdLzsgLy8gbm9uLUFTQ0lJIGNoYXJzXG52YXIgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbnZhciBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG52YXIgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IkMSh0eXBlKSB7XG5cdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHR2YXIgcmVzdWx0ID0gJyc7XG5cdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdH1cblx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGNvdW50ZXIgPSAwO1xuXHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHR2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7XG5cdFx0XHRcdC8vIExvdyBzdXJyb2dhdGUuXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJdCdzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZVxuXHRcdFx0XHQvLyBuZXh0IGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBlbmNvZGVcbiAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG4gKi9cbnZhciB1Y3MyZW5jb2RlID0gZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCB0b0NvbnN1bWFibGVBcnJheShhcnJheSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG4gKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuICovXG52YXIgYmFzaWNUb0RpZ2l0ID0gZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRpZiAoY29kZVBvaW50IC0gMHgzMCA8IDB4MEEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHgxNjtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg0MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg0MTtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg2MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcblx0fVxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xudmFyIGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcbn07XG5cbi8qKlxuICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYWRhcHQgPSBmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0dmFyIGsgPSAwO1xuXHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdGZvciAoOyAvKiBubyBpbml0aWFsaXphdGlvbiAqL2RlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHR9XG5cdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdC8vIERvbid0IHVzZSBVQ1MtMi5cblx0dmFyIG91dHB1dCA9IFtdO1xuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdHZhciBpID0gMDtcblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0dmFyIGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAodmFyIGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yJDEoJ25vdC1iYXNpYycpO1xuXHRcdH1cblx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0fVxuXG5cdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRmb3IgKHZhciBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7KSAvKiBubyBmaW5hbCBleHByZXNzaW9uICove1xuXG5cdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHR2YXIgb2xkaSA9IGk7XG5cdFx0Zm9yICh2YXIgdyA9IDEsIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cblx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRlcnJvciQxKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG5cblx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblx0XHR9XG5cblx0XHR2YXIgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdGkgJT0gb3V0O1xuXG5cdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dC5cblx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCBvdXRwdXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblxuXHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuXHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdC8vIENhY2hlIHRoZSBsZW5ndGguXG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGRlbHRhID0gMDtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG5cdHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuXHR2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcblx0XHRcdHZhciBfY3VycmVudFZhbHVlMiA9IF9zdGVwLnZhbHVlO1xuXG5cdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZTIgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShfY3VycmVudFZhbHVlMikpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0X2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuXHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuXHRcdFx0XHRfaXRlcmF0b3IucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuXHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXHR2YXIgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aDtcblxuXHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG5cdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdH1cblxuXHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHR2YXIgbSA9IG1heEludDtcblx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuXHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcblx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjIgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuXHRcdFx0XHR2YXIgY3VycmVudFZhbHVlID0gX3N0ZXAyLnZhbHVlO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdy5cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IyLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdG4gPSBtO1xuXG5cdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcblx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG5cdFx0dmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IzID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcblx0XHRcdFx0dmFyIF9jdXJyZW50VmFsdWUgPSBfc3RlcDMudmFsdWU7XG5cblx0XHRcdFx0aWYgKF9jdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0XHR2YXIgcSA9IGRlbHRhO1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpKTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IzLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0KytkZWx0YTtcblx0XHQrK247XG5cdH1cblx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICogY29udmVydCB0byBVbmljb2RlLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gKiBzdHJpbmcuXG4gKi9cbnZhciB0b1VuaWNvZGUgPSBmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKSA/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSkgOiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xudmFyIHRvQVNDSUkgPSBmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZykgPyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKSA6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xudmFyIHB1bnljb2RlID0ge1xuXHQvKipcbiAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG4gICogQG1lbWJlck9mIHB1bnljb2RlXG4gICogQHR5cGUgU3RyaW5nXG4gICovXG5cdCd2ZXJzaW9uJzogJzIuMS4wJyxcblx0LyoqXG4gICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcbiAgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuICAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAqIEB0eXBlIE9iamVjdFxuICAqL1xuXHQndWNzMic6IHtcblx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHR9LFxuXHQnZGVjb2RlJzogZGVjb2RlLFxuXHQnZW5jb2RlJzogZW5jb2RlLFxuXHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcbn07XG5cbi8qKlxuICogVVJJLmpzXG4gKlxuICogQGZpbGVvdmVydmlldyBBbiBSRkMgMzk4NiBjb21wbGlhbnQsIHNjaGVtZSBleHRlbmRhYmxlIFVSSSBwYXJzaW5nL3ZhbGlkYXRpbmcvcmVzb2x2aW5nIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Z2FyeS5jb3VydEBnbWFpbC5jb21cIj5HYXJ5IENvdXJ0PC9hPlxuICogQHNlZSBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzXG4gKi9cbi8qKlxuICogQ29weXJpZ2h0IDIwMTEgR2FyeSBDb3VydC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcbiAqIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXG4gKiAgICAgICBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcbiAqICAgICAgIG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gKiAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBHQVJZIENPVVJUIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRFxuICogV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEdBUlkgQ09VUlQgT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG4gKiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG4gKiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUZcbiAqIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFRoZSB2aWV3cyBhbmQgY29uY2x1c2lvbnMgY29udGFpbmVkIGluIHRoZSBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBhcmUgdGhvc2Ugb2YgdGhlXG4gKiBhdXRob3JzIGFuZCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIHJlcHJlc2VudGluZyBvZmZpY2lhbCBwb2xpY2llcywgZWl0aGVyIGV4cHJlc3NlZFxuICogb3IgaW1wbGllZCwgb2YgR2FyeSBDb3VydC5cbiAqL1xudmFyIFNDSEVNRVMgPSB7fTtcbmZ1bmN0aW9uIHBjdEVuY0NoYXIoY2hyKSB7XG4gICAgdmFyIGMgPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgZSA9IHZvaWQgMDtcbiAgICBpZiAoYyA8IDE2KSBlID0gXCIlMFwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGlmIChjIDwgMTI4KSBlID0gXCIlXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgaWYgKGMgPCAyMDQ4KSBlID0gXCIlXCIgKyAoYyA+PiA2IHwgMTkyKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKGMgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBlID0gXCIlXCIgKyAoYyA+PiAxMiB8IDIyNCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjID4+IDYgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcGN0RGVjQ2hhcnMoc3RyKSB7XG4gICAgdmFyIG5ld1N0ciA9IFwiXCI7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpbCA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBpbCkge1xuICAgICAgICB2YXIgYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDEsIDIpLCAxNik7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDE5NCAmJiBjIDwgMjI0KSB7XG4gICAgICAgICAgICBpZiAoaWwgLSBpID49IDYpIHtcbiAgICAgICAgICAgICAgICB2YXIgYzIgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCBjMiAmIDYzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDY7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+PSAyMjQpIHtcbiAgICAgICAgICAgIGlmIChpbCAtIGkgPj0gOSkge1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGMzID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNywgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDE1KSA8PCAxMiB8IChfYyAmIDYzKSA8PCA2IHwgYzMgJiA2Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSA5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgMyk7XG4gICAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0cjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCkge1xuICAgIGZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgICAgIHZhciBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuICAgICAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChwcm90b2NvbC5VTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lKSBjb21wb25lbnRzLnNjaGVtZSA9IFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9TQ0hFTUUsIFwiXCIpO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMudXNlcmluZm8gPSBTdHJpbmcoY29tcG9uZW50cy51c2VyaW5mbykucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfVVNFUklORk8sIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuaG9zdCA9IFN0cmluZyhjb21wb25lbnRzLmhvc3QpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfSE9TVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5wYXRoID0gU3RyaW5nKGNvbXBvbmVudHMucGF0aCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShjb21wb25lbnRzLnNjaGVtZSA/IHByb3RvY29sLk5PVF9QQVRIIDogcHJvdG9jb2wuTk9UX1BBVEhfTk9TQ0hFTUUsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnF1ZXJ5ID0gU3RyaW5nKGNvbXBvbmVudHMucXVlcnkpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1FVRVJZLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5mcmFnbWVudCA9IFN0cmluZyhjb21wb25lbnRzLmZyYWdtZW50KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9GUkFHTUVOVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfc3RyaXBMZWFkaW5nWmVyb3Moc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eMCooLiopLywgXCIkMVwiKSB8fCBcIjBcIjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY0KGhvc3QsIHByb3RvY29sKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjRBRERSRVNTKSB8fCBbXTtcblxuICAgIHZhciBfbWF0Y2hlcyA9IHNsaWNlZFRvQXJyYXkobWF0Y2hlcywgMiksXG4gICAgICAgIGFkZHJlc3MgPSBfbWF0Y2hlc1sxXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzLnNwbGl0KFwiLlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKS5qb2luKFwiLlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2Nihob3N0LCBwcm90b2NvbCkge1xuICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY2QUREUkVTUykgfHwgW107XG5cbiAgICB2YXIgX21hdGNoZXMyID0gc2xpY2VkVG9BcnJheShtYXRjaGVzLCAzKSxcbiAgICAgICAgYWRkcmVzcyA9IF9tYXRjaGVzMlsxXSxcbiAgICAgICAgem9uZSA9IF9tYXRjaGVzMlsyXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkuc3BsaXQoJzo6JykucmV2ZXJzZSgpLFxuICAgICAgICAgICAgX2FkZHJlc3MkdG9Mb3dlckNhc2UkMiA9IHNsaWNlZFRvQXJyYXkoX2FkZHJlc3MkdG9Mb3dlckNhc2UkLCAyKSxcbiAgICAgICAgICAgIGxhc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzBdLFxuICAgICAgICAgICAgZmlyc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzFdO1xuXG4gICAgICAgIHZhciBmaXJzdEZpZWxkcyA9IGZpcnN0ID8gZmlyc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpIDogW107XG4gICAgICAgIHZhciBsYXN0RmllbGRzID0gbGFzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcyk7XG4gICAgICAgIHZhciBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID0gcHJvdG9jb2wuSVBWNEFERFJFU1MudGVzdChsYXN0RmllbGRzW2xhc3RGaWVsZHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB2YXIgZmllbGRDb3VudCA9IGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MgPyA3IDogODtcbiAgICAgICAgdmFyIGxhc3RGaWVsZHNTdGFydCA9IGxhc3RGaWVsZHMubGVuZ3RoIC0gZmllbGRDb3VudDtcbiAgICAgICAgdmFyIGZpZWxkcyA9IEFycmF5KGZpZWxkQ291bnQpO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGZpZWxkQ291bnQ7ICsreCkge1xuICAgICAgICAgICAgZmllbGRzW3hdID0gZmlyc3RGaWVsZHNbeF0gfHwgbGFzdEZpZWxkc1tsYXN0RmllbGRzU3RhcnQgKyB4XSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMYXN0RmllbGRJUHY0QWRkcmVzcykge1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkQ291bnQgLSAxXSA9IF9ub3JtYWxpemVJUHY0KGZpZWxkc1tmaWVsZENvdW50IC0gMV0sIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxsWmVyb0ZpZWxkcyA9IGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZmllbGQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkIHx8IGZpZWxkID09PSBcIjBcIikge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0TG9uZ2VzdCA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMb25nZXN0ICYmIGxhc3RMb25nZXN0LmluZGV4ICsgbGFzdExvbmdlc3QubGVuZ3RoID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TG9uZ2VzdC5sZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY2MucHVzaCh7IGluZGV4OiBpbmRleCwgbGVuZ3RoOiAxIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgdmFyIGxvbmdlc3RaZXJvRmllbGRzID0gYWxsWmVyb0ZpZWxkcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHZhciBuZXdIb3N0ID0gdm9pZCAwO1xuICAgICAgICBpZiAobG9uZ2VzdFplcm9GaWVsZHMgJiYgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIG5ld0ZpcnN0ID0gZmllbGRzLnNsaWNlKDAsIGxvbmdlc3RaZXJvRmllbGRzLmluZGV4KTtcbiAgICAgICAgICAgIHZhciBuZXdMYXN0ID0gZmllbGRzLnNsaWNlKGxvbmdlc3RaZXJvRmllbGRzLmluZGV4ICsgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld0hvc3QgPSBuZXdGaXJzdC5qb2luKFwiOlwiKSArIFwiOjpcIiArIG5ld0xhc3Quam9pbihcIjpcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdIb3N0ID0gZmllbGRzLmpvaW4oXCI6XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b25lKSB7XG4gICAgICAgICAgICBuZXdIb3N0ICs9IFwiJVwiICsgem9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SG9zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG52YXIgVVJJX1BBUlNFID0gL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KFteXFwvPyNAXSopQCk/KFxcW1teXFwvPyNcXF1dK1xcXXxbXlxcLz8jOl0qKSg/OlxcOihcXGQqKSk/KSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58XFxufFxccikqKSk/L2k7XG52YXIgTk9fTUFUQ0hfSVNfVU5ERUZJTkVEID0gXCJcIi5tYXRjaCgvKCl7MH0vKVsxXSA9PT0gdW5kZWZpbmVkO1xuZnVuY3Rpb24gcGFyc2UodXJpU3RyaW5nKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIGNvbXBvbmVudHMgPSB7fTtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSBcInN1ZmZpeFwiKSB1cmlTdHJpbmcgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArIFwiOlwiIDogXCJcIikgKyBcIi8vXCIgKyB1cmlTdHJpbmc7XG4gICAgdmFyIG1hdGNoZXMgPSB1cmlTdHJpbmcubWF0Y2goVVJJX1BBUlNFKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBpZiAoTk9fTUFUQ0hfSVNfVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAvL3N0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gbWF0Y2hlc1s3XTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBtYXRjaGVzWzhdO1xuICAgICAgICAgICAgLy9maXggcG9ydCBudW1iZXJcbiAgICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gbWF0Y2hlc1s1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vSUUgRklYIGZvciBpbXByb3BlciBSZWdFeHAgbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gdXJpU3RyaW5nLmluZGV4T2YoXCJAXCIpICE9PSAtMSA/IG1hdGNoZXNbM10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSB1cmlTdHJpbmcuaW5kZXhPZihcIi8vXCIpICE9PSAtMSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gdXJpU3RyaW5nLmluZGV4T2YoXCI/XCIpICE9PSAtMSA/IG1hdGNoZXNbN10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gdXJpU3RyaW5nLmluZGV4T2YoXCIjXCIpICE9PSAtMSA/IG1hdGNoZXNbOF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvL2ZpeCBwb3J0IG51bWJlclxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSB1cmlTdHJpbmcubWF0Y2goL1xcL1xcLyg/Oi58XFxuKSpcXDooPzpcXC98XFw/fFxcI3wkKS8pID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgICAgICAvL25vcm1hbGl6ZSBJUCBob3N0c1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoY29tcG9uZW50cy5ob3N0LCBwcm90b2NvbCksIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICAvL2RldGVybWluZSByZWZlcmVuY2UgdHlwZVxuICAgICAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5ob3N0ID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5wb3J0ID09PSB1bmRlZmluZWQgJiYgIWNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJzYW1lLWRvY3VtZW50XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInJlbGF0aXZlXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJ1cmlcIjtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gY29tcG9uZW50cy5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGlzIG5vdCBhIFwiICsgb3B0aW9ucy5yZWZlcmVuY2UgKyBcIiByZWZlcmVuY2UuXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9maW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIC8vY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG4gICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCBzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb252ZXJ0IElSSSAtPiBVUklcbiAgICAgICAgICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBVUklfUFJPVE9DT0wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9ub3JtYWxpemUgZW5jb2RpbmdzXG4gICAgICAgICAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuICAgICAgICB9XG4gICAgICAgIC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnBhcnNlKSB7XG4gICAgICAgICAgICBzY2hlbWVIYW5kbGVyLnBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy51c2VyaW5mbyk7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiQFwiKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIElQIGhvc3RzLCBhZGQgYnJhY2tldHMgYW5kIGVzY2FwZSB6b25lIHNlcGFyYXRvciBmb3IgSVB2NlxuICAgICAgICB1cmlUb2tlbnMucHVzaChfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChTdHJpbmcoY29tcG9uZW50cy5ob3N0KSwgcHJvdG9jb2wpLCBwcm90b2NvbCkucmVwbGFjZShwcm90b2NvbC5JUFY2QUREUkVTUywgZnVuY3Rpb24gKF8sICQxLCAkMikge1xuICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgJDEgKyAoJDIgPyBcIiUyNVwiICsgJDIgOiBcIlwiKSArIFwiXVwiO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChTdHJpbmcoY29tcG9uZW50cy5wb3J0KSk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oXCJcIikgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBSRFMxID0gL15cXC5cXC4/XFwvLztcbnZhciBSRFMyID0gL15cXC9cXC4oXFwvfCQpLztcbnZhciBSRFMzID0gL15cXC9cXC5cXC4oXFwvfCQpLztcbnZhciBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvO1xuZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMoaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgd2hpbGUgKGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMyKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzIsIFwiL1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMzKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzMsIFwiL1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5wb3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXCIuXCIgfHwgaW5wdXQgPT09IFwiLi5cIikge1xuICAgICAgICAgICAgaW5wdXQgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGltID0gaW5wdXQubWF0Y2goUkRTNSk7XG4gICAgICAgICAgICBpZiAoaW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGltWzBdO1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2Uocy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIC8vZmluZCBzY2hlbWUgaGFuZGxlclxuICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgLy9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgIGlmIChjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhbiBJUHY2IGFkZHJlc3NcbiAgICAgICAgaWYgKHByb3RvY29sLklQVjZBRERSRVNTLnRlc3QoY29tcG9uZW50cy5ob3N0KSkge31cbiAgICAgICAgLy9UT0RPOiBub3JtYWxpemUgSVB2NiBhZGRyZXNzIGFzIHBlciBSRkMgNTk1MlxuXG4gICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShjb21wb25lbnRzLmhvc3QpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvL25vcm1hbGl6ZSBlbmNvZGluZ1xuICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIGNvbXBvbmVudHMuc2NoZW1lKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuc2NoZW1lKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuICAgIH1cbiAgICB2YXIgYXV0aG9yaXR5ID0gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiKSB7XG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChcIi8vXCIpO1xuICAgICAgICB9XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSk7XG4gICAgICAgIGlmIChjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiL1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHMgPSBjb21wb25lbnRzLnBhdGg7XG4gICAgICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZVBhdGggJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLmFic29sdXRlUGF0aCkpIHtcbiAgICAgICAgICAgIHMgPSByZW1vdmVEb3RTZWdtZW50cyhzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0aG9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoL15cXC9cXC8vLCBcIi8lMkZcIik7IC8vZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICAgICAgfVxuICAgICAgICB1cmlUb2tlbnMucHVzaChzKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIj9cIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMucXVlcnkpO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiI1wiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5mcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMuam9pbihcIlwiKTsgLy9tZXJnZSB0b2tlbnMgaW50byBhIHN0cmluZ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50cyhiYXNlLCByZWxhdGl2ZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgc2tpcE5vcm1hbGl6YXRpb24gPSBhcmd1bWVudHNbM107XG5cbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgICAgICBiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKTsgLy9ub3JtYWxpemUgYmFzZSBjb21wb25lbnRzXG4gICAgICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucyk7IC8vbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudHNcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuICAgICAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lO1xuICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcbiAgICAgICAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcbiAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5wYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBcIi9cIiArIHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpICsgcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgICAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm87XG4gICAgICAgICAgICB0YXJnZXQuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcbiAgICB9XG4gICAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnQ7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShiYXNlVVJJLCByZWxhdGl2ZVVSSSwgb3B0aW9ucykge1xuICAgIHZhciBzY2hlbWVsZXNzT3B0aW9ucyA9IGFzc2lnbih7IHNjaGVtZTogJ251bGwnIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBzZXJpYWxpemUocmVzb2x2ZUNvbXBvbmVudHMocGFyc2UoYmFzZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBwYXJzZShyZWxhdGl2ZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBzY2hlbWVsZXNzT3B0aW9ucywgdHJ1ZSksIHNjaGVtZWxlc3NPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKHVyaSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaTtcbn1cblxuZnVuY3Rpb24gZXF1YWwodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpQSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmlBKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHVyaUEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHVyaUIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZShwYXJzZSh1cmlCLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpQikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZSh1cmlCLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaUEgPT09IHVyaUI7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLkVTQ0FQRSA6IElSSV9QUk9UT0NPTC5FU0NBUEUsIHBjdEVuY0NoYXIpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLlBDVF9FTkNPREVEIDogSVJJX1BST1RPQ09MLlBDVF9FTkNPREVELCBwY3REZWNDaGFycyk7XG59XG5cbnZhciBoYW5kbGVyID0ge1xuICAgIHNjaGVtZTogXCJodHRwXCIsXG4gICAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICAvL3JlcG9ydCBtaXNzaW5nIGhvc3RcbiAgICAgICAgaWYgKCFjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwiaHR0cHNcIjtcbiAgICAgICAgLy9ub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICAgICAgICBpZiAoY29tcG9uZW50cy5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBlbXB0eSBwYXRoXG4gICAgICAgIGlmICghY29tcG9uZW50cy5wYXRoKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICAvL05PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgICAgICAgLy9hcyBXV1cgRm9ybSBVcmwgRW5jb2RlZCBxdWVyeSBzdHJpbmdzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MNCsgc3BlYyxcbiAgICAgICAgLy9hbmQgbm90IHRoZSBIVFRQIHNwZWMuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBoYW5kbGVyJDEgPSB7XG4gICAgc2NoZW1lOiBcImh0dHBzXCIsXG4gICAgZG9tYWluSG9zdDogaGFuZGxlci5kb21haW5Ib3N0LFxuICAgIHBhcnNlOiBoYW5kbGVyLnBhcnNlLFxuICAgIHNlcmlhbGl6ZTogaGFuZGxlci5zZXJpYWxpemVcbn07XG5cbmZ1bmN0aW9uIGlzU2VjdXJlKHdzQ29tcG9uZW50cykge1xuICAgIHJldHVybiB0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nID8gd3NDb21wb25lbnRzLnNlY3VyZSA6IFN0cmluZyh3c0NvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSBcIndzc1wiO1xufVxuLy9SRkMgNjQ1NVxudmFyIGhhbmRsZXIkMiA9IHtcbiAgICBzY2hlbWU6IFwid3NcIixcbiAgICBkb21haW5Ib3N0OiB0cnVlLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB3c0NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICAvL2luZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgICAgICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IGlzU2VjdXJlKHdzQ29tcG9uZW50cyk7XG4gICAgICAgIC8vY29uc3RydWN0IHJlc291Y2UgbmFtZVxuICAgICAgICB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gKHdzQ29tcG9uZW50cy5wYXRoIHx8ICcvJykgKyAod3NDb21wb25lbnRzLnF1ZXJ5ID8gJz8nICsgd3NDb21wb25lbnRzLnF1ZXJ5IDogJycpO1xuICAgICAgICB3c0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3NDb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUod3NDb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgICAgICAgaWYgKHdzQ29tcG9uZW50cy5wb3J0ID09PSAoaXNTZWN1cmUod3NDb21wb25lbnRzKSA/IDQ0MyA6IDgwKSB8fCB3c0NvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9lbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgICAgICAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5zY2hlbWUgPSB3c0NvbXBvbmVudHMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL3JlY29uc3RydWN0IHBhdGggZnJvbSByZXNvdXJjZSBuYW1lXG4gICAgICAgIGlmICh3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lKSB7XG4gICAgICAgICAgICB2YXIgX3dzQ29tcG9uZW50cyRyZXNvdXJjID0gd3NDb21wb25lbnRzLnJlc291cmNlTmFtZS5zcGxpdCgnPycpLFxuICAgICAgICAgICAgICAgIF93c0NvbXBvbmVudHMkcmVzb3VyYzIgPSBzbGljZWRUb0FycmF5KF93c0NvbXBvbmVudHMkcmVzb3VyYywgMiksXG4gICAgICAgICAgICAgICAgcGF0aCA9IF93c0NvbXBvbmVudHMkcmVzb3VyYzJbMF0sXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBfd3NDb21wb25lbnRzJHJlc291cmMyWzFdO1xuXG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucGF0aCA9IHBhdGggJiYgcGF0aCAhPT0gJy8nID8gcGF0aCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL2ZvcmJpZCBmcmFnbWVudCBjb21wb25lbnRcbiAgICAgICAgd3NDb21wb25lbnRzLmZyYWdtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3NDb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBoYW5kbGVyJDMgPSB7XG4gICAgc2NoZW1lOiBcIndzc1wiLFxuICAgIGRvbWFpbkhvc3Q6IGhhbmRsZXIkMi5kb21haW5Ib3N0LFxuICAgIHBhcnNlOiBoYW5kbGVyJDIucGFyc2UsXG4gICAgc2VyaWFsaXplOiBoYW5kbGVyJDIuc2VyaWFsaXplXG59O1xuXG52YXIgTyA9IHt9O1xudmFyIGlzSVJJID0gdHJ1ZTtcbi8vUkZDIDM5ODZcbnZhciBVTlJFU0VSVkVEJCQgPSBcIltBLVphLXowLTlcXFxcLVxcXFwuXFxcXF9cXFxcflwiICsgKGlzSVJJID8gXCJcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZcIiA6IFwiXCIpICsgXCJdXCI7XG52YXIgSEVYRElHJCQgPSBcIlswLTlBLUZhLWZdXCI7IC8vY2FzZS1pbnNlbnNpdGl2ZVxudmFyIFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKTsgLy9leHBhbmRlZFxuLy9SRkMgNTMyMiwgZXhjZXB0IHRoZXNlIHN5bWJvbHMgYXMgcGVyIFJGQyA2MDY4OiBAIDogLyA/ICMgWyBdICYgOyA9XG4vL2NvbnN0IEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcL1xcXFw9XFxcXD9cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FURVhUJCQgPSBcIltcXFxceDAxLVxcXFx4MDhcXFxceDBCXFxcXHgwQ1xcXFx4MEUtXFxcXHgxRlxcXFx4N0ZdXCI7ICAvLyglZDEtOCAvICVkMTEtMTIgLyAlZDE0LTMxIC8gJWQxMjcpXG4vL2NvbnN0IFFURVhUJCQgPSBtZXJnZShcIltcXFxceDIxXFxcXHgyMy1cXFxceDVCXFxcXHg1RC1cXFxceDdFXVwiLCBPQlNfUVRFWFQkJCk7ICAvLyVkMzMgLyAlZDM1LTkxIC8gJWQ5My0xMjYgLyBvYnMtcXRleHRcbi8vY29uc3QgVkNIQVIkJCA9IFwiW1xcXFx4MjEtXFxcXHg3RV1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FQJCA9IHN1YmV4cChcIlxcXFxcXFxcXCIgKyBtZXJnZShcIltcXFxceDAwXFxcXHgwRFxcXFx4MEFdXCIsIE9CU19RVEVYVCQkKSk7ICAvLyVkMCAvIENSIC8gTEYgLyBvYnMtcXRleHRcbi8vY29uc3QgRldTJCA9IHN1YmV4cChzdWJleHAoV1NQJCQgKyBcIipcIiArIFwiXFxcXHgwRFxcXFx4MEFcIikgKyBcIj9cIiArIFdTUCQkICsgXCIrXCIpO1xuLy9jb25zdCBRVU9URURfUEFJUiQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXFxcXFxcIiArIHN1YmV4cChWQ0hBUiQkICsgXCJ8XCIgKyBXU1AkJCkpICsgXCJ8XCIgKyBPQlNfUVAkKTtcbi8vY29uc3QgUVVPVEVEX1NUUklORyQgPSBzdWJleHAoJ1xcXFxcIicgKyBzdWJleHAoRldTJCArIFwiP1wiICsgUUNPTlRFTlQkKSArIFwiKlwiICsgRldTJCArIFwiP1wiICsgJ1xcXFxcIicpO1xudmFyIEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xudmFyIFFURVhUJCQgPSBcIltcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLVxcXFwuMC05XFxcXDxcXFxcPkEtWlxcXFx4NUUtXFxcXHg3RV1cIjtcbnZhciBWQ0hBUiQkID0gbWVyZ2UoUVRFWFQkJCwgXCJbXFxcXFxcXCJcXFxcXFxcXF1cIik7XG52YXIgU09NRV9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw6XFxcXEBdXCI7XG52YXIgVU5SRVNFUlZFRCA9IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIik7XG52YXIgUENUX0VOQ09ERUQgPSBuZXcgUmVnRXhwKFBDVF9FTkNPREVEJCwgXCJnXCIpO1xudmFyIE5PVF9MT0NBTF9QQVJUID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgJ1tcXFxcXCJdJywgVkNIQVIkJCksIFwiZ1wiKTtcbnZhciBOT1RfSEZOQU1FID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBVTlJFU0VSVkVEJCQsIFNPTUVfREVMSU1TJCQpLCBcImdcIik7XG52YXIgTk9UX0hGVkFMVUUgPSBOT1RfSEZOQU1FO1xuZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZChzdHIpIHtcbiAgICB2YXIgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcbiAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChVTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbn1cbnZhciBoYW5kbGVyJDQgPSB7XG4gICAgc2NoZW1lOiBcIm1haWx0b1wiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSQkMShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYWlsdG9Db21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdmFyIHRvID0gbWFpbHRvQ29tcG9uZW50cy50byA9IG1haWx0b0NvbXBvbmVudHMucGF0aCA/IG1haWx0b0NvbXBvbmVudHMucGF0aC5zcGxpdChcIixcIikgOiBbXTtcbiAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5xdWVyeSkge1xuICAgICAgICAgICAgdmFyIHVua25vd25IZWFkZXJzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgdmFyIGhmaWVsZHMgPSBtYWlsdG9Db21wb25lbnRzLnF1ZXJ5LnNwbGl0KFwiJlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCB4bCA9IGhmaWVsZHMubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgICAgIHZhciBoZmllbGQgPSBoZmllbGRzW3hdLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGhmaWVsZFswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b0FkZHJzID0gaGZpZWxkWzFdLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF94ID0gMCwgX3hsID0gdG9BZGRycy5sZW5ndGg7IF94IDwgX3hsOyArK194KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8ucHVzaCh0b0FkZHJzW194XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1YmplY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuYm9keSA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVua25vd25IZWFkZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzBdLCBvcHRpb25zKV0gPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVua25vd25IZWFkZXJzKSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIG1haWx0b0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAodmFyIF94MiA9IDAsIF94bDIgPSB0by5sZW5ndGg7IF94MiA8IF94bDI7ICsrX3gyKSB7XG4gICAgICAgICAgICB2YXIgYWRkciA9IHRvW194Ml0uc3BsaXQoXCJAXCIpO1xuICAgICAgICAgICAgYWRkclswXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMF0pO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJbMV0gPSBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5lcnJvciA9IG1haWx0b0NvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRyWzFdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvW194Ml0gPSBhZGRyLmpvaW4oXCJAXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWlsdG9Db21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUkJDEobWFpbHRvQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IG1haWx0b0NvbXBvbmVudHM7XG4gICAgICAgIHZhciB0byA9IHRvQXJyYXkobWFpbHRvQ29tcG9uZW50cy50byk7XG4gICAgICAgIGlmICh0bykge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsID0gdG8ubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgICAgIHZhciB0b0FkZHIgPSBTdHJpbmcodG9beF0pO1xuICAgICAgICAgICAgICAgIHZhciBhdElkeCA9IHRvQWRkci5sYXN0SW5kZXhPZihcIkBcIik7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUGFydCA9IHRvQWRkci5zbGljZSgwLCBhdElkeCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0xPQ0FMX1BBUlQsIHBjdEVuY0NoYXIpO1xuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSB0b0FkZHIuc2xpY2UoYXRJZHggKyAxKTtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoZG9tYWluLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShkb21haW4pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvW3hdID0gbG9jYWxQYXJ0ICsgXCJAXCIgKyBkb21haW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSB0by5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCkgaGVhZGVyc1tcInN1YmplY3RcIl0gPSBtYWlsdG9Db21wb25lbnRzLnN1YmplY3Q7XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLmJvZHkpIGhlYWRlcnNbXCJib2R5XCJdID0gbWFpbHRvQ29tcG9uZW50cy5ib2R5O1xuICAgICAgICB2YXIgZmllbGRzID0gW107XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbbmFtZV0gIT09IE9bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChuYW1lLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRk5BTUUsIHBjdEVuY0NoYXIpICsgXCI9XCIgKyBoZWFkZXJzW25hbWVdLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRlZBTFVFLCBwY3RFbmNDaGFyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSBmaWVsZHMuam9pbihcIiZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIFVSTl9QQVJTRSA9IC9eKFteXFw6XSspXFw6KC4qKS87XG4vL1JGQyAyMTQxXG52YXIgaGFuZGxlciQ1ID0ge1xuICAgIHNjaGVtZTogXCJ1cm5cIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UkJDEoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGgubWF0Y2goVVJOX1BBUlNFKTtcbiAgICAgICAgdmFyIHVybkNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgdmFyIHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG4gICAgICAgICAgICB2YXIgbmlkID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIG5zcyA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICB2YXIgdXJuU2NoZW1lID0gc2NoZW1lICsgXCI6XCIgKyAob3B0aW9ucy5uaWQgfHwgbmlkKTtcbiAgICAgICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5uaWQgPSBuaWQ7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLm5zcyA9IG5zcztcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIucGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLmVycm9yID0gdXJuQ29tcG9uZW50cy5lcnJvciB8fCBcIlVSTiBjYW4gbm90IGJlIHBhcnNlZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplJCQxKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG4gICAgICAgIHZhciBuaWQgPSB1cm5Db21wb25lbnRzLm5pZDtcbiAgICAgICAgdmFyIHVyblNjaGVtZSA9IHNjaGVtZSArIFwiOlwiICsgKG9wdGlvbnMubmlkIHx8IG5pZCk7XG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmlDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cztcbiAgICAgICAgdmFyIG5zcyA9IHVybkNvbXBvbmVudHMubnNzO1xuICAgICAgICB1cmlDb21wb25lbnRzLnBhdGggPSAobmlkIHx8IG9wdGlvbnMubmlkKSArIFwiOlwiICsgbnNzO1xuICAgICAgICByZXR1cm4gdXJpQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgVVVJRCA9IC9eWzAtOUEtRmEtZl17OH0oPzpcXC1bMC05QS1GYS1mXXs0fSl7M31cXC1bMC05QS1GYS1mXXsxMn0kLztcbi8vUkZDIDQxMjJcbnZhciBoYW5kbGVyJDYgPSB7XG4gICAgc2NoZW1lOiBcInVybjp1dWlkXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHV1aWRDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cztcbiAgICAgICAgdXVpZENvbXBvbmVudHMudXVpZCA9IHV1aWRDb21wb25lbnRzLm5zcztcbiAgICAgICAgdXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50cy51dWlkIHx8ICF1dWlkQ29tcG9uZW50cy51dWlkLm1hdGNoKFVVSUQpKSkge1xuICAgICAgICAgICAgdXVpZENvbXBvbmVudHMuZXJyb3IgPSB1dWlkQ29tcG9uZW50cy5lcnJvciB8fCBcIlVVSUQgaXMgbm90IHZhbGlkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dWlkQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKHV1aWRDb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1cm5Db21wb25lbnRzID0gdXVpZENvbXBvbmVudHM7XG4gICAgICAgIC8vbm9ybWFsaXplIFVVSURcbiAgICAgICAgdXJuQ29tcG9uZW50cy5uc3MgPSAodXVpZENvbXBvbmVudHMudXVpZCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG5TQ0hFTUVTW2hhbmRsZXIuc2NoZW1lXSA9IGhhbmRsZXI7XG5TQ0hFTUVTW2hhbmRsZXIkMS5zY2hlbWVdID0gaGFuZGxlciQxO1xuU0NIRU1FU1toYW5kbGVyJDIuc2NoZW1lXSA9IGhhbmRsZXIkMjtcblNDSEVNRVNbaGFuZGxlciQzLnNjaGVtZV0gPSBoYW5kbGVyJDM7XG5TQ0hFTUVTW2hhbmRsZXIkNC5zY2hlbWVdID0gaGFuZGxlciQ0O1xuU0NIRU1FU1toYW5kbGVyJDUuc2NoZW1lXSA9IGhhbmRsZXIkNTtcblNDSEVNRVNbaGFuZGxlciQ2LnNjaGVtZV0gPSBoYW5kbGVyJDY7XG5cbmV4cG9ydHMuU0NIRU1FUyA9IFNDSEVNRVM7XG5leHBvcnRzLnBjdEVuY0NoYXIgPSBwY3RFbmNDaGFyO1xuZXhwb3J0cy5wY3REZWNDaGFycyA9IHBjdERlY0NoYXJzO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5yZW1vdmVEb3RTZWdtZW50cyA9IHJlbW92ZURvdFNlZ21lbnRzO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5leHBvcnRzLnJlc29sdmVDb21wb25lbnRzID0gcmVzb2x2ZUNvbXBvbmVudHM7XG5leHBvcnRzLnJlc29sdmUgPSByZXNvbHZlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmVxdWFsID0gZXF1YWw7XG5leHBvcnRzLmVzY2FwZUNvbXBvbmVudCA9IGVzY2FwZUNvbXBvbmVudDtcbmV4cG9ydHMudW5lc2NhcGVDb21wb25lbnQgPSB1bmVzY2FwZUNvbXBvbmVudDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS5hbGwuanMubWFwXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJVUkkiLCJtZXJnZSIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzZXRzIiwiQXJyYXkiLCJfa2V5Iiwic2xpY2UiLCJ4bCIsIngiLCJqb2luIiwic3ViZXhwIiwic3RyIiwidHlwZU9mIiwibyIsInVuZGVmaW5lZCIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInNwbGl0IiwicG9wIiwic2hpZnQiLCJ0b0xvd2VyQ2FzZSIsInRvVXBwZXJDYXNlIiwidG9BcnJheSIsIm9iaiIsInNldEludGVydmFsIiwiYXNzaWduIiwidGFyZ2V0Iiwic291cmNlIiwia2V5IiwiYnVpbGRFeHBzIiwiaXNJUkkiLCJBTFBIQSQkIiwiQ1IkIiwiRElHSVQkJCIsIkRRVU9URSQkIiwiSEVYRElHJCQiLCJMRiQkIiwiU1AkJCIsIlBDVF9FTkNPREVEJCIsIkdFTl9ERUxJTVMkJCIsIlNVQl9ERUxJTVMkJCIsIlJFU0VSVkVEJCQiLCJVQ1NDSEFSJCQiLCJJUFJJVkFURSQkIiwiVU5SRVNFUlZFRCQkIiwiU0NIRU1FJCIsIlVTRVJJTkZPJCIsIkRFQ19PQ1RFVCQiLCJERUNfT0NURVRfUkVMQVhFRCQiLCJJUFY0QUREUkVTUyQiLCJIMTYkIiwiTFMzMiQiLCJJUFY2QUREUkVTUzEkIiwiSVBWNkFERFJFU1MyJCIsIklQVjZBRERSRVNTMyQiLCJJUFY2QUREUkVTUzQkIiwiSVBWNkFERFJFU1M1JCIsIklQVjZBRERSRVNTNiQiLCJJUFY2QUREUkVTUzckIiwiSVBWNkFERFJFU1M4JCIsIklQVjZBRERSRVNTOSQiLCJJUFY2QUREUkVTUyQiLCJaT05FSUQkIiwiSVBWNkFERFJaJCIsIklQVjZBRERSWl9SRUxBWEVEJCIsIklQVkZVVFVSRSQiLCJJUF9MSVRFUkFMJCIsIlJFR19OQU1FJCIsIkhPU1QkIiwiUE9SVCQiLCJBVVRIT1JJVFkkIiwiUENIQVIkIiwiU0VHTUVOVCQiLCJTRUdNRU5UX05aJCIsIlNFR01FTlRfTlpfTkMkIiwiUEFUSF9BQkVNUFRZJCIsIlBBVEhfQUJTT0xVVEUkIiwiUEFUSF9OT1NDSEVNRSQiLCJQQVRIX1JPT1RMRVNTJCIsIlBBVEhfRU1QVFkkIiwiUEFUSCQiLCJRVUVSWSQiLCJGUkFHTUVOVCQiLCJISUVSX1BBUlQkIiwiVVJJJCIsIlJFTEFUSVZFX1BBUlQkIiwiUkVMQVRJVkUkIiwiVVJJX1JFRkVSRU5DRSQiLCJBQlNPTFVURV9VUkkkIiwiR0VORVJJQ19SRUYkIiwiUkVMQVRJVkVfUkVGJCIsIkFCU09MVVRFX1JFRiQiLCJTQU1FRE9DX1JFRiQiLCJBVVRIT1JJVFlfUkVGJCIsIk5PVF9TQ0hFTUUiLCJSZWdFeHAiLCJOT1RfVVNFUklORk8iLCJOT1RfSE9TVCIsIk5PVF9QQVRIIiwiTk9UX1BBVEhfTk9TQ0hFTUUiLCJOT1RfUVVFUlkiLCJOT1RfRlJBR01FTlQiLCJFU0NBUEUiLCJVTlJFU0VSVkVEIiwiT1RIRVJfQ0hBUlMiLCJQQ1RfRU5DT0RFRCIsIklQVjRBRERSRVNTIiwiSVBWNkFERFJFU1MiLCJVUklfUFJPVE9DT0wiLCJJUklfUFJPVE9DT0wiLCJzbGljZWRUb0FycmF5Iiwic2xpY2VJdGVyYXRvciIsImFyciIsImkiLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwiX2kiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9zIiwibmV4dCIsImRvbmUiLCJwdXNoIiwidmFsdWUiLCJlcnIiLCJpc0FycmF5IiwiVHlwZUVycm9yIiwidG9Db25zdW1hYmxlQXJyYXkiLCJhcnIyIiwiZnJvbSIsIm1heEludCIsImJhc2UiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsImZsb29yIiwiTWF0aCIsInN0cmluZ0Zyb21DaGFyQ29kZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImVycm9yJDEiLCJ0eXBlIiwiUmFuZ2VFcnJvciIsIm1hcCIsImFycmF5IiwiZm4iLCJyZXN1bHQiLCJtYXBEb21haW4iLCJzdHJpbmciLCJwYXJ0cyIsInJlcGxhY2UiLCJsYWJlbHMiLCJlbmNvZGVkIiwidWNzMmRlY29kZSIsIm91dHB1dCIsImNvdW50ZXIiLCJjaGFyQ29kZUF0IiwiZXh0cmEiLCJ1Y3MyZW5jb2RlIiwiZnJvbUNvZGVQb2ludCIsImFwcGx5IiwiYmFzaWNUb0RpZ2l0IiwiY29kZVBvaW50IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImsiLCJkZWNvZGUiLCJpbnB1dCIsImlucHV0TGVuZ3RoIiwibiIsImJpYXMiLCJiYXNpYyIsImxhc3RJbmRleE9mIiwiaiIsImluZGV4Iiwib2xkaSIsInciLCJ0IiwiYmFzZU1pbnVzVCIsIm91dCIsInNwbGljZSIsImVuY29kZSIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24iLCJfZGlkSXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJfY3VycmVudFZhbHVlMiIsInJldHVybiIsImJhc2ljTGVuZ3RoIiwiaGFuZGxlZENQQ291bnQiLCJtIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIiLCJfZGlkSXRlcmF0b3JFcnJvcjIiLCJfaXRlcmF0b3JFcnJvcjIiLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMiLCJfZGlkSXRlcmF0b3JFcnJvcjMiLCJfaXRlcmF0b3JFcnJvcjMiLCJfaXRlcmF0b3IzIiwiX3N0ZXAzIiwiX2N1cnJlbnRWYWx1ZSIsInEiLCJxTWludXNUIiwidG9Vbmljb2RlIiwidGVzdCIsInRvQVNDSUkiLCJwdW55Y29kZSIsIlNDSEVNRVMiLCJwY3RFbmNDaGFyIiwiY2hyIiwiYyIsImUiLCJwY3REZWNDaGFycyIsIm5ld1N0ciIsImlsIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJjMiIsIl9jIiwiYzMiLCJfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmciLCJjb21wb25lbnRzIiwicHJvdG9jb2wiLCJkZWNvZGVVbnJlc2VydmVkIiwiZGVjU3RyIiwibWF0Y2giLCJzY2hlbWUiLCJ1c2VyaW5mbyIsImhvc3QiLCJwYXRoIiwicXVlcnkiLCJmcmFnbWVudCIsIl9zdHJpcExlYWRpbmdaZXJvcyIsIl9ub3JtYWxpemVJUHY0IiwibWF0Y2hlcyIsIl9tYXRjaGVzIiwiYWRkcmVzcyIsIl9ub3JtYWxpemVJUHY2IiwiX21hdGNoZXMyIiwiem9uZSIsIl9hZGRyZXNzJHRvTG93ZXJDYXNlJCIsInJldmVyc2UiLCJfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyIiwibGFzdCIsImZpcnN0IiwiZmlyc3RGaWVsZHMiLCJsYXN0RmllbGRzIiwiaXNMYXN0RmllbGRJUHY0QWRkcmVzcyIsImZpZWxkQ291bnQiLCJsYXN0RmllbGRzU3RhcnQiLCJmaWVsZHMiLCJhbGxaZXJvRmllbGRzIiwicmVkdWNlIiwiYWNjIiwiZmllbGQiLCJsYXN0TG9uZ2VzdCIsImxvbmdlc3RaZXJvRmllbGRzIiwic29ydCIsImEiLCJiIiwibmV3SG9zdCIsIm5ld0ZpcnN0IiwibmV3TGFzdCIsIlVSSV9QQVJTRSIsIk5PX01BVENIX0lTX1VOREVGSU5FRCIsInBhcnNlIiwidXJpU3RyaW5nIiwib3B0aW9ucyIsImlyaSIsInJlZmVyZW5jZSIsInBvcnQiLCJpc05hTiIsImluZGV4T2YiLCJlcnJvciIsInNjaGVtZUhhbmRsZXIiLCJ1bmljb2RlU3VwcG9ydCIsImRvbWFpbkhvc3QiLCJfcmVjb21wb3NlQXV0aG9yaXR5IiwidXJpVG9rZW5zIiwiXyIsIiQxIiwiJDIiLCJSRFMxIiwiUkRTMiIsIlJEUzMiLCJSRFM1IiwicmVtb3ZlRG90U2VnbWVudHMiLCJpbSIsInMiLCJFcnJvciIsInNlcmlhbGl6ZSIsImF1dGhvcml0eSIsImNoYXJBdCIsImFic29sdXRlUGF0aCIsInJlc29sdmVDb21wb25lbnRzIiwicmVsYXRpdmUiLCJza2lwTm9ybWFsaXphdGlvbiIsInRvbGVyYW50IiwicmVzb2x2ZSIsImJhc2VVUkkiLCJyZWxhdGl2ZVVSSSIsInNjaGVtZWxlc3NPcHRpb25zIiwibm9ybWFsaXplIiwidXJpIiwiZXF1YWwiLCJ1cmlBIiwidXJpQiIsImVzY2FwZUNvbXBvbmVudCIsInVuZXNjYXBlQ29tcG9uZW50IiwiaGFuZGxlciIsInNlY3VyZSIsImhhbmRsZXIkMSIsImlzU2VjdXJlIiwid3NDb21wb25lbnRzIiwiaGFuZGxlciQyIiwicmVzb3VyY2VOYW1lIiwiX3dzQ29tcG9uZW50cyRyZXNvdXJjIiwiX3dzQ29tcG9uZW50cyRyZXNvdXJjMiIsImhhbmRsZXIkMyIsIk8iLCJBVEVYVCQkIiwiUVRFWFQkJCIsIlZDSEFSJCQiLCJTT01FX0RFTElNUyQkIiwiTk9UX0xPQ0FMX1BBUlQiLCJOT1RfSEZOQU1FIiwiTk9UX0hGVkFMVUUiLCJoYW5kbGVyJDQiLCJwYXJzZSQkMSIsIm1haWx0b0NvbXBvbmVudHMiLCJ0byIsInVua25vd25IZWFkZXJzIiwiaGVhZGVycyIsImhmaWVsZHMiLCJoZmllbGQiLCJ0b0FkZHJzIiwiX3giLCJfeGwiLCJzdWJqZWN0IiwiYm9keSIsIl94MiIsIl94bDIiLCJhZGRyIiwic2VyaWFsaXplJCQxIiwidG9BZGRyIiwiYXRJZHgiLCJsb2NhbFBhcnQiLCJkb21haW4iLCJuYW1lIiwiVVJOX1BBUlNFIiwiaGFuZGxlciQ1IiwidXJuQ29tcG9uZW50cyIsIm5pZCIsIm5zcyIsInVyblNjaGVtZSIsInVyaUNvbXBvbmVudHMiLCJVVUlEIiwiaGFuZGxlciQ2IiwidXVpZENvbXBvbmVudHMiLCJ1dWlkIiwiZGVmaW5lUHJvcGVydHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uri-js/dist/es5/uri.all.js\n");

/***/ })

};
;