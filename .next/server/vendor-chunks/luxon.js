"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/luxon";
exports.ids = ["vendor-chunks/luxon"];
exports.modules = {

/***/ "(rsc)/./node_modules/luxon/src/datetime.js":
/*!********************************************!*\
  !*** ./node_modules/luxon/src/datetime.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DateTime),\n/* harmony export */   friendlyDateTime: () => (/* binding */ friendlyDateTime)\n/* harmony export */ });\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./duration.js */ \"(rsc)/./node_modules/luxon/src/duration.js\");\n/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./interval.js */ \"(rsc)/./node_modules/luxon/src/interval.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./settings.js */ \"(rsc)/./node_modules/luxon/src/settings.js\");\n/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./info.js */ \"(rsc)/./node_modules/luxon/src/info.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/formatter.js */ \"(rsc)/./node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./zones/fixedOffsetZone.js */ \"(rsc)/./node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/locale.js */ \"(rsc)/./node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/util.js */ \"(rsc)/./node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(rsc)/./node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_diff_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./impl/diff.js */ \"(rsc)/./node_modules/luxon/src/impl/diff.js\");\n/* harmony import */ var _impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./impl/regexParser.js */ \"(rsc)/./node_modules/luxon/src/impl/regexParser.js\");\n/* harmony import */ var _impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./impl/tokenParser.js */ \"(rsc)/./node_modules/luxon/src/impl/tokenParser.js\");\n/* harmony import */ var _impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./impl/conversions.js */ \"(rsc)/./node_modules/luxon/src/impl/conversions.js\");\n/* harmony import */ var _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./impl/formats.js */ \"(rsc)/./node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./impl/invalid.js */ \"(rsc)/./node_modules/luxon/src/impl/invalid.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst INVALID = \"Invalid DateTime\";\nconst MAX_DATE = 8.64e15;\nfunction unsupportedZone(zone) {\n    return new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"unsupported zone\", `the zone \"${zone.name}\" is not supported`);\n}\n// we cache week data on the DT object and this intermediates the cache\nfunction possiblyCachedWeekData(dt) {\n    if (dt.weekData === null) {\n        dt.weekData = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.gregorianToWeek)(dt.c);\n    }\n    return dt.weekData;\n}\n// clone really means, \"make a new object with these modifications\". all \"setters\" really use this\n// to create a new object while only changing some of the properties\nfunction clone(inst, alts) {\n    const current = {\n        ts: inst.ts,\n        zone: inst.zone,\n        c: inst.c,\n        o: inst.o,\n        loc: inst.loc,\n        invalid: inst.invalid\n    };\n    return new DateTime(Object.assign({}, current, alts, {\n        old: current\n    }));\n}\n// find the right offset a given local time. The o input is our guess, which determines which\n// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)\nfunction fixOffset(localTS, o, tz) {\n    // Our UTC time is just a guess because our offset is just a guess\n    let utcGuess = localTS - o * 60 * 1000;\n    // Test whether the zone matches the offset for this ts\n    const o2 = tz.offset(utcGuess);\n    // If so, offset didn't change and we're done\n    if (o === o2) {\n        return [\n            utcGuess,\n            o\n        ];\n    }\n    // If not, change the ts by the difference in the offset\n    utcGuess -= (o2 - o) * 60 * 1000;\n    // If that gives us the local time we want, we're done\n    const o3 = tz.offset(utcGuess);\n    if (o2 === o3) {\n        return [\n            utcGuess,\n            o2\n        ];\n    }\n    // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time\n    return [\n        localTS - Math.min(o2, o3) * 60 * 1000,\n        Math.max(o2, o3)\n    ];\n}\n// convert an epoch timestamp into a calendar object with the given offset\nfunction tsToObj(ts, offset) {\n    ts += offset * 60 * 1000;\n    const d = new Date(ts);\n    return {\n        year: d.getUTCFullYear(),\n        month: d.getUTCMonth() + 1,\n        day: d.getUTCDate(),\n        hour: d.getUTCHours(),\n        minute: d.getUTCMinutes(),\n        second: d.getUTCSeconds(),\n        millisecond: d.getUTCMilliseconds()\n    };\n}\n// convert a calendar object to a epoch timestamp\nfunction objToTS(obj, offset, zone) {\n    return fixOffset((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.objToLocalTS)(obj), offset, zone);\n}\n// create a new DT instance by adding a duration, adjusting for DSTs\nfunction adjustTime(inst, dur) {\n    const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = Object.assign({}, inst.c, {\n        year,\n        month,\n        day: Math.min(inst.c.day, (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.daysInMonth)(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7\n    }), millisToAdd = _duration_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromObject({\n        years: dur.years - Math.trunc(dur.years),\n        quarters: dur.quarters - Math.trunc(dur.quarters),\n        months: dur.months - Math.trunc(dur.months),\n        weeks: dur.weeks - Math.trunc(dur.weeks),\n        days: dur.days - Math.trunc(dur.days),\n        hours: dur.hours,\n        minutes: dur.minutes,\n        seconds: dur.seconds,\n        milliseconds: dur.milliseconds\n    }).as(\"milliseconds\"), localTS = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.objToLocalTS)(c);\n    let [ts, o] = fixOffset(localTS, oPre, inst.zone);\n    if (millisToAdd !== 0) {\n        ts += millisToAdd;\n        // that could have changed the offset by going over a DST, but we want to keep the ts the same\n        o = inst.zone.offset(ts);\n    }\n    return {\n        ts,\n        o\n    };\n}\n// helper useful in turning the results of parsing into real dates\n// by handling the zone options\nfunction parseDataToDateTime(parsed, parsedZone, opts, format, text) {\n    const { setZone, zone } = opts;\n    if (parsed && Object.keys(parsed).length !== 0) {\n        const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(Object.assign(parsed, opts, {\n            zone: interpretationZone,\n            // setZone is a valid option in the calling methods, but not in fromObject\n            setZone: undefined\n        }));\n        return setZone ? inst : inst.setZone(zone);\n    } else {\n        return DateTime.invalid(new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"unparsable\", `the input \"${text}\" can't be parsed as ${format}`));\n    }\n}\n// if you want to output a technical format (e.g. RFC 2822), this helper\n// helps handle the details\nfunction toTechFormat(dt, format, allowZ = true) {\n    return dt.isValid ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(_impl_locale_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].create(\"en-US\"), {\n        allowZ,\n        forceSimple: true\n    }).formatDateTimeFromString(dt, format) : null;\n}\n// technical time formats (e.g. the time part of ISO 8601), take some options\n// and this commonizes their handling\nfunction toTechTimeFormat(dt, { suppressSeconds = false, suppressMilliseconds = false, includeOffset, includePrefix = false, includeZone = false, spaceZone = false, format = \"extended\" }) {\n    let fmt = format === \"basic\" ? \"HHmm\" : \"HH:mm\";\n    if (!suppressSeconds || dt.second !== 0 || dt.millisecond !== 0) {\n        fmt += format === \"basic\" ? \"ss\" : \":ss\";\n        if (!suppressMilliseconds || dt.millisecond !== 0) {\n            fmt += \".SSS\";\n        }\n    }\n    if ((includeZone || includeOffset) && spaceZone) {\n        fmt += \" \";\n    }\n    if (includeZone) {\n        fmt += \"z\";\n    } else if (includeOffset) {\n        fmt += format === \"basic\" ? \"ZZZ\" : \"ZZ\";\n    }\n    let str = toTechFormat(dt, fmt);\n    if (includePrefix) {\n        str = \"T\" + str;\n    }\n    return str;\n}\n// defaults for unspecified units in the supported calendars\nconst defaultUnitValues = {\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0\n}, defaultWeekUnitValues = {\n    weekNumber: 1,\n    weekday: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0\n}, defaultOrdinalUnitValues = {\n    ordinal: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0\n};\n// Units in the supported calendars, sorted by bigness\nconst orderedUnits = [\n    \"year\",\n    \"month\",\n    \"day\",\n    \"hour\",\n    \"minute\",\n    \"second\",\n    \"millisecond\"\n], orderedWeekUnits = [\n    \"weekYear\",\n    \"weekNumber\",\n    \"weekday\",\n    \"hour\",\n    \"minute\",\n    \"second\",\n    \"millisecond\"\n], orderedOrdinalUnits = [\n    \"year\",\n    \"ordinal\",\n    \"hour\",\n    \"minute\",\n    \"second\",\n    \"millisecond\"\n];\n// standardize case and plurality in units\nfunction normalizeUnit(unit) {\n    const normalized = {\n        year: \"year\",\n        years: \"year\",\n        month: \"month\",\n        months: \"month\",\n        day: \"day\",\n        days: \"day\",\n        hour: \"hour\",\n        hours: \"hour\",\n        minute: \"minute\",\n        minutes: \"minute\",\n        quarter: \"quarter\",\n        quarters: \"quarter\",\n        second: \"second\",\n        seconds: \"second\",\n        millisecond: \"millisecond\",\n        milliseconds: \"millisecond\",\n        weekday: \"weekday\",\n        weekdays: \"weekday\",\n        weeknumber: \"weekNumber\",\n        weeksnumber: \"weekNumber\",\n        weeknumbers: \"weekNumber\",\n        weekyear: \"weekYear\",\n        weekyears: \"weekYear\",\n        ordinal: \"ordinal\"\n    }[unit.toLowerCase()];\n    if (!normalized) throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidUnitError(unit);\n    return normalized;\n}\n// this is a dumbed down version of fromObject() that runs about 60% faster\n// but doesn't do any validation, makes a bunch of assumptions about what units\n// are present, and so on.\nfunction quickDT(obj, zone) {\n    // assume we have the higher-order units\n    for (const u of orderedUnits){\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(obj[u])) {\n            obj[u] = defaultUnitValues[u];\n        }\n    }\n    const invalid = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.hasInvalidGregorianData)(obj) || (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.hasInvalidTimeData)(obj);\n    if (invalid) {\n        return DateTime.invalid(invalid);\n    }\n    const tsNow = _settings_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].now(), offsetProvis = zone.offset(tsNow), [ts, o] = objToTS(obj, offsetProvis, zone);\n    return new DateTime({\n        ts,\n        zone,\n        o\n    });\n}\nfunction diffRelative(start, end, opts) {\n    const round = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(opts.round) ? true : opts.round, format = (c, unit)=>{\n        c = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.roundTo)(c, round || opts.calendary ? 0 : 2, true);\n        const formatter = end.loc.clone(opts).relFormatter(opts);\n        return formatter.format(c, unit);\n    }, differ = (unit)=>{\n        if (opts.calendary) {\n            if (!end.hasSame(start, unit)) {\n                return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);\n            } else return 0;\n        } else {\n            return end.diff(start, unit).get(unit);\n        }\n    };\n    if (opts.unit) {\n        return format(differ(opts.unit), opts.unit);\n    }\n    for (const unit of opts.units){\n        const count = differ(unit);\n        if (Math.abs(count) >= 1) {\n            return format(count, unit);\n        }\n    }\n    return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);\n}\n/**\n * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.\n *\n * A DateTime comprises of:\n * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.\n * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).\n * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.\n *\n * Here is a brief overview of the most commonly used functionality it provides:\n *\n * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link local}, {@link utc}, and (most flexibly) {@link fromObject}. To create one from a standard string format, use {@link fromISO}, {@link fromHTTP}, and {@link fromRFC2822}. To create one from a custom string format, use {@link fromFormat}. To create one from a native JS date, use {@link fromJSDate}.\n * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link toObject}), use the {@link year}, {@link month},\n * {@link day}, {@link hour}, {@link minute}, {@link second}, {@link millisecond} accessors.\n * * **Week calendar**: For ISO week calendar attributes, see the {@link weekYear}, {@link weekNumber}, and {@link weekday} accessors.\n * * **Configuration** See the {@link locale} and {@link numberingSystem} accessors.\n * * **Transformation**: To transform the DateTime into other DateTimes, use {@link set}, {@link reconfigure}, {@link setZone}, {@link setLocale}, {@link plus}, {@link minus}, {@link endOf}, {@link startOf}, {@link toUTC}, and {@link toLocal}.\n * * **Output**: To convert the DateTime to other representations, use the {@link toRelative}, {@link toRelativeCalendar}, {@link toJSON}, {@link toISO}, {@link toHTTP}, {@link toObject}, {@link toRFC2822}, {@link toString}, {@link toLocaleString}, {@link toFormat}, {@link toMillis} and {@link toJSDate}.\n *\n * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.\n */ class DateTime {\n    /**\n   * @access private\n   */ constructor(config){\n        const zone = config.zone || _settings_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].defaultZone;\n        let invalid = config.invalid || (Number.isNaN(config.ts) ? new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"invalid input\") : null) || (!zone.isValid ? unsupportedZone(zone) : null);\n        /**\n     * @access private\n     */ this.ts = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(config.ts) ? _settings_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].now() : config.ts;\n        let c = null, o = null;\n        if (!invalid) {\n            const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);\n            if (unchanged) {\n                [c, o] = [\n                    config.old.c,\n                    config.old.o\n                ];\n            } else {\n                const ot = zone.offset(this.ts);\n                c = tsToObj(this.ts, ot);\n                invalid = Number.isNaN(c.year) ? new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"invalid input\") : null;\n                c = invalid ? null : c;\n                o = invalid ? null : ot;\n            }\n        }\n        /**\n     * @access private\n     */ this._zone = zone;\n        /**\n     * @access private\n     */ this.loc = config.loc || _impl_locale_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].create();\n        /**\n     * @access private\n     */ this.invalid = invalid;\n        /**\n     * @access private\n     */ this.weekData = null;\n        /**\n     * @access private\n     */ this.c = c;\n        /**\n     * @access private\n     */ this.o = o;\n        /**\n     * @access private\n     */ this.isLuxonDateTime = true;\n    }\n    // CONSTRUCT\n    /**\n   * Create a DateTime for the current instant, in the system's time zone.\n   *\n   * Use Settings to override these default values if needed.\n   * @example DateTime.now().toISO() //~> now in the ISO format\n   * @return {DateTime}\n   */ static now() {\n        return new DateTime({});\n    }\n    /**\n   * Create a local DateTime\n   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used\n   * @param {number} [month=1] - The month, 1-indexed\n   * @param {number} [day=1] - The day of the month, 1-indexed\n   * @param {number} [hour=0] - The hour of the day, in 24-hour time\n   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59\n   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59\n   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999\n   * @example DateTime.local()                            //~> now\n   * @example DateTime.local(2017)                        //~> 2017-01-01T00:00:00\n   * @example DateTime.local(2017, 3)                     //~> 2017-03-01T00:00:00\n   * @example DateTime.local(2017, 3, 12)                 //~> 2017-03-12T00:00:00\n   * @example DateTime.local(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00\n   * @example DateTime.local(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00\n   * @example DateTime.local(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10\n   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765\n   * @return {DateTime}\n   */ static local(year, month, day, hour, minute, second, millisecond) {\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(year)) {\n            return DateTime.now();\n        } else {\n            return quickDT({\n                year,\n                month,\n                day,\n                hour,\n                minute,\n                second,\n                millisecond\n            }, _settings_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].defaultZone);\n        }\n    }\n    /**\n   * Create a DateTime in UTC\n   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used\n   * @param {number} [month=1] - The month, 1-indexed\n   * @param {number} [day=1] - The day of the month\n   * @param {number} [hour=0] - The hour of the day, in 24-hour time\n   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59\n   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59\n   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999\n   * @example DateTime.utc()                            //~> now\n   * @example DateTime.utc(2017)                        //~> 2017-01-01T00:00:00Z\n   * @example DateTime.utc(2017, 3)                     //~> 2017-03-01T00:00:00Z\n   * @example DateTime.utc(2017, 3, 12)                 //~> 2017-03-12T00:00:00Z\n   * @example DateTime.utc(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765Z\n   * @return {DateTime}\n   */ static utc(year, month, day, hour, minute, second, millisecond) {\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(year)) {\n            return new DateTime({\n                ts: _settings_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].now(),\n                zone: _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].utcInstance\n            });\n        } else {\n            return quickDT({\n                year,\n                month,\n                day,\n                hour,\n                minute,\n                second,\n                millisecond\n            }, _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].utcInstance);\n        }\n    }\n    /**\n   * Create a DateTime from a JavaScript Date object. Uses the default zone.\n   * @param {Date} date - a JavaScript Date object\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @return {DateTime}\n   */ static fromJSDate(date, options = {}) {\n        const ts = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isDate)(date) ? date.valueOf() : NaN;\n        if (Number.isNaN(ts)) {\n            return DateTime.invalid(\"invalid input\");\n        }\n        const zoneToUse = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_9__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].defaultZone);\n        if (!zoneToUse.isValid) {\n            return DateTime.invalid(unsupportedZone(zoneToUse));\n        }\n        return new DateTime({\n            ts: ts,\n            zone: zoneToUse,\n            loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].fromObject(options)\n        });\n    }\n    /**\n   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n   * @param {number} milliseconds - a number of milliseconds since 1970 UTC\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @return {DateTime}\n   */ static fromMillis(milliseconds, options = {}) {\n        if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isNumber)(milliseconds)) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);\n        } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {\n            // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start\n            return DateTime.invalid(\"Timestamp out of range\");\n        } else {\n            return new DateTime({\n                ts: milliseconds,\n                zone: (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_9__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].defaultZone),\n                loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].fromObject(options)\n            });\n        }\n    }\n    /**\n   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n   * @param {number} seconds - a number of seconds since 1970 UTC\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @return {DateTime}\n   */ static fromSeconds(seconds, options = {}) {\n        if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isNumber)(seconds)) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidArgumentError(\"fromSeconds requires a numerical input\");\n        } else {\n            return new DateTime({\n                ts: seconds * 1000,\n                zone: (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_9__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].defaultZone),\n                loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].fromObject(options)\n            });\n        }\n    }\n    /**\n   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.\n   * @param {Object} obj - the object to create the DateTime from\n   * @param {number} obj.year - a year, such as 1987\n   * @param {number} obj.month - a month, 1-12\n   * @param {number} obj.day - a day of the month, 1-31, depending on the month\n   * @param {number} obj.ordinal - day of the year, 1-365 or 366\n   * @param {number} obj.weekYear - an ISO week year\n   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year\n   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday\n   * @param {number} obj.hour - hour of the day, 0-23\n   * @param {number} obj.minute - minute of the hour, 0-59\n   * @param {number} obj.second - second of the minute, 0-59\n   * @param {number} obj.millisecond - millisecond of the second, 0-999\n   * @param {string|Zone} [obj.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()\n   * @param {string} [obj.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} obj.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} obj.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'\n   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'utc' }),\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'local' })\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'America/New_York' })\n   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'\n   * @return {DateTime}\n   */ static fromObject(obj) {\n        const zoneToUse = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_9__.normalizeZone)(obj.zone, _settings_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].defaultZone);\n        if (!zoneToUse.isValid) {\n            return DateTime.invalid(unsupportedZone(zoneToUse));\n        }\n        const tsNow = _settings_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].now(), offsetProvis = zoneToUse.offset(tsNow), normalized = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.normalizeObject)(obj, normalizeUnit, [\n            \"zone\",\n            \"locale\",\n            \"outputCalendar\",\n            \"numberingSystem\"\n        ]), containsOrdinal = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(normalized.ordinal), containsGregorYear = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(normalized.year), containsGregorMD = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(normalized.month) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = _impl_locale_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].fromObject(obj);\n        // cases:\n        // just a weekday -> this week's instance of that weekday, no worries\n        // (gregorian data or ordinal) + (weekYear or weekNumber) -> error\n        // (gregorian month or day) + ordinal -> error\n        // otherwise just use weeks or ordinals or gregorian, depending on what's specified\n        if ((containsGregor || containsOrdinal) && definiteWeekDef) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.ConflictingSpecificationError(\"Can't mix weekYear/weekNumber units with year/month/day or ordinals\");\n        }\n        if (containsGregorMD && containsOrdinal) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.ConflictingSpecificationError(\"Can't mix ordinal dates with month/day\");\n        }\n        const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;\n        // configure ourselves to deal with gregorian dates or week stuff\n        let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);\n        if (useWeekData) {\n            units = orderedWeekUnits;\n            defaultValues = defaultWeekUnitValues;\n            objNow = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.gregorianToWeek)(objNow);\n        } else if (containsOrdinal) {\n            units = orderedOrdinalUnits;\n            defaultValues = defaultOrdinalUnitValues;\n            objNow = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.gregorianToOrdinal)(objNow);\n        } else {\n            units = orderedUnits;\n            defaultValues = defaultUnitValues;\n        }\n        // set default values for missing stuff\n        let foundFirst = false;\n        for (const u of units){\n            const v = normalized[u];\n            if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(v)) {\n                foundFirst = true;\n            } else if (foundFirst) {\n                normalized[u] = defaultValues[u];\n            } else {\n                normalized[u] = objNow[u];\n            }\n        }\n        // make sure the values we have are in range\n        const higherOrderInvalid = useWeekData ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.hasInvalidWeekData)(normalized) : containsOrdinal ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.hasInvalidOrdinalData)(normalized) : (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.hasInvalidGregorianData)(normalized), invalid = higherOrderInvalid || (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.hasInvalidTimeData)(normalized);\n        if (invalid) {\n            return DateTime.invalid(invalid);\n        }\n        // compute the actual time\n        const gregorian = useWeekData ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.weekToGregorian)(normalized) : containsOrdinal ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.ordinalToGregorian)(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({\n            ts: tsFinal,\n            zone: zoneToUse,\n            o: offsetFinal,\n            loc\n        });\n        // gregorian data + weekday serves only to validate\n        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {\n            return DateTime.invalid(\"mismatched weekday\", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);\n        }\n        return inst;\n    }\n    /**\n   * Create a DateTime from an ISO 8601 string\n   * @param {string} text - the ISO string\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance\n   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123')\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})\n   * @example DateTime.fromISO('2016-W05-4')\n   * @return {DateTime}\n   */ static fromISO(text, opts = {}) {\n        const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseISODate)(text);\n        return parseDataToDateTime(vals, parsedZone, opts, \"ISO 8601\", text);\n    }\n    /**\n   * Create a DateTime from an RFC 2822 string\n   * @param {string} text - the RFC 2822 string\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')\n   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')\n   * @return {DateTime}\n   */ static fromRFC2822(text, opts = {}) {\n        const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseRFC2822Date)(text);\n        return parseDataToDateTime(vals, parsedZone, opts, \"RFC 2822\", text);\n    }\n    /**\n   * Create a DateTime from an HTTP header date\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n   * @param {string} text - the HTTP header date\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\n   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')\n   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')\n   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')\n   * @return {DateTime}\n   */ static fromHTTP(text, opts = {}) {\n        const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseHTTPDate)(text);\n        return parseDataToDateTime(vals, parsedZone, opts, \"HTTP\", opts);\n    }\n    /**\n   * Create a DateTime from an input string and format string.\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale.\n   * @see https://moment.github.io/luxon/docs/manual/parsing.html#table-of-tokens\n   * @param {string} text - the string to parse\n   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale\n   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @return {DateTime}\n   */ static fromFormat(text, fmt, opts = {}) {\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(text) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(fmt)) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidArgumentError(\"fromFormat requires an input string and a format\");\n        }\n        const { locale = null, numberingSystem = null } = opts, localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].fromOpts({\n            locale,\n            numberingSystem,\n            defaultToEN: true\n        }), [vals, parsedZone, invalid] = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.parseFromTokens)(localeToUse, text, fmt);\n        if (invalid) {\n            return DateTime.invalid(invalid);\n        } else {\n            return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text);\n        }\n    }\n    /**\n   * @deprecated use fromFormat instead\n   */ static fromString(text, fmt, opts = {}) {\n        return DateTime.fromFormat(text, fmt, opts);\n    }\n    /**\n   * Create a DateTime from a SQL date, time, or datetime\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale\n   * @param {string} text - the string to parse\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale\n   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @example DateTime.fromSQL('2017-05-15')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })\n   * @example DateTime.fromSQL('09:12:34.342')\n   * @return {DateTime}\n   */ static fromSQL(text, opts = {}) {\n        const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseSQL)(text);\n        return parseDataToDateTime(vals, parsedZone, opts, \"SQL\", text);\n    }\n    /**\n   * Create an invalid DateTime.\n   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {DateTime}\n   */ static invalid(reason, explanation = null) {\n        if (!reason) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidArgumentError(\"need to specify a reason the DateTime is invalid\");\n        }\n        const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](reason, explanation);\n        if (_settings_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].throwOnInvalid) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidDateTimeError(invalid);\n        } else {\n            return new DateTime({\n                invalid\n            });\n        }\n    }\n    /**\n   * Check if an object is a DateTime. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */ static isDateTime(o) {\n        return o && o.isLuxonDateTime || false;\n    }\n    // INFO\n    /**\n   * Get the value of unit.\n   * @param {string} unit - a unit such as 'minute' or 'day'\n   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7\n   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4\n   * @return {number}\n   */ get(unit) {\n        return this[unit];\n    }\n    /**\n   * Returns whether the DateTime is valid. Invalid DateTimes occur when:\n   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30\n   * * The DateTime was created by an operation on another invalid date\n   * @type {boolean}\n   */ get isValid() {\n        return this.invalid === null;\n    }\n    /**\n   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid\n   * @type {string}\n   */ get invalidReason() {\n        return this.invalid ? this.invalid.reason : null;\n    }\n    /**\n   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid\n   * @type {string}\n   */ get invalidExplanation() {\n        return this.invalid ? this.invalid.explanation : null;\n    }\n    /**\n   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime\n   *\n   * @type {string}\n   */ get locale() {\n        return this.isValid ? this.loc.locale : null;\n    }\n    /**\n   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime\n   *\n   * @type {string}\n   */ get numberingSystem() {\n        return this.isValid ? this.loc.numberingSystem : null;\n    }\n    /**\n   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime\n   *\n   * @type {string}\n   */ get outputCalendar() {\n        return this.isValid ? this.loc.outputCalendar : null;\n    }\n    /**\n   * Get the time zone associated with this DateTime.\n   * @type {Zone}\n   */ get zone() {\n        return this._zone;\n    }\n    /**\n   * Get the name of the time zone.\n   * @type {string}\n   */ get zoneName() {\n        return this.isValid ? this.zone.name : null;\n    }\n    /**\n   * Get the year\n   * @example DateTime.local(2017, 5, 25).year //=> 2017\n   * @type {number}\n   */ get year() {\n        return this.isValid ? this.c.year : NaN;\n    }\n    /**\n   * Get the quarter\n   * @example DateTime.local(2017, 5, 25).quarter //=> 2\n   * @type {number}\n   */ get quarter() {\n        return this.isValid ? Math.ceil(this.c.month / 3) : NaN;\n    }\n    /**\n   * Get the month (1-12).\n   * @example DateTime.local(2017, 5, 25).month //=> 5\n   * @type {number}\n   */ get month() {\n        return this.isValid ? this.c.month : NaN;\n    }\n    /**\n   * Get the day of the month (1-30ish).\n   * @example DateTime.local(2017, 5, 25).day //=> 25\n   * @type {number}\n   */ get day() {\n        return this.isValid ? this.c.day : NaN;\n    }\n    /**\n   * Get the hour of the day (0-23).\n   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9\n   * @type {number}\n   */ get hour() {\n        return this.isValid ? this.c.hour : NaN;\n    }\n    /**\n   * Get the minute of the hour (0-59).\n   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30\n   * @type {number}\n   */ get minute() {\n        return this.isValid ? this.c.minute : NaN;\n    }\n    /**\n   * Get the second of the minute (0-59).\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52\n   * @type {number}\n   */ get second() {\n        return this.isValid ? this.c.second : NaN;\n    }\n    /**\n   * Get the millisecond of the second (0-999).\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654\n   * @type {number}\n   */ get millisecond() {\n        return this.isValid ? this.c.millisecond : NaN;\n    }\n    /**\n   * Get the week year\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015\n   * @type {number}\n   */ get weekYear() {\n        return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;\n    }\n    /**\n   * Get the week number of the week year (1-52ish).\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21\n   * @type {number}\n   */ get weekNumber() {\n        return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;\n    }\n    /**\n   * Get the day of the week.\n   * 1 is Monday and 7 is Sunday\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2014, 11, 31).weekday //=> 4\n   * @type {number}\n   */ get weekday() {\n        return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;\n    }\n    /**\n   * Get the ordinal (meaning the day of the year)\n   * @example DateTime.local(2017, 5, 25).ordinal //=> 145\n   * @type {number|DateTime}\n   */ get ordinal() {\n        return this.isValid ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.gregorianToOrdinal)(this.c).ordinal : NaN;\n    }\n    /**\n   * Get the human readable short month name, such as 'Oct'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct\n   * @type {string}\n   */ get monthShort() {\n        return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"].months(\"short\", {\n            locObj: this.loc\n        })[this.month - 1] : null;\n    }\n    /**\n   * Get the human readable long month name, such as 'October'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).monthLong //=> October\n   * @type {string}\n   */ get monthLong() {\n        return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"].months(\"long\", {\n            locObj: this.loc\n        })[this.month - 1] : null;\n    }\n    /**\n   * Get the human readable short weekday, such as 'Mon'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon\n   * @type {string}\n   */ get weekdayShort() {\n        return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"].weekdays(\"short\", {\n            locObj: this.loc\n        })[this.weekday - 1] : null;\n    }\n    /**\n   * Get the human readable long weekday, such as 'Monday'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday\n   * @type {string}\n   */ get weekdayLong() {\n        return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"].weekdays(\"long\", {\n            locObj: this.loc\n        })[this.weekday - 1] : null;\n    }\n    /**\n   * Get the UTC offset of this DateTime in minutes\n   * @example DateTime.now().offset //=> -240\n   * @example DateTime.utc().offset //=> 0\n   * @type {number}\n   */ get offset() {\n        return this.isValid ? +this.o : NaN;\n    }\n    /**\n   * Get the short human name for the zone's current offset, for example \"EST\" or \"EDT\".\n   * Defaults to the system's locale if no locale has been specified\n   * @type {string}\n   */ get offsetNameShort() {\n        if (this.isValid) {\n            return this.zone.offsetName(this.ts, {\n                format: \"short\",\n                locale: this.locale\n            });\n        } else {\n            return null;\n        }\n    }\n    /**\n   * Get the long human name for the zone's current offset, for example \"Eastern Standard Time\" or \"Eastern Daylight Time\".\n   * Defaults to the system's locale if no locale has been specified\n   * @type {string}\n   */ get offsetNameLong() {\n        if (this.isValid) {\n            return this.zone.offsetName(this.ts, {\n                format: \"long\",\n                locale: this.locale\n            });\n        } else {\n            return null;\n        }\n    }\n    /**\n   * Get whether this zone's offset ever changes, as in a DST.\n   * @type {boolean}\n   */ get isOffsetFixed() {\n        return this.isValid ? this.zone.universal : null;\n    }\n    /**\n   * Get whether the DateTime is in a DST.\n   * @type {boolean}\n   */ get isInDST() {\n        if (this.isOffsetFixed) {\n            return false;\n        } else {\n            return this.offset > this.set({\n                month: 1\n            }).offset || this.offset > this.set({\n                month: 5\n            }).offset;\n        }\n    }\n    /**\n   * Returns true if this DateTime is in a leap year, false otherwise\n   * @example DateTime.local(2016).isInLeapYear //=> true\n   * @example DateTime.local(2013).isInLeapYear //=> false\n   * @type {boolean}\n   */ get isInLeapYear() {\n        return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isLeapYear)(this.year);\n    }\n    /**\n   * Returns the number of days in this DateTime's month\n   * @example DateTime.local(2016, 2).daysInMonth //=> 29\n   * @example DateTime.local(2016, 3).daysInMonth //=> 31\n   * @type {number}\n   */ get daysInMonth() {\n        return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.daysInMonth)(this.year, this.month);\n    }\n    /**\n   * Returns the number of days in this DateTime's year\n   * @example DateTime.local(2016).daysInYear //=> 366\n   * @example DateTime.local(2013).daysInYear //=> 365\n   * @type {number}\n   */ get daysInYear() {\n        return this.isValid ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.daysInYear)(this.year) : NaN;\n    }\n    /**\n   * Returns the number of weeks in this DateTime's year\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2004).weeksInWeekYear //=> 53\n   * @example DateTime.local(2013).weeksInWeekYear //=> 52\n   * @type {number}\n   */ get weeksInWeekYear() {\n        return this.isValid ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.weeksInWeekYear)(this.weekYear) : NaN;\n    }\n    /**\n   * Returns the resolved Intl options for this DateTime.\n   * This is useful in understanding the behavior of formatting methods\n   * @param {Object} opts - the same options as toLocaleString\n   * @return {Object}\n   */ resolvedLocaleOpts(opts = {}) {\n        const { locale, numberingSystem, calendar } = _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.clone(opts), opts).resolvedOptions(this);\n        return {\n            locale,\n            numberingSystem,\n            outputCalendar: calendar\n        };\n    }\n    // TRANSFORM\n    /**\n   * \"Set\" the DateTime's zone to UTC. Returns a newly-constructed DateTime.\n   *\n   * Equivalent to {@link setZone}('utc')\n   * @param {number} [offset=0] - optionally, an offset from UTC in minutes\n   * @param {Object} [opts={}] - options to pass to `setZone()`\n   * @return {DateTime}\n   */ toUTC(offset = 0, opts = {}) {\n        return this.setZone(_zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].instance(offset), opts);\n    }\n    /**\n   * \"Set\" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.\n   *\n   * Equivalent to `setZone('local')`\n   * @return {DateTime}\n   */ toLocal() {\n        return this.setZone(_settings_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].defaultZone);\n    }\n    /**\n   * \"Set\" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.\n   *\n   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link plus}. You may wish to use {@link toLocal} and {@link toUTC} which provide simple convenience wrappers for commonly used zones.\n   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link Zone} class.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.\n   * @return {DateTime}\n   */ setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {\n        zone = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_9__.normalizeZone)(zone, _settings_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].defaultZone);\n        if (zone.equals(this.zone)) {\n            return this;\n        } else if (!zone.isValid) {\n            return DateTime.invalid(unsupportedZone(zone));\n        } else {\n            let newTS = this.ts;\n            if (keepLocalTime || keepCalendarTime) {\n                const offsetGuess = zone.offset(this.ts);\n                const asObj = this.toObject();\n                [newTS] = objToTS(asObj, offsetGuess, zone);\n            }\n            return clone(this, {\n                ts: newTS,\n                zone\n            });\n        }\n    }\n    /**\n   * \"Set\" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.\n   * @param {Object} properties - the properties to set\n   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })\n   * @return {DateTime}\n   */ reconfigure({ locale, numberingSystem, outputCalendar } = {}) {\n        const loc = this.loc.clone({\n            locale,\n            numberingSystem,\n            outputCalendar\n        });\n        return clone(this, {\n            loc\n        });\n    }\n    /**\n   * \"Set\" the locale. Returns a newly-constructed DateTime.\n   * Just a convenient alias for reconfigure({ locale })\n   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')\n   * @return {DateTime}\n   */ setLocale(locale) {\n        return this.reconfigure({\n            locale\n        });\n    }\n    /**\n   * \"Set\" the values of specified units. Returns a newly-constructed DateTime.\n   * You can only set units with this method; for \"setting\" metadata, see {@link reconfigure} and {@link setZone}.\n   * @param {Object} values - a mapping of units to numbers\n   * @example dt.set({ year: 2017 })\n   * @example dt.set({ hour: 8, minute: 30 })\n   * @example dt.set({ weekday: 5 })\n   * @example dt.set({ year: 2005, ordinal: 234 })\n   * @return {DateTime}\n   */ set(values) {\n        if (!this.isValid) return this;\n        const normalized = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.normalizeObject)(values, normalizeUnit, []), settingWeekStuff = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(normalized.weekYear) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(normalized.weekNumber) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(normalized.weekday), containsOrdinal = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(normalized.ordinal), containsGregorYear = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(normalized.year), containsGregorMD = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(normalized.month) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;\n        if ((containsGregor || containsOrdinal) && definiteWeekDef) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.ConflictingSpecificationError(\"Can't mix weekYear/weekNumber units with year/month/day or ordinals\");\n        }\n        if (containsGregorMD && containsOrdinal) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.ConflictingSpecificationError(\"Can't mix ordinal dates with month/day\");\n        }\n        let mixed;\n        if (settingWeekStuff) {\n            mixed = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.weekToGregorian)(Object.assign((0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.gregorianToWeek)(this.c), normalized));\n        } else if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(normalized.ordinal)) {\n            mixed = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.ordinalToGregorian)(Object.assign((0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_1__.gregorianToOrdinal)(this.c), normalized));\n        } else {\n            mixed = Object.assign(this.toObject(), normalized);\n            // if we didn't set the day but we ended up on an overflow date,\n            // use the last day of the right month\n            if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(normalized.day)) {\n                mixed.day = Math.min((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.daysInMonth)(mixed.year, mixed.month), mixed.day);\n            }\n        }\n        const [ts, o] = objToTS(mixed, this.o, this.zone);\n        return clone(this, {\n            ts,\n            o\n        });\n    }\n    /**\n   * Add a period of time to this DateTime and return the resulting DateTime\n   *\n   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.\n   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @example DateTime.now().plus(123) //~> in 123 milliseconds\n   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes\n   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow\n   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday\n   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min\n   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min\n   * @return {DateTime}\n   */ plus(duration) {\n        if (!this.isValid) return this;\n        const dur = (0,_duration_js__WEBPACK_IMPORTED_MODULE_3__.friendlyDuration)(duration);\n        return clone(this, adjustTime(this, dur));\n    }\n    /**\n   * Subtract a period of time to this DateTime and return the resulting DateTime\n   * See {@link plus}\n   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   @return {DateTime}\n  */ minus(duration) {\n        if (!this.isValid) return this;\n        const dur = (0,_duration_js__WEBPACK_IMPORTED_MODULE_3__.friendlyDuration)(duration).negate();\n        return clone(this, adjustTime(this, dur));\n    }\n    /**\n   * \"Set\" this DateTime to the beginning of a unit of time.\n   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'\n   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'\n   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays\n   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'\n   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'\n   * @return {DateTime}\n   */ startOf(unit) {\n        if (!this.isValid) return this;\n        const o = {}, normalizedUnit = _duration_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].normalizeUnit(unit);\n        switch(normalizedUnit){\n            case \"years\":\n                o.month = 1;\n            // falls through\n            case \"quarters\":\n            case \"months\":\n                o.day = 1;\n            // falls through\n            case \"weeks\":\n            case \"days\":\n                o.hour = 0;\n            // falls through\n            case \"hours\":\n                o.minute = 0;\n            // falls through\n            case \"minutes\":\n                o.second = 0;\n            // falls through\n            case \"seconds\":\n                o.millisecond = 0;\n                break;\n            case \"milliseconds\":\n                break;\n        }\n        if (normalizedUnit === \"weeks\") {\n            o.weekday = 1;\n        }\n        if (normalizedUnit === \"quarters\") {\n            const q = Math.ceil(this.month / 3);\n            o.month = (q - 1) * 3 + 1;\n        }\n        return this.set(o);\n    }\n    /**\n   * \"Set\" this DateTime to the end (meaning the last millisecond) of a unit of time\n   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays\n   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'\n   * @return {DateTime}\n   */ endOf(unit) {\n        return this.isValid ? this.plus({\n            [unit]: 1\n        }).startOf(unit).minus(1) : this;\n    }\n    // OUTPUT\n    /**\n   * Returns a string representation of this DateTime formatted according to the specified format string.\n   * **You may not want this.** See {@link toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens).\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale.\n   * @see https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens\n   * @param {string} fmt - the format string\n   * @param {Object} opts - opts to override the configuration options\n   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'\n   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'\n   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: \"fr\" }) //=> '2017 avr. 22'\n   * @example DateTime.now().toFormat(\"HH 'hours and' mm 'minutes'\") //=> '20 hours and 55 minutes'\n   * @return {string}\n   */ toFormat(fmt, opts = {}) {\n        return this.isValid ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;\n    }\n    /**\n   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.\n   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation\n   * of the DateTime in the assigned locale.\n   * Defaults to the system's locale if no locale has been specified\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param opts {Object} - Intl.DateTimeFormat constructor options and configuration options\n   * @example DateTime.now().toLocaleString(); //=> 4/20/2017\n   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'\n   * @example DateTime.now().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'\n   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'\n   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'\n   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'\n   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'\n   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'\n   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hour12: false }); //=> '11:32'\n   * @return {string}\n   */ toLocaleString(opts = _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_SHORT) {\n        return this.isValid ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.clone(opts), opts).formatDateTime(this) : INVALID;\n    }\n    /**\n   * Returns an array of format \"parts\", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.\n   * Defaults to the system's locale if no locale has been specified\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts\n   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.\n   * @example DateTime.now().toLocaleParts(); //=> [\n   *                                   //=>   { type: 'day', value: '25' },\n   *                                   //=>   { type: 'literal', value: '/' },\n   *                                   //=>   { type: 'month', value: '05' },\n   *                                   //=>   { type: 'literal', value: '/' },\n   *                                   //=>   { type: 'year', value: '1982' }\n   *                                   //=> ]\n   */ toLocaleParts(opts = {}) {\n        return this.isValid ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];\n    }\n    /**\n   * Returns an ISO 8601-compliant string representation of this DateTime\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @example DateTime.utc(1982, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'\n   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'\n   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'\n   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'\n   * @return {string}\n   */ toISO(opts = {}) {\n        if (!this.isValid) {\n            return null;\n        }\n        return `${this.toISODate(opts)}T${this.toISOTime(opts)}`;\n    }\n    /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's date component\n   * @param {Object} opts - options\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'\n   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'\n   * @return {string}\n   */ toISODate({ format = \"extended\" } = {}) {\n        let fmt = format === \"basic\" ? \"yyyyMMdd\" : \"yyyy-MM-dd\";\n        if (this.year > 9999) {\n            fmt = \"+\" + fmt;\n        }\n        return toTechFormat(this, fmt);\n    }\n    /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's week date\n   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'\n   * @return {string}\n   */ toISOWeekDate() {\n        return toTechFormat(this, \"kkkk-'W'WW-c\");\n    }\n    /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's time component\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'\n   * @return {string}\n   */ toISOTime({ suppressMilliseconds = false, suppressSeconds = false, includeOffset = true, includePrefix = false, format = \"extended\" } = {}) {\n        return toTechTimeFormat(this, {\n            suppressSeconds,\n            suppressMilliseconds,\n            includeOffset,\n            includePrefix,\n            format\n        });\n    }\n    /**\n   * Returns an RFC 2822-compatible string representation of this DateTime, always in UTC\n   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'\n   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'\n   * @return {string}\n   */ toRFC2822() {\n        return toTechFormat(this, \"EEE, dd LLL yyyy HH:mm:ss ZZZ\", false);\n    }\n    /**\n   * Returns a string representation of this DateTime appropriate for use in HTTP headers.\n   * Specifically, the string conforms to RFC 1123.\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'\n   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'\n   * @return {string}\n   */ toHTTP() {\n        return toTechFormat(this.toUTC(), \"EEE, dd LLL yyyy HH:mm:ss 'GMT'\");\n    }\n    /**\n   * Returns a string representation of this DateTime appropriate for use in SQL Date\n   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'\n   * @return {string}\n   */ toSQLDate() {\n        return toTechFormat(this, \"yyyy-MM-dd\");\n    }\n    /**\n   * Returns a string representation of this DateTime appropriate for use in SQL Time\n   * @param {Object} opts - options\n   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @example DateTime.utc().toSQL() //=> '05:15:16.345'\n   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'\n   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'\n   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'\n   * @return {string}\n   */ toSQLTime({ includeOffset = true, includeZone = false } = {}) {\n        return toTechTimeFormat(this, {\n            includeOffset,\n            includeZone,\n            spaceZone: true\n        });\n    }\n    /**\n   * Returns a string representation of this DateTime appropriate for use in SQL DateTime\n   * @param {Object} opts - options\n   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'\n   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'\n   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'\n   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'\n   * @return {string}\n   */ toSQL(opts = {}) {\n        if (!this.isValid) {\n            return null;\n        }\n        return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;\n    }\n    /**\n   * Returns a string representation of this DateTime appropriate for debugging\n   * @return {string}\n   */ toString() {\n        return this.isValid ? this.toISO() : INVALID;\n    }\n    /**\n   * Returns the epoch milliseconds of this DateTime. Alias of {@link toMillis}\n   * @return {number}\n   */ valueOf() {\n        return this.toMillis();\n    }\n    /**\n   * Returns the epoch milliseconds of this DateTime.\n   * @return {number}\n   */ toMillis() {\n        return this.isValid ? this.ts : NaN;\n    }\n    /**\n   * Returns the epoch seconds of this DateTime.\n   * @return {number}\n   */ toSeconds() {\n        return this.isValid ? this.ts / 1000 : NaN;\n    }\n    /**\n   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.\n   * @return {string}\n   */ toJSON() {\n        return this.toISO();\n    }\n    /**\n   * Returns a BSON serializable equivalent to this DateTime.\n   * @return {Date}\n   */ toBSON() {\n        return this.toJSDate();\n    }\n    /**\n   * Returns a JavaScript object with this DateTime's year, month, day, and so on.\n   * @param opts - options for generating the object\n   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output\n   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }\n   * @return {Object}\n   */ toObject(opts = {}) {\n        if (!this.isValid) return {};\n        const base = Object.assign({}, this.c);\n        if (opts.includeConfig) {\n            base.outputCalendar = this.outputCalendar;\n            base.numberingSystem = this.loc.numberingSystem;\n            base.locale = this.loc.locale;\n        }\n        return base;\n    }\n    /**\n   * Returns a JavaScript Date equivalent to this DateTime.\n   * @return {Date}\n   */ toJSDate() {\n        return new Date(this.isValid ? this.ts : NaN);\n    }\n    // COMPARE\n    /**\n   * Return the difference between two DateTimes as a Duration.\n   * @param {DateTime} otherDateTime - the DateTime to compare this one to\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @example\n   * var i1 = DateTime.fromISO('1982-05-25T09:45'),\n   *     i2 = DateTime.fromISO('1983-10-14T10:30');\n   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }\n   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }\n   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }\n   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }\n   * @return {Duration}\n   */ diff(otherDateTime, unit = \"milliseconds\", opts = {}) {\n        if (!this.isValid || !otherDateTime.isValid) {\n            return _duration_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].invalid(this.invalid || otherDateTime.invalid, \"created by diffing an invalid DateTime\");\n        }\n        const durOpts = Object.assign({\n            locale: this.locale,\n            numberingSystem: this.numberingSystem\n        }, opts);\n        const units = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.maybeArray)(unit).map(_duration_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = (0,_impl_diff_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(earlier, later, units, durOpts);\n        return otherIsLater ? diffed.negate() : diffed;\n    }\n    /**\n   * Return the difference between this DateTime and right now.\n   * See {@link diff}\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */ diffNow(unit = \"milliseconds\", opts = {}) {\n        return this.diff(DateTime.now(), unit, opts);\n    }\n    /**\n   * Return an Interval spanning between this DateTime and another DateTime\n   * @param {DateTime} otherDateTime - the other end point of the Interval\n   * @return {Interval}\n   */ until(otherDateTime) {\n        return this.isValid ? _interval_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"].fromDateTimes(this, otherDateTime) : this;\n    }\n    /**\n   * Return whether this DateTime is in the same unit of time as another DateTime.\n   * Higher-order units must also be identical for this function to return `true`.\n   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link setZone} to convert one of the dates if needed.\n   * @param {DateTime} otherDateTime - the other DateTime\n   * @param {string} unit - the unit of time to check sameness on\n   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day\n   * @return {boolean}\n   */ hasSame(otherDateTime, unit) {\n        if (!this.isValid) return false;\n        const inputMs = otherDateTime.valueOf();\n        const otherZoneDateTime = this.setZone(otherDateTime.zone, {\n            keepLocalTime: true\n        });\n        return otherZoneDateTime.startOf(unit) <= inputMs && inputMs <= otherZoneDateTime.endOf(unit);\n    }\n    /**\n   * Equality check\n   * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.\n   * To compare just the millisecond values, use `+dt1 === +dt2`.\n   * @param {DateTime} other - the other DateTime\n   * @return {boolean}\n   */ equals(other) {\n        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);\n    }\n    /**\n   * Returns a string representation of a this time relative to now, such as \"in two days\". Can only internationalize if your\n   * platform supports Intl.RelativeTimeFormat. Rounds down by default.\n   * @param {Object} options - options that affect the output\n   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.\n   * @param {string} [options.style=\"long\"] - the style of units, must be \"long\", \"short\", or \"narrow\"\n   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of \"years\", \"quarters\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\", or \"seconds\"\n   * @param {boolean} [options.round=true] - whether to round the numbers in the output.\n   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.\n   * @param {string} options.locale - override the locale of this DateTime\n   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> \"in 1 day\"\n   * @example DateTime.now().setLocale(\"es\").toRelative({ days: 1 }) //=> \"dentro de 1 día\"\n   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: \"fr\" }) //=> \"dans 23 heures\"\n   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> \"2 days ago\"\n   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: \"hours\" }) //=> \"48 hours ago\"\n   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> \"1.5 days ago\"\n   */ toRelative(options = {}) {\n        if (!this.isValid) return null;\n        const base = options.base || DateTime.fromObject({\n            zone: this.zone\n        }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;\n        let units = [\n            \"years\",\n            \"months\",\n            \"days\",\n            \"hours\",\n            \"minutes\",\n            \"seconds\"\n        ];\n        let unit = options.unit;\n        if (Array.isArray(options.unit)) {\n            units = options.unit;\n            unit = undefined;\n        }\n        return diffRelative(base, this.plus(padding), Object.assign(options, {\n            numeric: \"always\",\n            units,\n            unit\n        }));\n    }\n    /**\n   * Returns a string representation of this date relative to today, such as \"yesterday\" or \"next month\".\n   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.\n   * @param {Object} options - options that affect the output\n   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.\n   * @param {string} options.locale - override the locale of this DateTime\n   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of \"years\", \"quarters\", \"months\", \"weeks\", or \"days\"\n   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> \"tomorrow\"\n   * @example DateTime.now().setLocale(\"es\").plus({ days: 1 }).toRelative() //=> \"\"mañana\"\n   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: \"fr\" }) //=> \"demain\"\n   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> \"2 days ago\"\n   */ toRelativeCalendar(options = {}) {\n        if (!this.isValid) return null;\n        return diffRelative(options.base || DateTime.fromObject({\n            zone: this.zone\n        }), this, Object.assign(options, {\n            numeric: \"auto\",\n            units: [\n                \"years\",\n                \"months\",\n                \"days\"\n            ],\n            calendary: true\n        }));\n    }\n    /**\n   * Return the min of several date times\n   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum\n   * @return {DateTime} the min DateTime, or undefined if called with no argument\n   */ static min(...dateTimes) {\n        if (!dateTimes.every(DateTime.isDateTime)) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidArgumentError(\"min requires all arguments be DateTimes\");\n        }\n        return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.bestBy)(dateTimes, (i)=>i.valueOf(), Math.min);\n    }\n    /**\n   * Return the max of several date times\n   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum\n   * @return {DateTime} the max DateTime, or undefined if called with no argument\n   */ static max(...dateTimes) {\n        if (!dateTimes.every(DateTime.isDateTime)) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidArgumentError(\"max requires all arguments be DateTimes\");\n        }\n        return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.bestBy)(dateTimes, (i)=>i.valueOf(), Math.max);\n    }\n    // MISC\n    /**\n   * Explain how a string would be parsed by fromFormat()\n   * @param {string} text - the string to parse\n   * @param {string} fmt - the format the string is expected to be in (see description)\n   * @param {Object} options - options taken by fromFormat()\n   * @return {Object}\n   */ static fromFormatExplain(text, fmt, options = {}) {\n        const { locale = null, numberingSystem = null } = options, localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].fromOpts({\n            locale,\n            numberingSystem,\n            defaultToEN: true\n        });\n        return (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.explainFromTokens)(localeToUse, text, fmt);\n    }\n    /**\n   * @deprecated use fromFormatExplain instead\n   */ static fromStringExplain(text, fmt, options = {}) {\n        return DateTime.fromFormatExplain(text, fmt, options);\n    }\n    // FORMAT PRESETS\n    /**\n   * {@link toLocaleString} format like 10/14/1983\n   * @type {Object}\n   */ static get DATE_SHORT() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_SHORT;\n    }\n    /**\n   * {@link toLocaleString} format like 'Oct 14, 1983'\n   * @type {Object}\n   */ static get DATE_MED() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_MED;\n    }\n    /**\n   * {@link toLocaleString} format like 'Fri, Oct 14, 1983'\n   * @type {Object}\n   */ static get DATE_MED_WITH_WEEKDAY() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_MED_WITH_WEEKDAY;\n    }\n    /**\n   * {@link toLocaleString} format like 'October 14, 1983'\n   * @type {Object}\n   */ static get DATE_FULL() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_FULL;\n    }\n    /**\n   * {@link toLocaleString} format like 'Tuesday, October 14, 1983'\n   * @type {Object}\n   */ static get DATE_HUGE() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_HUGE;\n    }\n    /**\n   * {@link toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */ static get TIME_SIMPLE() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_SIMPLE;\n    }\n    /**\n   * {@link toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */ static get TIME_WITH_SECONDS() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_SECONDS;\n    }\n    /**\n   * {@link toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */ static get TIME_WITH_SHORT_OFFSET() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_SHORT_OFFSET;\n    }\n    /**\n   * {@link toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */ static get TIME_WITH_LONG_OFFSET() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_LONG_OFFSET;\n    }\n    /**\n   * {@link toLocaleString} format like '09:30', always 24-hour.\n   * @type {Object}\n   */ static get TIME_24_SIMPLE() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_SIMPLE;\n    }\n    /**\n   * {@link toLocaleString} format like '09:30:23', always 24-hour.\n   * @type {Object}\n   */ static get TIME_24_WITH_SECONDS() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_SECONDS;\n    }\n    /**\n   * {@link toLocaleString} format like '09:30:23 EDT', always 24-hour.\n   * @type {Object}\n   */ static get TIME_24_WITH_SHORT_OFFSET() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_SHORT_OFFSET;\n    }\n    /**\n   * {@link toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.\n   * @type {Object}\n   */ static get TIME_24_WITH_LONG_OFFSET() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_LONG_OFFSET;\n    }\n    /**\n   * {@link toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */ static get DATETIME_SHORT() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_SHORT;\n    }\n    /**\n   * {@link toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */ static get DATETIME_SHORT_WITH_SECONDS() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_SHORT_WITH_SECONDS;\n    }\n    /**\n   * {@link toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */ static get DATETIME_MED() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED;\n    }\n    /**\n   * {@link toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */ static get DATETIME_MED_WITH_SECONDS() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED_WITH_SECONDS;\n    }\n    /**\n   * {@link toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */ static get DATETIME_MED_WITH_WEEKDAY() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED_WITH_WEEKDAY;\n    }\n    /**\n   * {@link toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */ static get DATETIME_FULL() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_FULL;\n    }\n    /**\n   * {@link toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */ static get DATETIME_FULL_WITH_SECONDS() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_FULL_WITH_SECONDS;\n    }\n    /**\n   * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */ static get DATETIME_HUGE() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_HUGE;\n    }\n    /**\n   * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */ static get DATETIME_HUGE_WITH_SECONDS() {\n        return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_HUGE_WITH_SECONDS;\n    }\n}\n/**\n * @private\n */ function friendlyDateTime(dateTimeish) {\n    if (DateTime.isDateTime(dateTimeish)) {\n        return dateTimeish;\n    } else if (dateTimeish && dateTimeish.valueOf && (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_2__.isNumber)(dateTimeish.valueOf())) {\n        return DateTime.fromJSDate(dateTimeish);\n    } else if (dateTimeish && typeof dateTimeish === \"object\") {\n        return DateTime.fromObject(dateTimeish);\n    } else {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2RhdGV0aW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyRDtBQUN0QjtBQUNBO0FBQ1I7QUFDZTtBQUNhO0FBQ25CO0FBY2Q7QUFDMkI7QUFDakI7QUFDOEQ7QUFDckI7QUFVNUM7QUFDYztBQU14QjtBQUNtQjtBQUV4QyxNQUFNMEMsVUFBVTtBQUNoQixNQUFNQyxXQUFXO0FBRWpCLFNBQVNDLGdCQUFnQkMsSUFBSTtJQUMzQixPQUFPLElBQUlKLHdEQUFPQSxDQUFDLG9CQUFvQixDQUFDLFVBQVUsRUFBRUksS0FBS0MsSUFBSSxDQUFDLGtCQUFrQixDQUFDO0FBQ25GO0FBRUEsdUVBQXVFO0FBQ3ZFLFNBQVNDLHVCQUF1QkMsRUFBRTtJQUNoQyxJQUFJQSxHQUFHQyxRQUFRLEtBQUssTUFBTTtRQUN4QkQsR0FBR0MsUUFBUSxHQUFHckIscUVBQWVBLENBQUNvQixHQUFHRSxDQUFDO0lBQ3BDO0lBQ0EsT0FBT0YsR0FBR0MsUUFBUTtBQUNwQjtBQUVBLGtHQUFrRztBQUNsRyxvRUFBb0U7QUFDcEUsU0FBU0UsTUFBTUMsSUFBSSxFQUFFQyxJQUFJO0lBQ3ZCLE1BQU1DLFVBQVU7UUFDZEMsSUFBSUgsS0FBS0csRUFBRTtRQUNYVixNQUFNTyxLQUFLUCxJQUFJO1FBQ2ZLLEdBQUdFLEtBQUtGLENBQUM7UUFDVE0sR0FBR0osS0FBS0ksQ0FBQztRQUNUQyxLQUFLTCxLQUFLSyxHQUFHO1FBQ2JDLFNBQVNOLEtBQUtNLE9BQU87SUFDdkI7SUFDQSxPQUFPLElBQUlDLFNBQVNDLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdQLFNBQVNELE1BQU07UUFBRVMsS0FBS1I7SUFBUTtBQUN0RTtBQUVBLDZGQUE2RjtBQUM3RixtRkFBbUY7QUFDbkYsU0FBU1MsVUFBVUMsT0FBTyxFQUFFUixDQUFDLEVBQUVTLEVBQUU7SUFDL0Isa0VBQWtFO0lBQ2xFLElBQUlDLFdBQVdGLFVBQVVSLElB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QU8sS0FBSztRQUNoRixPQUFPbEksU0FBUytILFVBQVUsQ0FBQ3VKO0lBQzdCLE9BQU8sSUFBSUEsZUFBZSxPQUFPQSxnQkFBZ0IsVUFBVTtRQUN6RCxPQUFPdFIsU0FBUzJDLFVBQVUsQ0FBQzJPO0lBQzdCLE9BQU87UUFDTCxNQUFNLElBQUk1Uyw0REFBb0JBLENBQzVCLENBQUMsMkJBQTJCLEVBQUU0UyxZQUFZLFVBQVUsRUFBRSxPQUFPQSxZQUFZLENBQUM7SUFFOUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2lhdG9vbHMtbmV4dC8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZGF0ZXRpbWUuanM/MWY5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRHVyYXRpb24sIHsgZnJpZW5kbHlEdXJhdGlvbiB9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgSW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IEluZm8gZnJvbSBcIi4vaW5mby5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9pbXBsL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCB7XG4gIGlzVW5kZWZpbmVkLFxuICBtYXliZUFycmF5LFxuICBpc0RhdGUsXG4gIGlzTnVtYmVyLFxuICBiZXN0QnksXG4gIGRheXNJbk1vbnRoLFxuICBkYXlzSW5ZZWFyLFxuICBpc0xlYXBZZWFyLFxuICB3ZWVrc0luV2Vla1llYXIsXG4gIG5vcm1hbGl6ZU9iamVjdCxcbiAgcm91bmRUbyxcbiAgb2JqVG9Mb2NhbFRTXG59IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcbmltcG9ydCBkaWZmIGZyb20gXCIuL2ltcGwvZGlmZi5qc1wiO1xuaW1wb3J0IHsgcGFyc2VSRkMyODIyRGF0ZSwgcGFyc2VJU09EYXRlLCBwYXJzZUhUVFBEYXRlLCBwYXJzZVNRTCB9IGZyb20gXCIuL2ltcGwvcmVnZXhQYXJzZXIuanNcIjtcbmltcG9ydCB7IHBhcnNlRnJvbVRva2VucywgZXhwbGFpbkZyb21Ub2tlbnMgfSBmcm9tIFwiLi9pbXBsL3Rva2VuUGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBncmVnb3JpYW5Ub1dlZWssXG4gIHdlZWtUb0dyZWdvcmlhbixcbiAgZ3JlZ29yaWFuVG9PcmRpbmFsLFxuICBvcmRpbmFsVG9HcmVnb3JpYW4sXG4gIGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhLFxuICBoYXNJbnZhbGlkV2Vla0RhdGEsXG4gIGhhc0ludmFsaWRPcmRpbmFsRGF0YSxcbiAgaGFzSW52YWxpZFRpbWVEYXRhXG59IGZyb20gXCIuL2ltcGwvY29udmVyc2lvbnMuanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vaW1wbC9mb3JtYXRzLmpzXCI7XG5pbXBvcnQge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IsXG4gIEludmFsaWRVbml0RXJyb3IsXG4gIEludmFsaWREYXRlVGltZUVycm9yXG59IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRGF0ZVRpbWVcIjtcbmNvbnN0IE1BWF9EQVRFID0gOC42NGUxNTtcblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRab25lKHpvbmUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFwidW5zdXBwb3J0ZWQgem9uZVwiLCBgdGhlIHpvbmUgXCIke3pvbmUubmFtZX1cIiBpcyBub3Qgc3VwcG9ydGVkYCk7XG59XG5cbi8vIHdlIGNhY2hlIHdlZWsgZGF0YSBvbiB0aGUgRFQgb2JqZWN0IGFuZCB0aGlzIGludGVybWVkaWF0ZXMgdGhlIGNhY2hlXG5mdW5jdGlvbiBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKGR0KSB7XG4gIGlmIChkdC53ZWVrRGF0YSA9PT0gbnVsbCkge1xuICAgIGR0LndlZWtEYXRhID0gZ3JlZ29yaWFuVG9XZWVrKGR0LmMpO1xuICB9XG4gIHJldHVybiBkdC53ZWVrRGF0YTtcbn1cblxuLy8gY2xvbmUgcmVhbGx5IG1lYW5zLCBcIm1ha2UgYSBuZXcgb2JqZWN0IHdpdGggdGhlc2UgbW9kaWZpY2F0aW9uc1wiLiBhbGwgXCJzZXR0ZXJzXCIgcmVhbGx5IHVzZSB0aGlzXG4vLyB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHdoaWxlIG9ubHkgY2hhbmdpbmcgc29tZSBvZiB0aGUgcHJvcGVydGllc1xuZnVuY3Rpb24gY2xvbmUoaW5zdCwgYWx0cykge1xuICBjb25zdCBjdXJyZW50ID0ge1xuICAgIHRzOiBpbnN0LnRzLFxuICAgIHpvbmU6IGluc3Quem9uZSxcbiAgICBjOiBpbnN0LmMsXG4gICAgbzogaW5zdC5vLFxuICAgIGxvYzogaW5zdC5sb2MsXG4gICAgaW52YWxpZDogaW5zdC5pbnZhbGlkXG4gIH07XG4gIHJldHVybiBuZXcgRGF0ZVRpbWUoT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudCwgYWx0cywgeyBvbGQ6IGN1cnJlbnQgfSkpO1xufVxuXG4vLyBmaW5kIHRoZSByaWdodCBvZmZzZXQgYSBnaXZlbiBsb2NhbCB0aW1lLiBUaGUgbyBpbnB1dCBpcyBvdXIgZ3Vlc3MsIHdoaWNoIGRldGVybWluZXMgd2hpY2hcbi8vIG9mZnNldCB3ZSdsbCBwaWNrIGluIGFtYmlndW91cyBjYXNlcyAoZS5nLiB0aGVyZSBhcmUgdHdvIDMgQU1zIGIvYyBGYWxsYmFjayBEU1QpXG5mdW5jdGlvbiBmaXhPZmZzZXQobG9jYWxUUywgbywgdHopIHtcbiAgLy8gT3VyIFVUQyB0aW1lIGlzIGp1c3QgYSBndWVzcyBiZWNhdXNlIG91ciBvZmZzZXQgaXMganVzdCBhIGd1ZXNzXG4gIGxldCB1dGNHdWVzcyA9IGxvY2FsVFMgLSBvICogNjAgKiAxMDAwO1xuXG4gIC8vIFRlc3Qgd2hldGhlciB0aGUgem9uZSBtYXRjaGVzIHRoZSBvZmZzZXQgZm9yIHRoaXMgdHNcbiAgY29uc3QgbzIgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuXG4gIC8vIElmIHNvLCBvZmZzZXQgZGlkbid0IGNoYW5nZSBhbmQgd2UncmUgZG9uZVxuICBpZiAobyA9PT0gbzIpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvXTtcbiAgfVxuXG4gIC8vIElmIG5vdCwgY2hhbmdlIHRoZSB0cyBieSB0aGUgZGlmZmVyZW5jZSBpbiB0aGUgb2Zmc2V0XG4gIHV0Y0d1ZXNzIC09IChvMiAtIG8pICogNjAgKiAxMDAwO1xuXG4gIC8vIElmIHRoYXQgZ2l2ZXMgdXMgdGhlIGxvY2FsIHRpbWUgd2Ugd2FudCwgd2UncmUgZG9uZVxuICBjb25zdCBvMyA9IHR6Lm9mZnNldCh1dGNHdWVzcyk7XG4gIGlmIChvMiA9PT0gbzMpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvMl07XG4gIH1cblxuICAvLyBJZiBpdCdzIGRpZmZlcmVudCwgd2UncmUgaW4gYSBob2xlIHRpbWUuIFRoZSBvZmZzZXQgaGFzIGNoYW5nZWQsIGJ1dCB0aGUgd2UgZG9uJ3QgYWRqdXN0IHRoZSB0aW1lXG4gIHJldHVybiBbbG9jYWxUUyAtIE1hdGgubWluKG8yLCBvMykgKiA2MCAqIDEwMDAsIE1hdGgubWF4KG8yLCBvMyldO1xufVxuXG4vLyBjb252ZXJ0IGFuIGVwb2NoIHRpbWVzdGFtcCBpbnRvIGEgY2FsZW5kYXIgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG9mZnNldFxuZnVuY3Rpb24gdHNUb09iaih0cywgb2Zmc2V0KSB7XG4gIHRzICs9IG9mZnNldCAqIDYwICogMTAwMDtcblxuICBjb25zdCBkID0gbmV3IERhdGUodHMpO1xuXG4gIHJldHVybiB7XG4gICAgeWVhcjogZC5nZXRVVENGdWxsWWVhcigpLFxuICAgIG1vbnRoOiBkLmdldFVUQ01vbnRoKCkgKyAxLFxuICAgIGRheTogZC5nZXRVVENEYXRlKCksXG4gICAgaG91cjogZC5nZXRVVENIb3VycygpLFxuICAgIG1pbnV0ZTogZC5nZXRVVENNaW51dGVzKCksXG4gICAgc2Vjb25kOiBkLmdldFVUQ1NlY29uZHMoKSxcbiAgICBtaWxsaXNlY29uZDogZC5nZXRVVENNaWxsaXNlY29uZHMoKVxuICB9O1xufVxuXG4vLyBjb252ZXJ0IGEgY2FsZW5kYXIgb2JqZWN0IHRvIGEgZXBvY2ggdGltZXN0YW1wXG5mdW5jdGlvbiBvYmpUb1RTKG9iaiwgb2Zmc2V0LCB6b25lKSB7XG4gIHJldHVybiBmaXhPZmZzZXQob2JqVG9Mb2NhbFRTKG9iaiksIG9mZnNldCwgem9uZSk7XG59XG5cbi8vIGNyZWF0ZSBhIG5ldyBEVCBpbnN0YW5jZSBieSBhZGRpbmcgYSBkdXJhdGlvbiwgYWRqdXN0aW5nIGZvciBEU1RzXG5mdW5jdGlvbiBhZGp1c3RUaW1lKGluc3QsIGR1cikge1xuICBjb25zdCBvUHJlID0gaW5zdC5vLFxuICAgIHllYXIgPSBpbnN0LmMueWVhciArIE1hdGgudHJ1bmMoZHVyLnllYXJzKSxcbiAgICBtb250aCA9IGluc3QuYy5tb250aCArIE1hdGgudHJ1bmMoZHVyLm1vbnRocykgKyBNYXRoLnRydW5jKGR1ci5xdWFydGVycykgKiAzLFxuICAgIGMgPSBPYmplY3QuYXNzaWduKHt9LCBpbnN0LmMsIHtcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheTpcbiAgICAgICAgTWF0aC5taW4oaW5zdC5jLmRheSwgZGF5c0luTW9udGgoeWVhciwgbW9udGgpKSArXG4gICAgICAgIE1hdGgudHJ1bmMoZHVyLmRheXMpICtcbiAgICAgICAgTWF0aC50cnVuYyhkdXIud2Vla3MpICogN1xuICAgIH0pLFxuICAgIG1pbGxpc1RvQWRkID0gRHVyYXRpb24uZnJvbU9iamVjdCh7XG4gICAgICB5ZWFyczogZHVyLnllYXJzIC0gTWF0aC50cnVuYyhkdXIueWVhcnMpLFxuICAgICAgcXVhcnRlcnM6IGR1ci5xdWFydGVycyAtIE1hdGgudHJ1bmMoZHVyLnF1YXJ0ZXJzKSxcbiAgICAgIG1vbnRoczogZHVyLm1vbnRocyAtIE1hdGgudHJ1bmMoZHVyLm1vbnRocyksXG4gICAgICB3ZWVrczogZHVyLndlZWtzIC0gTWF0aC50cnVuYyhkdXIud2Vla3MpLFxuICAgICAgZGF5czogZHVyLmRheXMgLSBNYXRoLnRydW5jKGR1ci5kYXlzKSxcbiAgICAgIGhvdXJzOiBkdXIuaG91cnMsXG4gICAgICBtaW51dGVzOiBkdXIubWludXRlcyxcbiAgICAgIHNlY29uZHM6IGR1ci5zZWNvbmRzLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkdXIubWlsbGlzZWNvbmRzXG4gICAgfSkuYXMoXCJtaWxsaXNlY29uZHNcIiksXG4gICAgbG9jYWxUUyA9IG9ialRvTG9jYWxUUyhjKTtcblxuICBsZXQgW3RzLCBvXSA9IGZpeE9mZnNldChsb2NhbFRTLCBvUHJlLCBpbnN0LnpvbmUpO1xuXG4gIGlmIChtaWxsaXNUb0FkZCAhPT0gMCkge1xuICAgIHRzICs9IG1pbGxpc1RvQWRkO1xuICAgIC8vIHRoYXQgY291bGQgaGF2ZSBjaGFuZ2VkIHRoZSBvZmZzZXQgYnkgZ29pbmcgb3ZlciBhIERTVCwgYnV0IHdlIHdhbnQgdG8ga2VlcCB0aGUgdHMgdGhlIHNhbWVcbiAgICBvID0gaW5zdC56b25lLm9mZnNldCh0cyk7XG4gIH1cblxuICByZXR1cm4geyB0cywgbyB9O1xufVxuXG4vLyBoZWxwZXIgdXNlZnVsIGluIHR1cm5pbmcgdGhlIHJlc3VsdHMgb2YgcGFyc2luZyBpbnRvIHJlYWwgZGF0ZXNcbi8vIGJ5IGhhbmRsaW5nIHRoZSB6b25lIG9wdGlvbnNcbmZ1bmN0aW9uIHBhcnNlRGF0YVRvRGF0ZVRpbWUocGFyc2VkLCBwYXJzZWRab25lLCBvcHRzLCBmb3JtYXQsIHRleHQpIHtcbiAgY29uc3QgeyBzZXRab25lLCB6b25lIH0gPSBvcHRzO1xuICBpZiAocGFyc2VkICYmIE9iamVjdC5rZXlzKHBhcnNlZCkubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgaW50ZXJwcmV0YXRpb25ab25lID0gcGFyc2VkWm9uZSB8fCB6b25lLFxuICAgICAgaW5zdCA9IERhdGVUaW1lLmZyb21PYmplY3QoXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkLCBvcHRzLCB7XG4gICAgICAgICAgem9uZTogaW50ZXJwcmV0YXRpb25ab25lLFxuICAgICAgICAgIC8vIHNldFpvbmUgaXMgYSB2YWxpZCBvcHRpb24gaW4gdGhlIGNhbGxpbmcgbWV0aG9kcywgYnV0IG5vdCBpbiBmcm9tT2JqZWN0XG4gICAgICAgICAgc2V0Wm9uZTogdW5kZWZpbmVkXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIHJldHVybiBzZXRab25lID8gaW5zdCA6IGluc3Quc2V0Wm9uZSh6b25lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcbiAgICAgIG5ldyBJbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyAke2Zvcm1hdH1gKVxuICAgICk7XG4gIH1cbn1cblxuLy8gaWYgeW91IHdhbnQgdG8gb3V0cHV0IGEgdGVjaG5pY2FsIGZvcm1hdCAoZS5nLiBSRkMgMjgyMiksIHRoaXMgaGVscGVyXG4vLyBoZWxwcyBoYW5kbGUgdGhlIGRldGFpbHNcbmZ1bmN0aW9uIHRvVGVjaEZvcm1hdChkdCwgZm9ybWF0LCBhbGxvd1ogPSB0cnVlKSB7XG4gIHJldHVybiBkdC5pc1ZhbGlkXG4gICAgPyBGb3JtYXR0ZXIuY3JlYXRlKExvY2FsZS5jcmVhdGUoXCJlbi1VU1wiKSwge1xuICAgICAgICBhbGxvd1osXG4gICAgICAgIGZvcmNlU2ltcGxlOiB0cnVlXG4gICAgICB9KS5mb3JtYXREYXRlVGltZUZyb21TdHJpbmcoZHQsIGZvcm1hdClcbiAgICA6IG51bGw7XG59XG5cbi8vIHRlY2huaWNhbCB0aW1lIGZvcm1hdHMgKGUuZy4gdGhlIHRpbWUgcGFydCBvZiBJU08gODYwMSksIHRha2Ugc29tZSBvcHRpb25zXG4vLyBhbmQgdGhpcyBjb21tb25pemVzIHRoZWlyIGhhbmRsaW5nXG5mdW5jdGlvbiB0b1RlY2hUaW1lRm9ybWF0KFxuICBkdCxcbiAge1xuICAgIHN1cHByZXNzU2Vjb25kcyA9IGZhbHNlLFxuICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzID0gZmFsc2UsXG4gICAgaW5jbHVkZU9mZnNldCxcbiAgICBpbmNsdWRlUHJlZml4ID0gZmFsc2UsXG4gICAgaW5jbHVkZVpvbmUgPSBmYWxzZSxcbiAgICBzcGFjZVpvbmUgPSBmYWxzZSxcbiAgICBmb3JtYXQgPSBcImV4dGVuZGVkXCJcbiAgfVxuKSB7XG4gIGxldCBmbXQgPSBmb3JtYXQgPT09IFwiYmFzaWNcIiA/IFwiSEhtbVwiIDogXCJISDptbVwiO1xuXG4gIGlmICghc3VwcHJlc3NTZWNvbmRzIHx8IGR0LnNlY29uZCAhPT0gMCB8fCBkdC5taWxsaXNlY29uZCAhPT0gMCkge1xuICAgIGZtdCArPSBmb3JtYXQgPT09IFwiYmFzaWNcIiA/IFwic3NcIiA6IFwiOnNzXCI7XG4gICAgaWYgKCFzdXBwcmVzc01pbGxpc2Vjb25kcyB8fCBkdC5taWxsaXNlY29uZCAhPT0gMCkge1xuICAgICAgZm10ICs9IFwiLlNTU1wiO1xuICAgIH1cbiAgfVxuXG4gIGlmICgoaW5jbHVkZVpvbmUgfHwgaW5jbHVkZU9mZnNldCkgJiYgc3BhY2Vab25lKSB7XG4gICAgZm10ICs9IFwiIFwiO1xuICB9XG5cbiAgaWYgKGluY2x1ZGVab25lKSB7XG4gICAgZm10ICs9IFwielwiO1xuICB9IGVsc2UgaWYgKGluY2x1ZGVPZmZzZXQpIHtcbiAgICBmbXQgKz0gZm9ybWF0ID09PSBcImJhc2ljXCIgPyBcIlpaWlwiIDogXCJaWlwiO1xuICB9XG5cbiAgbGV0IHN0ciA9IHRvVGVjaEZvcm1hdChkdCwgZm10KTtcblxuICBpZiAoaW5jbHVkZVByZWZpeCkge1xuICAgIHN0ciA9IFwiVFwiICsgc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLy8gZGVmYXVsdHMgZm9yIHVuc3BlY2lmaWVkIHVuaXRzIGluIHRoZSBzdXBwb3J0ZWQgY2FsZW5kYXJzXG5jb25zdCBkZWZhdWx0VW5pdFZhbHVlcyA9IHtcbiAgICBtb250aDogMSxcbiAgICBkYXk6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIG1pbGxpc2Vjb25kOiAwXG4gIH0sXG4gIGRlZmF1bHRXZWVrVW5pdFZhbHVlcyA9IHtcbiAgICB3ZWVrTnVtYmVyOiAxLFxuICAgIHdlZWtkYXk6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIG1pbGxpc2Vjb25kOiAwXG4gIH0sXG4gIGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcyA9IHtcbiAgICBvcmRpbmFsOiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMFxuICB9O1xuXG4vLyBVbml0cyBpbiB0aGUgc3VwcG9ydGVkIGNhbGVuZGFycywgc29ydGVkIGJ5IGJpZ25lc3NcbmNvbnN0IG9yZGVyZWRVbml0cyA9IFtcInllYXJcIiwgXCJtb250aFwiLCBcImRheVwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSxcbiAgb3JkZXJlZFdlZWtVbml0cyA9IFtcbiAgICBcIndlZWtZZWFyXCIsXG4gICAgXCJ3ZWVrTnVtYmVyXCIsXG4gICAgXCJ3ZWVrZGF5XCIsXG4gICAgXCJob3VyXCIsXG4gICAgXCJtaW51dGVcIixcbiAgICBcInNlY29uZFwiLFxuICAgIFwibWlsbGlzZWNvbmRcIlxuICBdLFxuICBvcmRlcmVkT3JkaW5hbFVuaXRzID0gW1wieWVhclwiLCBcIm9yZGluYWxcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl07XG5cbi8vIHN0YW5kYXJkaXplIGNhc2UgYW5kIHBsdXJhbGl0eSBpbiB1bml0c1xuZnVuY3Rpb24gbm9ybWFsaXplVW5pdCh1bml0KSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7XG4gICAgeWVhcjogXCJ5ZWFyXCIsXG4gICAgeWVhcnM6IFwieWVhclwiLFxuICAgIG1vbnRoOiBcIm1vbnRoXCIsXG4gICAgbW9udGhzOiBcIm1vbnRoXCIsXG4gICAgZGF5OiBcImRheVwiLFxuICAgIGRheXM6IFwiZGF5XCIsXG4gICAgaG91cjogXCJob3VyXCIsXG4gICAgaG91cnM6IFwiaG91clwiLFxuICAgIG1pbnV0ZTogXCJtaW51dGVcIixcbiAgICBtaW51dGVzOiBcIm1pbnV0ZVwiLFxuICAgIHF1YXJ0ZXI6IFwicXVhcnRlclwiLFxuICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJcIixcbiAgICBzZWNvbmQ6IFwic2Vjb25kXCIsXG4gICAgc2Vjb25kczogXCJzZWNvbmRcIixcbiAgICBtaWxsaXNlY29uZDogXCJtaWxsaXNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kczogXCJtaWxsaXNlY29uZFwiLFxuICAgIHdlZWtkYXk6IFwid2Vla2RheVwiLFxuICAgIHdlZWtkYXlzOiBcIndlZWtkYXlcIixcbiAgICB3ZWVrbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrc251bWJlcjogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla251bWJlcnM6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWt5ZWFyOiBcIndlZWtZZWFyXCIsXG4gICAgd2Vla3llYXJzOiBcIndlZWtZZWFyXCIsXG4gICAgb3JkaW5hbDogXCJvcmRpbmFsXCJcbiAgfVt1bml0LnRvTG93ZXJDYXNlKCldO1xuXG4gIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8vIHRoaXMgaXMgYSBkdW1iZWQgZG93biB2ZXJzaW9uIG9mIGZyb21PYmplY3QoKSB0aGF0IHJ1bnMgYWJvdXQgNjAlIGZhc3RlclxuLy8gYnV0IGRvZXNuJ3QgZG8gYW55IHZhbGlkYXRpb24sIG1ha2VzIGEgYnVuY2ggb2YgYXNzdW1wdGlvbnMgYWJvdXQgd2hhdCB1bml0c1xuLy8gYXJlIHByZXNlbnQsIGFuZCBzbyBvbi5cbmZ1bmN0aW9uIHF1aWNrRFQob2JqLCB6b25lKSB7XG4gIC8vIGFzc3VtZSB3ZSBoYXZlIHRoZSBoaWdoZXItb3JkZXIgdW5pdHNcbiAgZm9yIChjb25zdCB1IG9mIG9yZGVyZWRVbml0cykge1xuICAgIGlmIChpc1VuZGVmaW5lZChvYmpbdV0pKSB7XG4gICAgICBvYmpbdV0gPSBkZWZhdWx0VW5pdFZhbHVlc1t1XTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBpbnZhbGlkID0gaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEob2JqKSB8fCBoYXNJbnZhbGlkVGltZURhdGEob2JqKTtcbiAgaWYgKGludmFsaWQpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgfVxuXG4gIGNvbnN0IHRzTm93ID0gU2V0dGluZ3Mubm93KCksXG4gICAgb2Zmc2V0UHJvdmlzID0gem9uZS5vZmZzZXQodHNOb3cpLFxuICAgIFt0cywgb10gPSBvYmpUb1RTKG9iaiwgb2Zmc2V0UHJvdmlzLCB6b25lKTtcblxuICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICB0cyxcbiAgICB6b25lLFxuICAgIG9cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRpZmZSZWxhdGl2ZShzdGFydCwgZW5kLCBvcHRzKSB7XG4gIGNvbnN0IHJvdW5kID0gaXNVbmRlZmluZWQob3B0cy5yb3VuZCkgPyB0cnVlIDogb3B0cy5yb3VuZCxcbiAgICBmb3JtYXQgPSAoYywgdW5pdCkgPT4ge1xuICAgICAgYyA9IHJvdW5kVG8oYywgcm91bmQgfHwgb3B0cy5jYWxlbmRhcnkgPyAwIDogMiwgdHJ1ZSk7XG4gICAgICBjb25zdCBmb3JtYXR0ZXIgPSBlbmQubG9jLmNsb25lKG9wdHMpLnJlbEZvcm1hdHRlcihvcHRzKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGMsIHVuaXQpO1xuICAgIH0sXG4gICAgZGlmZmVyID0gdW5pdCA9PiB7XG4gICAgICBpZiAob3B0cy5jYWxlbmRhcnkpIHtcbiAgICAgICAgaWYgKCFlbmQuaGFzU2FtZShzdGFydCwgdW5pdCkpIHtcbiAgICAgICAgICByZXR1cm4gZW5kXG4gICAgICAgICAgICAuc3RhcnRPZih1bml0KVxuICAgICAgICAgICAgLmRpZmYoc3RhcnQuc3RhcnRPZih1bml0KSwgdW5pdClcbiAgICAgICAgICAgIC5nZXQodW5pdCk7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbmQuZGlmZihzdGFydCwgdW5pdCkuZ2V0KHVuaXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgaWYgKG9wdHMudW5pdCkge1xuICAgIHJldHVybiBmb3JtYXQoZGlmZmVyKG9wdHMudW5pdCksIG9wdHMudW5pdCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHVuaXQgb2Ygb3B0cy51bml0cykge1xuICAgIGNvbnN0IGNvdW50ID0gZGlmZmVyKHVuaXQpO1xuICAgIGlmIChNYXRoLmFicyhjb3VudCkgPj0gMSkge1xuICAgICAgcmV0dXJuIGZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXQoc3RhcnQgPiBlbmQgPyAtMCA6IDAsIG9wdHMudW5pdHNbb3B0cy51bml0cy5sZW5ndGggLSAxXSk7XG59XG5cbi8qKlxuICogQSBEYXRlVGltZSBpcyBhbiBpbW11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgc3BlY2lmaWMgZGF0ZSBhbmQgdGltZSBhbmQgYWNjb21wYW55aW5nIG1ldGhvZHMuIEl0IGNvbnRhaW5zIGNsYXNzIGFuZCBpbnN0YW5jZSBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLlxuICpcbiAqIEEgRGF0ZVRpbWUgY29tcHJpc2VzIG9mOlxuICogKiBBIHRpbWVzdGFtcC4gRWFjaCBEYXRlVGltZSBpbnN0YW5jZSByZWZlcnMgdG8gYSBzcGVjaWZpYyBtaWxsaXNlY29uZCBvZiB0aGUgVW5peCBlcG9jaC5cbiAqICogQSB0aW1lIHpvbmUuIEVhY2ggaW5zdGFuY2UgaXMgY29uc2lkZXJlZCBpbiB0aGUgY29udGV4dCBvZiBhIHNwZWNpZmljIHpvbmUgKGJ5IGRlZmF1bHQgdGhlIGxvY2FsIHN5c3RlbSdzIHpvbmUpLlxuICogKiBDb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdGhhdCBlZmZlY3QgaG93IG91dHB1dCBzdHJpbmdzIGFyZSBmb3JtYXR0ZWQsIHN1Y2ggYXMgYGxvY2FsZWAsIGBudW1iZXJpbmdTeXN0ZW1gLCBhbmQgYG91dHB1dENhbGVuZGFyYC5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBmdW5jdGlvbmFsaXR5IGl0IHByb3ZpZGVzOlxuICpcbiAqICogKipDcmVhdGlvbioqOiBUbyBjcmVhdGUgYSBEYXRlVGltZSBmcm9tIGl0cyBjb21wb25lbnRzLCB1c2Ugb25lIG9mIGl0cyBmYWN0b3J5IGNsYXNzIG1ldGhvZHM6IHtAbGluayBsb2NhbH0sIHtAbGluayB1dGN9LCBhbmQgKG1vc3QgZmxleGlibHkpIHtAbGluayBmcm9tT2JqZWN0fS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgc3RhbmRhcmQgc3RyaW5nIGZvcm1hdCwgdXNlIHtAbGluayBmcm9tSVNPfSwge0BsaW5rIGZyb21IVFRQfSwgYW5kIHtAbGluayBmcm9tUkZDMjgyMn0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIGN1c3RvbSBzdHJpbmcgZm9ybWF0LCB1c2Uge0BsaW5rIGZyb21Gb3JtYXR9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBuYXRpdmUgSlMgZGF0ZSwgdXNlIHtAbGluayBmcm9tSlNEYXRlfS5cbiAqICogKipHcmVnb3JpYW4gY2FsZW5kYXIgYW5kIHRpbWUqKjogVG8gZXhhbWluZSB0aGUgR3JlZ29yaWFuIHByb3BlcnRpZXMgb2YgYSBEYXRlVGltZSBpbmRpdmlkdWFsbHkgKGkuZSBhcyBvcHBvc2VkIHRvIGNvbGxlY3RpdmVseSB0aHJvdWdoIHtAbGluayB0b09iamVjdH0pLCB1c2UgdGhlIHtAbGluayB5ZWFyfSwge0BsaW5rIG1vbnRofSxcbiAqIHtAbGluayBkYXl9LCB7QGxpbmsgaG91cn0sIHtAbGluayBtaW51dGV9LCB7QGxpbmsgc2Vjb25kfSwge0BsaW5rIG1pbGxpc2Vjb25kfSBhY2Nlc3NvcnMuXG4gKiAqICoqV2VlayBjYWxlbmRhcioqOiBGb3IgSVNPIHdlZWsgY2FsZW5kYXIgYXR0cmlidXRlcywgc2VlIHRoZSB7QGxpbmsgd2Vla1llYXJ9LCB7QGxpbmsgd2Vla051bWJlcn0sIGFuZCB7QGxpbmsgd2Vla2RheX0gYWNjZXNzb3JzLlxuICogKiAqKkNvbmZpZ3VyYXRpb24qKiBTZWUgdGhlIHtAbGluayBsb2NhbGV9IGFuZCB7QGxpbmsgbnVtYmVyaW5nU3lzdGVtfSBhY2Nlc3NvcnMuXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKjogVG8gdHJhbnNmb3JtIHRoZSBEYXRlVGltZSBpbnRvIG90aGVyIERhdGVUaW1lcywgdXNlIHtAbGluayBzZXR9LCB7QGxpbmsgcmVjb25maWd1cmV9LCB7QGxpbmsgc2V0Wm9uZX0sIHtAbGluayBzZXRMb2NhbGV9LCB7QGxpbmsgcGx1c30sIHtAbGluayBtaW51c30sIHtAbGluayBlbmRPZn0sIHtAbGluayBzdGFydE9mfSwge0BsaW5rIHRvVVRDfSwgYW5kIHtAbGluayB0b0xvY2FsfS5cbiAqICogKipPdXRwdXQqKjogVG8gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCB1c2UgdGhlIHtAbGluayB0b1JlbGF0aXZlfSwge0BsaW5rIHRvUmVsYXRpdmVDYWxlbmRhcn0sIHtAbGluayB0b0pTT059LCB7QGxpbmsgdG9JU099LCB7QGxpbmsgdG9IVFRQfSwge0BsaW5rIHRvT2JqZWN0fSwge0BsaW5rIHRvUkZDMjgyMn0sIHtAbGluayB0b1N0cmluZ30sIHtAbGluayB0b0xvY2FsZVN0cmluZ30sIHtAbGluayB0b0Zvcm1hdH0sIHtAbGluayB0b01pbGxpc30gYW5kIHtAbGluayB0b0pTRGF0ZX0uXG4gKlxuICogVGhlcmUncyBwbGVudHkgb3RoZXJzIGRvY3VtZW50ZWQgYmVsb3cuIEluIGFkZGl0aW9uLCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdWJ0bGVyIHRvcGljcyBsaWtlIGludGVybmF0aW9uYWxpemF0aW9uLCB0aW1lIHpvbmVzLCBhbHRlcm5hdGl2ZSBjYWxlbmRhcnMsIHZhbGlkaXR5LCBhbmQgc28gb24sIHNlZSB0aGUgZXh0ZXJuYWwgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZVRpbWUge1xuICAvKipcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCB6b25lID0gY29uZmlnLnpvbmUgfHwgU2V0dGluZ3MuZGVmYXVsdFpvbmU7XG5cbiAgICBsZXQgaW52YWxpZCA9XG4gICAgICBjb25maWcuaW52YWxpZCB8fFxuICAgICAgKE51bWJlci5pc05hTihjb25maWcudHMpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbCkgfHxcbiAgICAgICghem9uZS5pc1ZhbGlkID8gdW5zdXBwb3J0ZWRab25lKHpvbmUpIDogbnVsbCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cyA9IGlzVW5kZWZpbmVkKGNvbmZpZy50cykgPyBTZXR0aW5ncy5ub3coKSA6IGNvbmZpZy50cztcblxuICAgIGxldCBjID0gbnVsbCxcbiAgICAgIG8gPSBudWxsO1xuICAgIGlmICghaW52YWxpZCkge1xuICAgICAgY29uc3QgdW5jaGFuZ2VkID0gY29uZmlnLm9sZCAmJiBjb25maWcub2xkLnRzID09PSB0aGlzLnRzICYmIGNvbmZpZy5vbGQuem9uZS5lcXVhbHMoem9uZSk7XG5cbiAgICAgIGlmICh1bmNoYW5nZWQpIHtcbiAgICAgICAgW2MsIG9dID0gW2NvbmZpZy5vbGQuYywgY29uZmlnLm9sZC5vXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG90ID0gem9uZS5vZmZzZXQodGhpcy50cyk7XG4gICAgICAgIGMgPSB0c1RvT2JqKHRoaXMudHMsIG90KTtcbiAgICAgICAgaW52YWxpZCA9IE51bWJlci5pc05hTihjLnllYXIpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbDtcbiAgICAgICAgYyA9IGludmFsaWQgPyBudWxsIDogYztcbiAgICAgICAgbyA9IGludmFsaWQgPyBudWxsIDogb3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fem9uZSA9IHpvbmU7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2MgPSBjb25maWcubG9jIHx8IExvY2FsZS5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud2Vla0RhdGEgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYyA9IGM7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vID0gbztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25EYXRlVGltZSA9IHRydWU7XG4gIH1cblxuICAvLyBDT05TVFJVQ1RcblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZm9yIHRoZSBjdXJyZW50IGluc3RhbnQsIGluIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqXG4gICAqIFVzZSBTZXR0aW5ncyB0byBvdmVycmlkZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpZiBuZWVkZWQuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy9+PiBub3cgaW4gdGhlIElTTyBmb3JtYXRcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvY2FsIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYGxvY2FsKClgIHdpdGggbm8gYXJndW1lbnRzKSwgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb250aD0xXSAtIFRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF5PTFdIC0gVGhlIGRheSBvZiB0aGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hvdXI9MF0gLSBUaGUgaG91ciBvZiB0aGUgZGF5LCBpbiAyNC1ob3VyIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW51dGU9MF0gLSBUaGUgbWludXRlIG9mIHRoZSBob3VyLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmQ9MF0gLSBUaGUgc2Vjb25kIG9mIHRoZSBtaW51dGUsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbGxpc2Vjb25kPTBdIC0gVGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3KSAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMS0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMikgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSkgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgNDUpICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgNDUsIDEwKSAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgNDUsIDEwLCA3NjUpIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMC43NjVcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgbG9jYWwoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHllYXIpKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUubm93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBxdWlja0RUKFxuICAgICAgICB7XG4gICAgICAgICAgeWVhcixcbiAgICAgICAgICBtb250aCxcbiAgICAgICAgICBkYXksXG4gICAgICAgICAgaG91cixcbiAgICAgICAgICBtaW51dGUsXG4gICAgICAgICAgc2Vjb25kLFxuICAgICAgICAgIG1pbGxpc2Vjb25kXG4gICAgICAgIH0sXG4gICAgICAgIFNldHRpbmdzLmRlZmF1bHRab25lXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBpbiBVVENcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5ZWFyXSAtIFRoZSBjYWxlbmRhciB5ZWFyLiBJZiBvbWl0dGVkIChhcyBpbiwgY2FsbCBgdXRjKClgIHdpdGggbm8gYXJndW1lbnRzKSwgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb250aD0xXSAtIFRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF5PTFdIC0gVGhlIGRheSBvZiB0aGUgbW9udGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtob3VyPTBdIC0gVGhlIGhvdXIgb2YgdGhlIGRheSwgaW4gMjQtaG91ciB0aW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWludXRlPTBdIC0gVGhlIG1pbnV0ZSBvZiB0aGUgaG91ciwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kPTBdIC0gVGhlIHNlY29uZCBvZiB0aGUgbWludXRlLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaWxsaXNlY29uZD0wXSAtIFRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgOTk5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gbm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3KSAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMS0wMVQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMpICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTAxVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIpICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSkgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSkgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIDEwLCA3NjUpIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMC43NjVaXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIHV0Yyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQoeWVhcikpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogU2V0dGluZ3Mubm93KCksXG4gICAgICAgIHpvbmU6IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBxdWlja0RUKFxuICAgICAgICB7XG4gICAgICAgICAgeWVhcixcbiAgICAgICAgICBtb250aCxcbiAgICAgICAgICBkYXksXG4gICAgICAgICAgaG91cixcbiAgICAgICAgICBtaW51dGUsXG4gICAgICAgICAgc2Vjb25kLFxuICAgICAgICAgIG1pbGxpc2Vjb25kXG4gICAgICAgIH0sXG4gICAgICAgIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3QuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlIC0gYSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21KU0RhdGUoZGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHMgPSBpc0RhdGUoZGF0ZSkgPyBkYXRlLnZhbHVlT2YoKSA6IE5hTjtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHRzKSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHpvbmVUb1VzZSA9IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgdHM6IHRzLFxuICAgICAgem9uZTogem9uZVRvVXNlLFxuICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCAobWVhbmluZyBzaW5jZSAxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaWxsaXNlY29uZHMgLSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbU1pbGxpcyhtaWxsaXNlY29uZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNOdW1iZXIobWlsbGlzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgZnJvbU1pbGxpcyByZXF1aXJlcyBhIG51bWVyaWNhbCBpbnB1dCwgYnV0IHJlY2VpdmVkIGEgJHt0eXBlb2YgbWlsbGlzZWNvbmRzfSB3aXRoIHZhbHVlICR7bWlsbGlzZWNvbmRzfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChtaWxsaXNlY29uZHMgPCAtTUFYX0RBVEUgfHwgbWlsbGlzZWNvbmRzID4gTUFYX0RBVEUpIHtcbiAgICAgIC8vIHRoaXMgaXNuJ3QgcGVyZmVjdCBiZWNhdXNlIGJlY2F1c2Ugd2UgY2FuIHN0aWxsIGVuZCB1cCBvdXQgb2YgcmFuZ2UgYmVjYXVzZSBvZiBhZGRpdGlvbmFsIHNoaWZ0aW5nLCBidXQgaXQncyBhIHN0YXJ0XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcIlRpbWVzdGFtcCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogbWlsbGlzZWNvbmRzLFxuICAgICAgICB6b25lOiBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCAobWVhbmluZyBzaW5jZSAxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWNvbmRzIC0gYSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSAxOTcwIFVUQ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRpb25zLnpvbmU9J2xvY2FsJ10gLSB0aGUgem9uZSB0byBwbGFjZSB0aGUgRGF0ZVRpbWUgaW50b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxlXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tU2Vjb25kcyhzZWNvbmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzTnVtYmVyKHNlY29uZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tU2Vjb25kcyByZXF1aXJlcyBhIG51bWVyaWNhbCBpbnB1dFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiBzZWNvbmRzICogMTAwMCxcbiAgICAgICAgem9uZTogbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcicgYW5kICdob3VyJyB3aXRoIHJlYXNvbmFibGUgZGVmYXVsdHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGNyZWF0ZSB0aGUgRGF0ZVRpbWUgZnJvbVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnllYXIgLSBhIHllYXIsIHN1Y2ggYXMgMTk4N1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoIC0gYSBtb250aCwgMS0xMlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmRheSAtIGEgZGF5IG9mIHRoZSBtb250aCwgMS0zMSwgZGVwZW5kaW5nIG9uIHRoZSBtb250aFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm9yZGluYWwgLSBkYXkgb2YgdGhlIHllYXIsIDEtMzY1IG9yIDM2NlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtZZWFyIC0gYW4gSVNPIHdlZWsgeWVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtOdW1iZXIgLSBhbiBJU08gd2VlayBudW1iZXIsIGJldHdlZW4gMSBhbmQgNTIgb3IgNTMsIGRlcGVuZGluZyBvbiB0aGUgeWVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtkYXkgLSBhbiBJU08gd2Vla2RheSwgMS03LCB3aGVyZSAxIGlzIE1vbmRheSBhbmQgNyBpcyBTdW5kYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5ob3VyIC0gaG91ciBvZiB0aGUgZGF5LCAwLTIzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlIC0gbWludXRlIG9mIHRoZSBob3VyLCAwLTU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kIC0gc2Vjb25kIG9mIHRoZSBtaW51dGUsIDAtNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZCAtIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIDAtOTk5XG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvYmouem9uZT0nbG9jYWwnXSAtIGludGVycHJldCB0aGUgbnVtYmVycyBpbiB0aGUgY29udGV4dCBvZiBhIHBhcnRpY3VsYXIgem9uZS4gQ2FuIHRha2UgYW55IHZhbHVlIHRha2VuIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBzZXRab25lKClcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvYmoubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvYmoub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvYmoubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHllYXI6IDE5ODIsIG1vbnRoOiA1LCBkYXk6IDI1fSkudG9JU09EYXRlKCkgLy89PiAnMTk4Mi0wNS0yNSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHllYXI6IDE5ODIgfSkudG9JU09EYXRlKCkgLy89PiAnMTk4Mi0wMS0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSkgLy9+PiB0b2RheSBhdCAxMDoyNjowNlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiwgem9uZTogJ3V0YycgfSksXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2LCB6b25lOiAnbG9jYWwnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2LCB6b25lOiAnQW1lcmljYS9OZXdfWW9yaycgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHdlZWtZZWFyOiAyMDE2LCB3ZWVrTnVtYmVyOiAyLCB3ZWVrZGF5OiAzIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzIwMTYtMDEtMTMnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21PYmplY3Qob2JqKSB7XG4gICAgY29uc3Qgem9uZVRvVXNlID0gbm9ybWFsaXplWm9uZShvYmouem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICghem9uZVRvVXNlLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lVG9Vc2UpKTtcbiAgICB9XG5cbiAgICBjb25zdCB0c05vdyA9IFNldHRpbmdzLm5vdygpLFxuICAgICAgb2Zmc2V0UHJvdmlzID0gem9uZVRvVXNlLm9mZnNldCh0c05vdyksXG4gICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplVW5pdCwgW1xuICAgICAgICBcInpvbmVcIixcbiAgICAgICAgXCJsb2NhbGVcIixcbiAgICAgICAgXCJvdXRwdXRDYWxlbmRhclwiLFxuICAgICAgICBcIm51bWJlcmluZ1N5c3RlbVwiXG4gICAgICBdKSxcbiAgICAgIGNvbnRhaW5zT3JkaW5hbCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpLFxuICAgICAgY29udGFpbnNHcmVnb3JZZWFyID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQueWVhciksXG4gICAgICBjb250YWluc0dyZWdvck1EID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQubW9udGgpIHx8ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLmRheSksXG4gICAgICBjb250YWluc0dyZWdvciA9IGNvbnRhaW5zR3JlZ29yWWVhciB8fCBjb250YWluc0dyZWdvck1ELFxuICAgICAgZGVmaW5pdGVXZWVrRGVmID0gbm9ybWFsaXplZC53ZWVrWWVhciB8fCBub3JtYWxpemVkLndlZWtOdW1iZXIsXG4gICAgICBsb2MgPSBMb2NhbGUuZnJvbU9iamVjdChvYmopO1xuXG4gICAgLy8gY2FzZXM6XG4gICAgLy8ganVzdCBhIHdlZWtkYXkgLT4gdGhpcyB3ZWVrJ3MgaW5zdGFuY2Ugb2YgdGhhdCB3ZWVrZGF5LCBubyB3b3JyaWVzXG4gICAgLy8gKGdyZWdvcmlhbiBkYXRhIG9yIG9yZGluYWwpICsgKHdlZWtZZWFyIG9yIHdlZWtOdW1iZXIpIC0+IGVycm9yXG4gICAgLy8gKGdyZWdvcmlhbiBtb250aCBvciBkYXkpICsgb3JkaW5hbCAtPiBlcnJvclxuICAgIC8vIG90aGVyd2lzZSBqdXN0IHVzZSB3ZWVrcyBvciBvcmRpbmFscyBvciBncmVnb3JpYW4sIGRlcGVuZGluZyBvbiB3aGF0J3Mgc3BlY2lmaWVkXG5cbiAgICBpZiAoKGNvbnRhaW5zR3JlZ29yIHx8IGNvbnRhaW5zT3JkaW5hbCkgJiYgZGVmaW5pdGVXZWVrRGVmKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgbWl4IHdlZWtZZWFyL3dlZWtOdW1iZXIgdW5pdHMgd2l0aCB5ZWFyL21vbnRoL2RheSBvciBvcmRpbmFsc1wiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjb250YWluc0dyZWdvck1EICYmIGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFwiQ2FuJ3QgbWl4IG9yZGluYWwgZGF0ZXMgd2l0aCBtb250aC9kYXlcIik7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlV2Vla0RhdGEgPSBkZWZpbml0ZVdlZWtEZWYgfHwgKG5vcm1hbGl6ZWQud2Vla2RheSAmJiAhY29udGFpbnNHcmVnb3IpO1xuXG4gICAgLy8gY29uZmlndXJlIG91cnNlbHZlcyB0byBkZWFsIHdpdGggZ3JlZ29yaWFuIGRhdGVzIG9yIHdlZWsgc3R1ZmZcbiAgICBsZXQgdW5pdHMsXG4gICAgICBkZWZhdWx0VmFsdWVzLFxuICAgICAgb2JqTm93ID0gdHNUb09iaih0c05vdywgb2Zmc2V0UHJvdmlzKTtcbiAgICBpZiAodXNlV2Vla0RhdGEpIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFdlZWtVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0V2Vla1VuaXRWYWx1ZXM7XG4gICAgICBvYmpOb3cgPSBncmVnb3JpYW5Ub1dlZWsob2JqTm93KTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkT3JkaW5hbFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvT3JkaW5hbChvYmpOb3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0VW5pdFZhbHVlcztcbiAgICB9XG5cbiAgICAvLyBzZXQgZGVmYXVsdCB2YWx1ZXMgZm9yIG1pc3Npbmcgc3R1ZmZcbiAgICBsZXQgZm91bmRGaXJzdCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdSBvZiB1bml0cykge1xuICAgICAgY29uc3QgdiA9IG5vcm1hbGl6ZWRbdV07XG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKHYpKSB7XG4gICAgICAgIGZvdW5kRmlyc3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChmb3VuZEZpcnN0KSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbdV0gPSBkZWZhdWx0VmFsdWVzW3VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFsaXplZFt1XSA9IG9iak5vd1t1XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIHZhbHVlcyB3ZSBoYXZlIGFyZSBpbiByYW5nZVxuICAgIGNvbnN0IGhpZ2hlck9yZGVySW52YWxpZCA9IHVzZVdlZWtEYXRhXG4gICAgICAgID8gaGFzSW52YWxpZFdlZWtEYXRhKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogY29udGFpbnNPcmRpbmFsXG4gICAgICAgICAgPyBoYXNJbnZhbGlkT3JkaW5hbERhdGEobm9ybWFsaXplZClcbiAgICAgICAgICA6IGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhKG5vcm1hbGl6ZWQpLFxuICAgICAgaW52YWxpZCA9IGhpZ2hlck9yZGVySW52YWxpZCB8fCBoYXNJbnZhbGlkVGltZURhdGEobm9ybWFsaXplZCk7XG5cbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSB0aGUgYWN0dWFsIHRpbWVcbiAgICBjb25zdCBncmVnb3JpYW4gPSB1c2VXZWVrRGF0YVxuICAgICAgICA/IHdlZWtUb0dyZWdvcmlhbihub3JtYWxpemVkKVxuICAgICAgICA6IGNvbnRhaW5zT3JkaW5hbFxuICAgICAgICAgID8gb3JkaW5hbFRvR3JlZ29yaWFuKG5vcm1hbGl6ZWQpXG4gICAgICAgICAgOiBub3JtYWxpemVkLFxuICAgICAgW3RzRmluYWwsIG9mZnNldEZpbmFsXSA9IG9ialRvVFMoZ3JlZ29yaWFuLCBvZmZzZXRQcm92aXMsIHpvbmVUb1VzZSksXG4gICAgICBpbnN0ID0gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IHRzRmluYWwsXG4gICAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgICAgbzogb2Zmc2V0RmluYWwsXG4gICAgICAgIGxvY1xuICAgICAgfSk7XG5cbiAgICAvLyBncmVnb3JpYW4gZGF0YSArIHdlZWtkYXkgc2VydmVzIG9ubHkgdG8gdmFsaWRhdGVcbiAgICBpZiAobm9ybWFsaXplZC53ZWVrZGF5ICYmIGNvbnRhaW5zR3JlZ29yICYmIG9iai53ZWVrZGF5ICE9PSBpbnN0LndlZWtkYXkpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFxuICAgICAgICBcIm1pc21hdGNoZWQgd2Vla2RheVwiLFxuICAgICAgICBgeW91IGNhbid0IHNwZWNpZnkgYm90aCBhIHdlZWtkYXkgb2YgJHtub3JtYWxpemVkLndlZWtkYXl9IGFuZCBhIGRhdGUgb2YgJHtpbnN0LnRvSVNPKCl9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIElTTyA4NjAxIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBJU08gc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcl0gLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW1dIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMyswNjowMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzKzA2OjAwJywge3NldFpvbmU6IHRydWV9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMycsIHt6b25lOiAndXRjJ30pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtVzA1LTQnKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlSVNPRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIklTTyA4NjAxXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gUkZDIDI4MjIgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIFJGQyAyODIyIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIHRoZSBvZmZzZXQgaXMgYWx3YXlzIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgdGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBzdHJpbmcsIG1lcmVseSB0aGUgem9uZSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGlzIGV4cHJlc3NlZCBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzOjEyIEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCdGcmksIDI1IE5vdiAyMDE2IDEzOjIzOjEyICswNjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzIFonKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tUkZDMjgyMih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZVJGQzI4MjJEYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiUkZDIDI4MjJcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBIVFRQIGhlYWRlciBkYXRlXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMy5odG1sI3NlYzMuMy4xXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIEhUVFAgaGVhZGVyIGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lLiBTaW5jZSBIVFRQIGRhdGVzIGFyZSBhbHdheXMgaW4gVVRDLCB0aGlzIGhhcyBubyBlZmZlY3Qgb24gdGhlIGludGVycHJldGF0aW9uIG9mIHN0cmluZywgbWVyZWx5IHRoZSB6b25lIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaXMgZXhwcmVzc2VkIGluLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCB0aGUgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcuIEZvciBIVFRQIGRhdGVzLCB0aGlzIGlzIGFsd2F5cyBVVEMsIHNvIHRoaXMgb3B0aW9uIGlzIGVxdWl2YWxlbnQgdG8gc2V0dGluZyB0aGUgYHpvbmVgIG9wdGlvbiB0byAndXRjJywgYnV0IHRoaXMgb3B0aW9uIGlzIGluY2x1ZGVkIGZvciBjb25zaXN0ZW5jeSB3aXRoIHNpbWlsYXIgbWV0aG9kcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1biwgMDYgTm92IDE5OTQgMDg6NDk6MzcgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1bmRheSwgMDYtTm92LTk0IDA4OjQ5OjM3IEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW4gTm92ICA2IDA4OjQ5OjM3IDE5OTQnKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSFRUUCh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZUhUVFBEYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSFRUUFwiLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIGlucHV0IHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZy5cbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlLlxuICAgKiBAc2VlIGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi9kb2NzL21hbnVhbC9wYXJzaW5nLmh0bWwjdGFibGUtb2YtdG9rZW5zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWUgdGhlIGxpbmsgYmVsb3cgZm9yIHRoZSBmb3JtYXRzKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIGEgbG9jYWxlIHN0cmluZyB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSBEYXRlVGltZSB0byB0aGlzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgdG8gdGhpcyBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tRm9ybWF0KHRleHQsIGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHRleHQpIHx8IGlzVW5kZWZpbmVkKGZtdCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZyb21Gb3JtYXQgcmVxdWlyZXMgYW4gaW5wdXQgc3RyaW5nIGFuZCBhIGZvcm1hdFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwgfSA9IG9wdHMsXG4gICAgICBsb2NhbGVUb1VzZSA9IExvY2FsZS5mcm9tT3B0cyh7XG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBkZWZhdWx0VG9FTjogdHJ1ZVxuICAgICAgfSksXG4gICAgICBbdmFscywgcGFyc2VkWm9uZSwgaW52YWxpZF0gPSBwYXJzZUZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBgZm9ybWF0ICR7Zm10fWAsIHRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZnJvbUZvcm1hdCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyh0ZXh0LCBmbXQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tRm9ybWF0KHRleHQsIGZtdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIFNRTCBkYXRlLCB0aW1lLCBvciBkYXRldGltZVxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gYSBsb2NhbGUgc3RyaW5nIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIERhdGVUaW1lIHRvIHRoaXMgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIHJlc3VsdGluZyBEYXRlVGltZSB0byB0aGlzIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0JylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDInKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiswNjowMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyIEFtZXJpY2EvTG9zX0FuZ2VsZXMnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiBBbWVyaWNhL0xvc19BbmdlbGVzJywgeyBzZXRab25lOiB0cnVlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyJywgeyB6b25lOiAnQW1lcmljYS9Mb3NfQW5nZWxlcycgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMDk6MTI6MzQuMzQyJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVNRTCh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZVNRTCh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIlNRTFwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgRGF0ZVRpbWUgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBEYXRlVGltZSBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0ZVRpbWVFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhIERhdGVUaW1lLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNEYXRlVGltZShvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkRhdGVUaW1lKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8vIElORk9cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGUnIG9yICdkYXknXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDcsIDQpLmdldCgnbW9udGgnKTsgLy89PiA3XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDcsIDQpLmdldCgnZGF5Jyk7IC8vPT4gNFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW3VuaXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgRGF0ZVRpbWUgaXMgdmFsaWQuIEludmFsaWQgRGF0ZVRpbWVzIG9jY3VyIHdoZW46XG4gICAqICogVGhlIERhdGVUaW1lIHdhcyBjcmVhdGVkIGZyb20gaW52YWxpZCBjYWxlbmRhciBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgMTN0aCBtb250aCBvciBGZWJydWFyeSAzMFxuICAgKiAqIFRoZSBEYXRlVGltZSB3YXMgY3JlYXRlZCBieSBhbiBvcGVyYXRpb24gb24gYW5vdGhlciBpbnZhbGlkIGRhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIERhdGVUaW1lIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEYXRlVGltZSBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRGF0ZVRpbWUgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb2NhbGUgb2YgYSBEYXRlVGltZSwgc3VjaCAnZW4tR0InLiBUaGUgbG9jYWxlIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubG9jYWxlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlcmluZyBzeXN0ZW0gb2YgYSBEYXRlVGltZSwgc3VjaCAnYmVuZycuIFRoZSBudW1iZXJpbmcgc3lzdGVtIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG91dHB1dCBjYWxlbmRhciBvZiBhIERhdGVUaW1lLCBzdWNoICdpc2xhbWljJy4gVGhlIG91dHB1dCBjYWxlbmRhciBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvdXRwdXRDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGltZSB6b25lIGFzc29jaWF0ZWQgd2l0aCB0aGlzIERhdGVUaW1lLlxuICAgKiBAdHlwZSB7Wm9uZX1cbiAgICovXG4gIGdldCB6b25lKCkge1xuICAgIHJldHVybiB0aGlzLl96b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgdGltZSB6b25lLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHpvbmVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnpvbmUubmFtZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS55ZWFyIC8vPT4gMjAxN1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy55ZWFyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVhcnRlclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkucXVhcnRlciAvLz0+IDJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBxdWFydGVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBNYXRoLmNlaWwodGhpcy5jLm1vbnRoIC8gMykgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aCAoMS0xMikuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5tb250aCAvLz0+IDVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1vbnRoIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IG9mIHRoZSBtb250aCAoMS0zMGlzaCkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5kYXkgLy89PiAyNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLmRheSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvdXIgb2YgdGhlIGRheSAoMC0yMykuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5KS5ob3VyIC8vPT4gOVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5ob3VyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludXRlIG9mIHRoZSBob3VyICgwLTU5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwKS5taW51dGUgLy89PiAzMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbnV0ZSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZCBvZiB0aGUgbWludXRlICgwLTU5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwLCA1Mikuc2Vjb25kIC8vPT4gNTJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5zZWNvbmQgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kICgwLTk5OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCwgNTIsIDY1NCkubWlsbGlzZWNvbmQgLy89PiA2NTRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaWxsaXNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbGxpc2Vjb25kIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayB5ZWFyXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAxMiwgMzEpLndlZWtZZWFyIC8vPT4gMjAxNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtZZWFyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayBudW1iZXIgb2YgdGhlIHdlZWsgeWVhciAoMS01MmlzaCkuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkud2Vla051bWJlciAvLz0+IDIxXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrTnVtYmVyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiAxIGlzIE1vbmRheSBhbmQgNyBpcyBTdW5kYXlcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDExLCAzMSkud2Vla2RheSAvLz0+IDRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrZGF5KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtkYXkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmRpbmFsIChtZWFuaW5nIHRoZSBkYXkgb2YgdGhlIHllYXIpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5vcmRpbmFsIC8vPT4gMTQ1XG4gICAqIEB0eXBlIHtudW1iZXJ8RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgb3JkaW5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gZ3JlZ29yaWFuVG9PcmRpbmFsKHRoaXMuYykub3JkaW5hbCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIHNob3J0IG1vbnRoIG5hbWUsIHN1Y2ggYXMgJ09jdCcuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLm1vbnRoU2hvcnQgLy89PiBPY3RcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBtb250aFNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLm1vbnRocyhcInNob3J0XCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgbG9uZyBtb250aCBuYW1lLCBzdWNoIGFzICdPY3RvYmVyJy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkubW9udGhMb25nIC8vPT4gT2N0b2JlclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1vbnRoTG9uZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby5tb250aHMoXCJsb25nXCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgd2Vla2RheSwgc3VjaCBhcyAnTW9uJy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheVNob3J0IC8vPT4gTW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgd2Vla2RheVNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwic2hvcnRcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIGxvbmcgd2Vla2RheSwgc3VjaCBhcyAnTW9uZGF5Jy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheUxvbmcgLy89PiBNb25kYXlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB3ZWVrZGF5TG9uZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby53ZWVrZGF5cyhcImxvbmdcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFVUQyBvZmZzZXQgb2YgdGhpcyBEYXRlVGltZSBpbiBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm9mZnNldCAvLz0+IC0yNDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkub2Zmc2V0IC8vPT4gMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gK3RoaXMubyA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNob3J0IGh1bWFuIG5hbWUgZm9yIHRoZSB6b25lJ3MgY3VycmVudCBvZmZzZXQsIGZvciBleGFtcGxlIFwiRVNUXCIgb3IgXCJFRFRcIi5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb2Zmc2V0TmFtZVNob3J0KCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUub2Zmc2V0TmFtZSh0aGlzLnRzLCB7XG4gICAgICAgIGZvcm1hdDogXCJzaG9ydFwiLFxuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9uZyBodW1hbiBuYW1lIGZvciB0aGUgem9uZSdzIGN1cnJlbnQgb2Zmc2V0LCBmb3IgZXhhbXBsZSBcIkVhc3Rlcm4gU3RhbmRhcmQgVGltZVwiIG9yIFwiRWFzdGVybiBEYXlsaWdodCBUaW1lXCIuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG9mZnNldE5hbWVMb25nKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUub2Zmc2V0TmFtZSh0aGlzLnRzLCB7XG4gICAgICAgIGZvcm1hdDogXCJsb25nXCIsXG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhpcyB6b25lJ3Mgb2Zmc2V0IGV2ZXIgY2hhbmdlcywgYXMgaW4gYSBEU1QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzT2Zmc2V0Rml4ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS51bml2ZXJzYWwgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHRoZSBEYXRlVGltZSBpcyBpbiBhIERTVC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNJbkRTVCgpIHtcbiAgICBpZiAodGhpcy5pc09mZnNldEZpeGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMub2Zmc2V0ID4gdGhpcy5zZXQoeyBtb250aDogMSB9KS5vZmZzZXQgfHwgdGhpcy5vZmZzZXQgPiB0aGlzLnNldCh7IG1vbnRoOiA1IH0pLm9mZnNldFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgRGF0ZVRpbWUgaXMgaW4gYSBsZWFwIHllYXIsIGZhbHNlIG90aGVyd2lzZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5pc0luTGVhcFllYXIgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLmlzSW5MZWFwWWVhciAvLz0+IGZhbHNlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzSW5MZWFwWWVhcigpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyBtb250aFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2LCAyKS5kYXlzSW5Nb250aCAvLz0+IDI5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDMpLmRheXNJbk1vbnRoIC8vPT4gMzFcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzSW5Nb250aCgpIHtcbiAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyLCB0aGlzLm1vbnRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIERhdGVUaW1lJ3MgeWVhclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5kYXlzSW5ZZWFyIC8vPT4gMzY2XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLmRheXNJblllYXIgLy89PiAzNjVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzSW5ZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBkYXlzSW5ZZWFyKHRoaXMueWVhcikgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoaXMgRGF0ZVRpbWUncyB5ZWFyXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDA0KS53ZWVrc0luV2Vla1llYXIgLy89PiA1M1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDEzKS53ZWVrc0luV2Vla1llYXIgLy89PiA1MlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtzSW5XZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gd2Vla3NJbldlZWtZZWFyKHRoaXMud2Vla1llYXIpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdmVkIEludGwgb3B0aW9ucyBmb3IgdGhpcyBEYXRlVGltZS5cbiAgICogVGhpcyBpcyB1c2VmdWwgaW4gdW5kZXJzdGFuZGluZyB0aGUgYmVoYXZpb3Igb2YgZm9ybWF0dGluZyBtZXRob2RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gdGhlIHNhbWUgb3B0aW9ucyBhcyB0b0xvY2FsZVN0cmluZ1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICByZXNvbHZlZExvY2FsZU9wdHMob3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXIgfSA9IEZvcm1hdHRlci5jcmVhdGUoXG4gICAgICB0aGlzLmxvYy5jbG9uZShvcHRzKSxcbiAgICAgIG9wdHNcbiAgICApLnJlc29sdmVkT3B0aW9ucyh0aGlzKTtcbiAgICByZXR1cm4geyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXI6IGNhbGVuZGFyIH07XG4gIH1cblxuICAvLyBUUkFOU0ZPUk1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIFVUQy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBFcXVpdmFsZW50IHRvIHtAbGluayBzZXRab25lfSgndXRjJylcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gLSBvcHRpb25hbGx5LCBhbiBvZmZzZXQgZnJvbSBVVEMgaW4gbWludXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dIC0gb3B0aW9ucyB0byBwYXNzIHRvIGBzZXRab25lKClgXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgdG9VVEMob2Zmc2V0ID0gMCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Wm9uZShGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2Uob2Zmc2V0KSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIHRoZSBob3N0J3MgbG9jYWwgem9uZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBFcXVpdmFsZW50IHRvIGBzZXRab25lKCdsb2NhbCcpYFxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHRvTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Wm9uZShTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIHNwZWNpZmllZCB6b25lLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBzZXR0ZXIga2VlcHMgdGhlIHVuZGVybHlpbmcgdGltZSB0aGUgc2FtZSAoYXMgaW4sIHRoZSBzYW1lIHRpbWVzdGFtcCksIGJ1dCB0aGUgbmV3IGluc3RhbmNlIHdpbGwgcmVwb3J0IGRpZmZlcmVudCBsb2NhbCB0aW1lcyBhbmQgY29uc2lkZXIgRFNUcyB3aGVuIG1ha2luZyBjb21wdXRhdGlvbnMsIGFzIHdpdGgge0BsaW5rIHBsdXN9LiBZb3UgbWF5IHdpc2ggdG8gdXNlIHtAbGluayB0b0xvY2FsfSBhbmQge0BsaW5rIHRvVVRDfSB3aGljaCBwcm92aWRlIHNpbXBsZSBjb252ZW5pZW5jZSB3cmFwcGVycyBmb3IgY29tbW9ubHkgdXNlZCB6b25lcy5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW3pvbmU9J2xvY2FsJ10gLSBhIHpvbmUgaWRlbnRpZmllci4gQXMgYSBzdHJpbmcsIHRoYXQgY2FuIGJlIGFueSBJQU5BIHpvbmUgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IGVudmlyb25tZW50LCBvciBhIGZpeGVkLW9mZnNldCBuYW1lIG9mIHRoZSBmb3JtICdVVEMrMycsIG9yIHRoZSBzdHJpbmdzICdsb2NhbCcgb3IgJ3V0YycuIFlvdSBtYXkgYWxzbyBzdXBwbHkgYW4gaW5zdGFuY2Ugb2YgYSB7QGxpbmsgWm9uZX0gY2xhc3MuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmtlZXBMb2NhbFRpbWU9ZmFsc2VdIC0gSWYgdHJ1ZSwgYWRqdXN0IHRoZSB1bmRlcmx5aW5nIHRpbWUgc28gdGhhdCB0aGUgbG9jYWwgdGltZSBzdGF5cyB0aGUgc2FtZSwgYnV0IGluIHRoZSB0YXJnZXQgem9uZS4gWW91IHNob3VsZCByYXJlbHkgbmVlZCB0aGlzLlxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldFpvbmUoem9uZSwgeyBrZWVwTG9jYWxUaW1lID0gZmFsc2UsIGtlZXBDYWxlbmRhclRpbWUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICB6b25lID0gbm9ybWFsaXplWm9uZSh6b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKHpvbmUuZXF1YWxzKHRoaXMuem9uZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAoIXpvbmUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5ld1RTID0gdGhpcy50cztcbiAgICAgIGlmIChrZWVwTG9jYWxUaW1lIHx8IGtlZXBDYWxlbmRhclRpbWUpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0R3Vlc3MgPSB6b25lLm9mZnNldCh0aGlzLnRzKTtcbiAgICAgICAgY29uc3QgYXNPYmogPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgICAgIFtuZXdUU10gPSBvYmpUb1RTKGFzT2JqLCBvZmZzZXRHdWVzcywgem9uZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmUodGhpcywgeyB0czogbmV3VFMsIHpvbmUgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvciBvdXRwdXRDYWxlbmRhci4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIHRoZSBwcm9wZXJ0aWVzIHRvIHNldFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkucmVjb25maWd1cmUoeyBsb2NhbGU6ICdlbi1HQicgfSlcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICByZWNvbmZpZ3VyZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciB9ID0ge30pIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmxvYy5jbG9uZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciB9KTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyBsb2MgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIEp1c3QgYSBjb252ZW5pZW50IGFsaWFzIGZvciByZWNvbmZpZ3VyZSh7IGxvY2FsZSB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkuc2V0TG9jYWxlKCdlbi1HQicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0TG9jYWxlKGxvY2FsZSkge1xuICAgIHJldHVybiB0aGlzLnJlY29uZmlndXJlKHsgbG9jYWxlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogWW91IGNhbiBvbmx5IHNldCB1bml0cyB3aXRoIHRoaXMgbWV0aG9kOyBmb3IgXCJzZXR0aW5nXCIgbWV0YWRhdGEsIHNlZSB7QGxpbmsgcmVjb25maWd1cmV9IGFuZCB7QGxpbmsgc2V0Wm9uZX0uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSBhIG1hcHBpbmcgb2YgdW5pdHMgdG8gbnVtYmVyc1xuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB5ZWFyOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IGhvdXI6IDgsIG1pbnV0ZTogMzAgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgd2Vla2RheTogNSB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB5ZWFyOiAyMDA1LCBvcmRpbmFsOiAyMzQgfSlcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU9iamVjdCh2YWx1ZXMsIG5vcm1hbGl6ZVVuaXQsIFtdKSxcbiAgICAgIHNldHRpbmdXZWVrU3R1ZmYgPVxuICAgICAgICAhaXNVbmRlZmluZWQobm9ybWFsaXplZC53ZWVrWWVhcikgfHxcbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla051bWJlcikgfHxcbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla2RheSksXG4gICAgICBjb250YWluc09yZGluYWwgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yWWVhciA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLnllYXIpLFxuICAgICAgY29udGFpbnNHcmVnb3JNRCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm1vbnRoKSB8fCAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpLFxuICAgICAgY29udGFpbnNHcmVnb3IgPSBjb250YWluc0dyZWdvclllYXIgfHwgY29udGFpbnNHcmVnb3JNRCxcbiAgICAgIGRlZmluaXRlV2Vla0RlZiA9IG5vcm1hbGl6ZWQud2Vla1llYXIgfHwgbm9ybWFsaXplZC53ZWVrTnVtYmVyO1xuXG4gICAgaWYgKChjb250YWluc0dyZWdvciB8fCBjb250YWluc09yZGluYWwpICYmIGRlZmluaXRlV2Vla0RlZikge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbid0IG1peCB3ZWVrWWVhci93ZWVrTnVtYmVyIHVuaXRzIHdpdGggeWVhci9tb250aC9kYXkgb3Igb3JkaW5hbHNcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbnNHcmVnb3JNRCAmJiBjb250YWluc09yZGluYWwpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcIkNhbid0IG1peCBvcmRpbmFsIGRhdGVzIHdpdGggbW9udGgvZGF5XCIpO1xuICAgIH1cblxuICAgIGxldCBtaXhlZDtcbiAgICBpZiAoc2V0dGluZ1dlZWtTdHVmZikge1xuICAgICAgbWl4ZWQgPSB3ZWVrVG9HcmVnb3JpYW4oT2JqZWN0LmFzc2lnbihncmVnb3JpYW5Ub1dlZWsodGhpcy5jKSwgbm9ybWFsaXplZCkpO1xuICAgIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCkpIHtcbiAgICAgIG1peGVkID0gb3JkaW5hbFRvR3JlZ29yaWFuKE9iamVjdC5hc3NpZ24oZ3JlZ29yaWFuVG9PcmRpbmFsKHRoaXMuYyksIG5vcm1hbGl6ZWQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWl4ZWQgPSBPYmplY3QuYXNzaWduKHRoaXMudG9PYmplY3QoKSwgbm9ybWFsaXplZCk7XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBzZXQgdGhlIGRheSBidXQgd2UgZW5kZWQgdXAgb24gYW4gb3ZlcmZsb3cgZGF0ZSxcbiAgICAgIC8vIHVzZSB0aGUgbGFzdCBkYXkgb2YgdGhlIHJpZ2h0IG1vbnRoXG4gICAgICBpZiAoaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpKSB7XG4gICAgICAgIG1peGVkLmRheSA9IE1hdGgubWluKGRheXNJbk1vbnRoKG1peGVkLnllYXIsIG1peGVkLm1vbnRoKSwgbWl4ZWQuZGF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBbdHMsIG9dID0gb2JqVG9UUyhtaXhlZCwgdGhpcy5vLCB0aGlzLnpvbmUpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHRzLCBvIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqXG4gICAqIEFkZGluZyBob3VycywgbWludXRlcywgc2Vjb25kcywgb3IgbWlsbGlzZWNvbmRzIGluY3JlYXNlcyB0aGUgdGltZXN0YW1wIGJ5IHRoZSByaWdodCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLiBBZGRpbmcgZGF5cywgbW9udGhzLCBvciB5ZWFycyBzaGlmdHMgdGhlIGNhbGVuZGFyLCBhY2NvdW50aW5nIGZvciBEU1RzIGFuZCBsZWFwIHllYXJzIGFsb25nIHRoZSB3YXkuIFRodXMsIGBkdC5wbHVzKHsgaG91cnM6IDI0IH0pYCBtYXkgcmVzdWx0IGluIGEgZGlmZmVyZW50IHRpbWUgdGhhbiBgZHQucGx1cyh7IGRheXM6IDEgfSlgIGlmIHRoZXJlJ3MgYSBEU1Qgc2hpZnQgaW4gYmV0d2Vlbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gYWRkLiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKDEyMykgLy9+PiBpbiAxMjMgbWlsbGlzZWNvbmRzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBtaW51dGVzOiAxNSB9KSAvL34+IGluIDE1IG1pbnV0ZXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkgLy9+PiB0aGlzIHRpbWUgdG9tb3Jyb3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IC0xIH0pIC8vfj4gdGhpcyB0aW1lIHllc3RlcmRheVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgaG91cnM6IDMsIG1pbnV0ZXM6IDEzIH0pIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSkgLy9+PiBpbiAzIGhyLCAxMyBtaW5cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGR1ciA9IGZyaWVuZGx5RHVyYXRpb24oZHVyYXRpb24pO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnRyYWN0IGEgcGVyaW9kIG9mIHRpbWUgdG8gdGhpcyBEYXRlVGltZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVcbiAgICogU2VlIHtAbGluayBwbHVzfVxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBzdWJ0cmFjdC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgIEByZXR1cm4ge0RhdGVUaW1lfVxuICAqL1xuICBtaW51cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBkdXIgPSBmcmllbmRseUR1cmF0aW9uKGR1cmF0aW9uKS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgYWRqdXN0VGltZSh0aGlzLCBkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoaXMgRGF0ZVRpbWUgdG8gdGhlIGJlZ2lubmluZyBvZiBhIHVuaXQgb2YgdGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBUaGUgdW5pdCB0byBnbyB0byB0aGUgYmVnaW5uaW5nIG9mLiBDYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCBvciAnbWlsbGlzZWNvbmQnLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCdtb250aCcpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCd5ZWFyJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3dlZWsnKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMy0wMycsIHdlZWtzIGFsd2F5cyBzdGFydCBvbiBNb25kYXlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdkYXknKS50b0lTT1RpbWUoKTsgLy89PiAnMDA6MDAuMDAwLTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuc3RhcnRPZignaG91cicpLnRvSVNPVGltZSgpOyAvLz0+ICcwNTowMDowMC4wMDAtMDU6MDAnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhcnRPZih1bml0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IG8gPSB7fSxcbiAgICAgIG5vcm1hbGl6ZWRVbml0ID0gRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1bml0KTtcbiAgICBzd2l0Y2ggKG5vcm1hbGl6ZWRVbml0KSB7XG4gICAgICBjYXNlIFwieWVhcnNcIjpcbiAgICAgICAgby5tb250aCA9IDE7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwicXVhcnRlcnNcIjpcbiAgICAgIGNhc2UgXCJtb250aHNcIjpcbiAgICAgICAgby5kYXkgPSAxO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcIndlZWtzXCI6XG4gICAgICBjYXNlIFwiZGF5c1wiOlxuICAgICAgICBvLmhvdXIgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcImhvdXJzXCI6XG4gICAgICAgIG8ubWludXRlID0gMDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJtaW51dGVzXCI6XG4gICAgICAgIG8uc2Vjb25kID0gMDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJzZWNvbmRzXCI6XG4gICAgICAgIG8ubWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWxsaXNlY29uZHNcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBubyBkZWZhdWx0LCBpbnZhbGlkIHVuaXRzIHRocm93IGluIG5vcm1hbGl6ZVVuaXQoKVxuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkVW5pdCA9PT0gXCJ3ZWVrc1wiKSB7XG4gICAgICBvLndlZWtkYXkgPSAxO1xuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkVW5pdCA9PT0gXCJxdWFydGVyc1wiKSB7XG4gICAgICBjb25zdCBxID0gTWF0aC5jZWlsKHRoaXMubW9udGggLyAzKTtcbiAgICAgIG8ubW9udGggPSAocSAtIDEpICogMyArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0KG8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgZW5kIChtZWFuaW5nIHRoZSBsYXN0IG1pbGxpc2Vjb25kKSBvZiBhIHVuaXQgb2YgdGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBlbmQgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCdtb250aCcpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMzFUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZigneWVhcicpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMTItMzFUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZignd2VlaycpLnRvSVNPKCk7IC8vID0+ICcyMDE0LTAzLTA5VDIzOjU5OjU5Ljk5OS0wNTowMCcsIHdlZWtzIHN0YXJ0IG9uIE1vbmRheXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLmVuZE9mKCdkYXknKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTAzVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLmVuZE9mKCdob3VyJykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0wM1QwNTo1OTo1OS45OTktMDU6MDAnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgZW5kT2YodW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gdGhpcy5wbHVzKHsgW3VuaXRdOiAxIH0pXG4gICAgICAgICAgLnN0YXJ0T2YodW5pdClcbiAgICAgICAgICAubWludXMoMSlcbiAgICAgIDogdGhpcztcbiAgfVxuXG4gIC8vIE9VVFBVVFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuXG4gICAqICoqWW91IG1heSBub3Qgd2FudCB0aGlzLioqIFNlZSB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvciBhIG1vcmUgZmxleGlibGUgZm9ybWF0dGluZyB0b29sLiBGb3IgYSB0YWJsZSBvZiB0b2tlbnMgYW5kIHRoZWlyIGludGVycHJldGF0aW9ucywgc2VlIFtoZXJlXShodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vZG9jcy9tYW51YWwvZm9ybWF0dGluZy5odG1sI3RhYmxlLW9mLXRva2VucykuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS5cbiAgICogQHNlZSBodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vZG9jcy9tYW51YWwvZm9ybWF0dGluZy5odG1sI3RhYmxlLW9mLXRva2Vuc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJykgLy89PiAnMjAxNyBBcHIgMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZSgnZnInKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnKSAvLz0+ICcyMDE3IGF2ci4gMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcsIHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiAnMjAxNyBhdnIuIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdChcIkhIICdob3VycyBhbmQnIG1tICdtaW51dGVzJ1wiKSAvLz0+ICcyMCBob3VycyBhbmQgNTUgbWludXRlcydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZm10LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MucmVkZWZhdWx0VG9FTihvcHRzKSkuZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKHRoaXMsIGZtdClcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBkYXRlLiBBY2NlcHRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgdGhlIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3IgYW5kIGFueSBwcmVzZXRzIGRlZmluZWQgYnkgTHV4b24sIHN1Y2ggYXMgYERhdGVUaW1lLkRBVEVfRlVMTGAgb3IgYERhdGVUaW1lLlRJTUVfU0lNUExFYC5cbiAgICogVGhlIGV4YWN0IGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kIGlzIGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBpbiBnZW5lcmFsIGl0IHdpbGwgcmV0dXJuIGFuIGFwcHJvcHJpYXRlIHJlcHJlc2VudGF0aW9uXG4gICAqIG9mIHRoZSBEYXRlVGltZSBpbiB0aGUgYXNzaWduZWQgbG9jYWxlLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0gb3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucyBhbmQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gNC8yMC8yMDE3XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZSgnZW4tZ2InKS50b0xvY2FsZVN0cmluZygpOyAvLz0+ICcyMC8wNC8yMDE3J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IGxvY2FsZTogJ2VuLWdiJyB9KTsgLy89PiAnMjAvMDQvMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMKTsgLy89PiAnQXByaWwgMjAsIDIwMTcnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKTsgLy89PiAnMTE6MzIgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVUSU1FX1NIT1JUKTsgLy89PiAnNC8yMC8yMDE3LCAxMTozMiBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnbG9uZycsIG1vbnRoOiAnbG9uZycsIGRheTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHVyc2RheSwgQXByaWwgMjAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdzaG9ydCcsIGRheTogJzItZGlnaXQnLCBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHUsIEFwciAyMCwgMTE6MjcgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JywgaG91cjEyOiBmYWxzZSB9KTsgLy89PiAnMTE6MzInXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvTG9jYWxlU3RyaW5nKG9wdHMgPSBGb3JtYXRzLkRBVEVfU0hPUlQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MuY2xvbmUob3B0cyksIG9wdHMpLmZvcm1hdERhdGVUaW1lKHRoaXMpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBmb3JtYXQgXCJwYXJ0c1wiLCBtZWFuaW5nIGluZGl2aWR1YWwgdG9rZW5zIGFsb25nIHdpdGggbWV0YWRhdGEuIFRoaXMgaXMgYWxsb3dzIGNhbGxlcnMgdG8gcG9zdC1wcm9jZXNzIGluZGl2aWR1YWwgc2VjdGlvbnMgb2YgdGhlIGZvcm1hdHRlZCBvdXRwdXQuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0L2Zvcm1hdFRvUGFydHNcbiAgICogQHBhcmFtIG9wdHMge09iamVjdH0gLSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMsIHNhbWUgYXMgYHRvTG9jYWxlU3RyaW5nYC5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVQYXJ0cygpOyAvLz0+IFtcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdkYXknLCB2YWx1ZTogJzI1JyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy8nIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbW9udGgnLCB2YWx1ZTogJzA1JyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy8nIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAneWVhcicsIHZhbHVlOiAnMTk4MicgfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiBdXG4gICAqL1xuICB0b0xvY2FsZVBhcnRzKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5jbG9uZShvcHRzKSwgb3B0cykuZm9ybWF0RGF0ZVRpbWVQYXJ0cyh0aGlzKVxuICAgICAgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU08oKSAvLz0+ICcxOTgyLTA1LTI1VDAwOjAwOjAwLjAwMFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzIwMTcwNDIyVDIwNDcwNS4zMzUtMDQwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08ob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBgJHt0aGlzLnRvSVNPRGF0ZShvcHRzKX1UJHt0aGlzLnRvSVNPVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3MgZGF0ZSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09EYXRlKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzE5ODIwNTI1J1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT0RhdGUoeyBmb3JtYXQgPSBcImV4dGVuZGVkXCIgfSA9IHt9KSB7XG4gICAgbGV0IGZtdCA9IGZvcm1hdCA9PT0gXCJiYXNpY1wiID8gXCJ5eXl5TU1kZFwiIDogXCJ5eXl5LU1NLWRkXCI7XG4gICAgaWYgKHRoaXMueWVhciA+IDk5OTkpIHtcbiAgICAgIGZtdCA9IFwiK1wiICsgZm10O1xuICAgIH1cblxuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgZm10KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHdlZWsgZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPV2Vla0RhdGUoKSAvLz0+ICcxOTgyLVcyMS0yJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1dlZWtEYXRlKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJra2trLSdXJ1dXLWNcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyB0aW1lIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlUHJlZml4PWZhbHNlXSAtIGluY2x1ZGUgdGhlIGBUYCBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKCkgLy89PiAnMDc6MzQ6MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCwgc2Vjb25kczogMCwgbWlsbGlzZWNvbmRzOiAwIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzU2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcwNzozNFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzA3MzQxOS4zNjFaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSh7IGluY2x1ZGVQcmVmaXg6IHRydWUgfSkgLy89PiAnVDA3OjM0OjE5LjM2MVonXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZSh7XG4gICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBmYWxzZSxcbiAgICBzdXBwcmVzc1NlY29uZHMgPSBmYWxzZSxcbiAgICBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSxcbiAgICBpbmNsdWRlUHJlZml4ID0gZmFsc2UsXG4gICAgZm9ybWF0ID0gXCJleHRlbmRlZFwiXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiB0b1RlY2hUaW1lRm9ybWF0KHRoaXMsIHtcbiAgICAgIHN1cHByZXNzU2Vjb25kcyxcbiAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICAgICAgaW5jbHVkZU9mZnNldCxcbiAgICAgIGluY2x1ZGVQcmVmaXgsXG4gICAgICBmb3JtYXRcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFJGQyAyODIyLWNvbXBhdGlibGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUsIGFsd2F5cyBpbiBVVENcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwICswMDAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9SRkMyODIyKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCAtMDQwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9SRkMyODIyKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJFRUUsIGRkIExMTCB5eXl5IEhIOm1tOnNzIFpaWlwiLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSFRUUCBoZWFkZXJzLlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZSBzdHJpbmcgY29uZm9ybXMgdG8gUkZDIDExMjMuXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMy5odG1sI3NlYzMuMy4xXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCBHTVQnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMywgMTkpLnRvSFRUUCgpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMTk6MDA6MDAgR01UJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0hUVFAoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLnRvVVRDKCksIFwiRUVFLCBkZCBMTEwgeXl5eSBISDptbTpzcyAnR01UJ1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvU1FMRGF0ZSgpIC8vPT4gJzIwMTQtMDctMTMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMRGF0ZSgpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMsIFwieXl5eS1NTS1kZFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKCkgLy89PiAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSB9KSAvLz0+ICcwNToxNToxNi4zNDUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKHsgaW5jbHVkZVpvbmU6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSBBbWVyaWNhL05ld19Zb3JrJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1NRTFRpbWUoeyBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSwgaW5jbHVkZVpvbmUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICByZXR1cm4gdG9UZWNoVGltZUZvcm1hdCh0aGlzLCB7XG4gICAgICBpbmNsdWRlT2Zmc2V0LFxuICAgICAgaW5jbHVkZVpvbmUsXG4gICAgICBzcGFjZVpvbmU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVpvbmU9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgem9uZSwgc3VjaCBhcyAnQW1lcmljYS9OZXdfWW9yaycuIE92ZXJyaWRlcyBpbmNsdWRlT2Zmc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9TUUwoKSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCBaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoKSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoeyBpbmNsdWRlWm9uZTogdHJ1ZSB9KSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCBBbWVyaWNhL05ld19Zb3JrJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1NRTChvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3RoaXMudG9TUUxEYXRlKCl9ICR7dGhpcy50b1NRTFRpbWUob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIGRlYnVnZ2luZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50b0lTTygpIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS4gQWxpYXMgb2Yge0BsaW5rIHRvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggbWlsbGlzZWNvbmRzIG9mIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvTWlsbGlzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIHNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9TZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIC8gMTAwMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBKU09OLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgQlNPTiBzZXJpYWxpemFibGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgdG9CU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNEYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhpcyBEYXRlVGltZSdzIHllYXIsIG1vbnRoLCBkYXksIGFuZCBzbyBvbi5cbiAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIGZvciBnZW5lcmF0aW5nIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlQ29uZmlnPWZhbHNlXSAtIGluY2x1ZGUgY29uZmlndXJhdGlvbiBhdHRyaWJ1dGVzIGluIHRoZSBvdXRwdXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9PYmplY3QoKSAvLz0+IHsgeWVhcjogMjAxNywgbW9udGg6IDQsIGRheTogMjIsIGhvdXI6IDIwLCBtaW51dGU6IDQ5LCBzZWNvbmQ6IDQyLCBtaWxsaXNlY29uZDogMjY4IH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9PYmplY3Qob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB7fTtcblxuICAgIGNvbnN0IGJhc2UgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmMpO1xuXG4gICAgaWYgKG9wdHMuaW5jbHVkZUNvbmZpZykge1xuICAgICAgYmFzZS5vdXRwdXRDYWxlbmRhciA9IHRoaXMub3V0cHV0Q2FsZW5kYXI7XG4gICAgICBiYXNlLm51bWJlcmluZ1N5c3RlbSA9IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbTtcbiAgICAgIGJhc2UubG9jYWxlID0gdGhpcy5sb2MubG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBEYXRlIGVxdWl2YWxlbnQgdG8gdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICovXG4gIHRvSlNEYXRlKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOKTtcbiAgfVxuXG4gIC8vIENPTVBBUkVcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIERhdGVUaW1lcyBhcyBhIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIERhdGVUaW1lIHRvIGNvbXBhcmUgdGhpcyBvbmUgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgYXJyYXkgb2YgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGkxID0gRGF0ZVRpbWUuZnJvbUlTTygnMTk4Mi0wNS0yNVQwOTo0NScpLFxuICAgKiAgICAgaTIgPSBEYXRlVGltZS5mcm9tSVNPKCcxOTgzLTEwLTE0VDEwOjMwJyk7XG4gICAqIGkyLmRpZmYoaTEpLnRvT2JqZWN0KCkgLy89PiB7IG1pbGxpc2Vjb25kczogNDM4MDc1MDAwMDAgfVxuICAgKiBpMi5kaWZmKGkxLCAnaG91cnMnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTIxNjguNzUgfVxuICAgKiBpMi5kaWZmKGkxLCBbJ21vbnRocycsICdkYXlzJ10pLnRvT2JqZWN0KCkgLy89PiB7IG1vbnRoczogMTYsIGRheXM6IDE5LjAzMTI1IH1cbiAgICogaTIuZGlmZihpMSwgWydtb250aHMnLCAnZGF5cycsICdob3VycyddKS50b09iamVjdCgpIC8vPT4geyBtb250aHM6IDE2LCBkYXlzOiAxOSwgaG91cnM6IDAuNzUgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIGRpZmYob3RoZXJEYXRlVGltZSwgdW5pdCA9IFwibWlsbGlzZWNvbmRzXCIsIG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlckRhdGVUaW1lLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFxuICAgICAgICB0aGlzLmludmFsaWQgfHwgb3RoZXJEYXRlVGltZS5pbnZhbGlkLFxuICAgICAgICBcImNyZWF0ZWQgYnkgZGlmZmluZyBhbiBpbnZhbGlkIERhdGVUaW1lXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZHVyT3B0cyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7IGxvY2FsZTogdGhpcy5sb2NhbGUsIG51bWJlcmluZ1N5c3RlbTogdGhpcy5udW1iZXJpbmdTeXN0ZW0gfSxcbiAgICAgIG9wdHNcbiAgICApO1xuXG4gICAgY29uc3QgdW5pdHMgPSBtYXliZUFycmF5KHVuaXQpLm1hcChEdXJhdGlvbi5ub3JtYWxpemVVbml0KSxcbiAgICAgIG90aGVySXNMYXRlciA9IG90aGVyRGF0ZVRpbWUudmFsdWVPZigpID4gdGhpcy52YWx1ZU9mKCksXG4gICAgICBlYXJsaWVyID0gb3RoZXJJc0xhdGVyID8gdGhpcyA6IG90aGVyRGF0ZVRpbWUsXG4gICAgICBsYXRlciA9IG90aGVySXNMYXRlciA/IG90aGVyRGF0ZVRpbWUgOiB0aGlzLFxuICAgICAgZGlmZmVkID0gZGlmZihlYXJsaWVyLCBsYXRlciwgdW5pdHMsIGR1ck9wdHMpO1xuXG4gICAgcmV0dXJuIG90aGVySXNMYXRlciA/IGRpZmZlZC5uZWdhdGUoKSA6IGRpZmZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCByaWdodCBub3cuXG4gICAqIFNlZSB7QGxpbmsgZGlmZn1cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIGRpZmZOb3codW5pdCA9IFwibWlsbGlzZWNvbmRzXCIsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmRpZmYoRGF0ZVRpbWUubm93KCksIHVuaXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCBzcGFubmluZyBiZXR3ZWVuIHRoaXMgRGF0ZVRpbWUgYW5kIGFub3RoZXIgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBvdGhlciBlbmQgcG9pbnQgb2YgdGhlIEludGVydmFsXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW50aWwob3RoZXJEYXRlVGltZSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHRoaXMsIG90aGVyRGF0ZVRpbWUpIDogdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIERhdGVUaW1lIGlzIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZSBhcyBhbm90aGVyIERhdGVUaW1lLlxuICAgKiBIaWdoZXItb3JkZXIgdW5pdHMgbXVzdCBhbHNvIGJlIGlkZW50aWNhbCBmb3IgdGhpcyBmdW5jdGlvbiB0byByZXR1cm4gYHRydWVgLlxuICAgKiBOb3RlIHRoYXQgdGltZSB6b25lcyBhcmUgKippZ25vcmVkKiogaW4gdGhpcyBjb21wYXJpc29uLCB3aGljaCBjb21wYXJlcyB0aGUgKipsb2NhbCoqIGNhbGVuZGFyIHRpbWUuIFVzZSB7QGxpbmsgc2V0Wm9uZX0gdG8gY29udmVydCBvbmUgb2YgdGhlIGRhdGVzIGlmIG5lZWRlZC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBvdGhlciBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY2hlY2sgc2FtZW5lc3Mgb25cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuaGFzU2FtZShvdGhlckRULCAnZGF5Jyk7IC8vfj4gdHJ1ZSBpZiBvdGhlckRUIGlzIGluIHRoZSBzYW1lIGN1cnJlbnQgY2FsZW5kYXIgZGF5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNTYW1lKG90aGVyRGF0ZVRpbWUsIHVuaXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgaW5wdXRNcyA9IG90aGVyRGF0ZVRpbWUudmFsdWVPZigpO1xuICAgIGNvbnN0IG90aGVyWm9uZURhdGVUaW1lID0gdGhpcy5zZXRab25lKG90aGVyRGF0ZVRpbWUuem9uZSwgeyBrZWVwTG9jYWxUaW1lOiB0cnVlIH0pO1xuICAgIHJldHVybiBvdGhlclpvbmVEYXRlVGltZS5zdGFydE9mKHVuaXQpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSBvdGhlclpvbmVEYXRlVGltZS5lbmRPZih1bml0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcXVhbGl0eSBjaGVja1xuICAgKiBUd28gRGF0ZVRpbWVzIGFyZSBlcXVhbCBpZmYgdGhleSByZXByZXNlbnQgdGhlIHNhbWUgbWlsbGlzZWNvbmQsIGhhdmUgdGhlIHNhbWUgem9uZSBhbmQgbG9jYXRpb24sIGFuZCBhcmUgYm90aCB2YWxpZC5cbiAgICogVG8gY29tcGFyZSBqdXN0IHRoZSBtaWxsaXNlY29uZCB2YWx1ZXMsIHVzZSBgK2R0MSA9PT0gK2R0MmAuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyIC0gdGhlIG90aGVyIERhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5pc1ZhbGlkICYmXG4gICAgICBvdGhlci5pc1ZhbGlkICYmXG4gICAgICB0aGlzLnZhbHVlT2YoKSA9PT0gb3RoZXIudmFsdWVPZigpICYmXG4gICAgICB0aGlzLnpvbmUuZXF1YWxzKG90aGVyLnpvbmUpICYmXG4gICAgICB0aGlzLmxvYy5lcXVhbHMob3RoZXIubG9jKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHRoaXMgdGltZSByZWxhdGl2ZSB0byBub3csIHN1Y2ggYXMgXCJpbiB0d28gZGF5c1wiLiBDYW4gb25seSBpbnRlcm5hdGlvbmFsaXplIGlmIHlvdXJcbiAgICogcGxhdGZvcm0gc3VwcG9ydHMgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQuIFJvdW5kcyBkb3duIGJ5IGRlZmF1bHQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgb3V0cHV0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IFtvcHRpb25zLmJhc2U9RGF0ZVRpbWUubm93KCldIC0gdGhlIERhdGVUaW1lIHRvIHVzZSBhcyB0aGUgYmFzaXMgdG8gd2hpY2ggdGhpcyB0aW1lIGlzIGNvbXBhcmVkLiBEZWZhdWx0cyB0byBub3cuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zdHlsZT1cImxvbmdcIl0gLSB0aGUgc3R5bGUgb2YgdW5pdHMsIG11c3QgYmUgXCJsb25nXCIsIFwic2hvcnRcIiwgb3IgXCJuYXJyb3dcIlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gb3B0aW9ucy51bml0IC0gdXNlIGEgc3BlY2lmaWMgdW5pdCBvciBhcnJheSBvZiB1bml0czsgaWYgb21pdHRlZCwgb3IgYW4gYXJyYXksIHRoZSBtZXRob2Qgd2lsbCBwaWNrIHRoZSBiZXN0IHVuaXQuIFVzZSBhbiBhcnJheSBvciBvbmUgb2YgXCJ5ZWFyc1wiLCBcInF1YXJ0ZXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIG9yIFwic2Vjb25kc1wiXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucm91bmQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIHJvdW5kIHRoZSBudW1iZXJzIGluIHRoZSBvdXRwdXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wYWRkaW5nPTBdIC0gcGFkZGluZyBpbiBtaWxsaXNlY29uZHMuIFRoaXMgYWxsb3dzIHlvdSB0byByb3VuZCB1cCB0aGUgcmVzdWx0IGlmIGl0IGZpdHMgaW5zaWRlIHRoZSB0aHJlc2hvbGQuIERvbid0IHVzZSBpbiBjb21iaW5hdGlvbiB3aXRoIHtyb3VuZDogZmFsc2V9IGJlY2F1c2UgdGhlIGRlY2ltYWwgb3V0cHV0IHdpbGwgaW5jbHVkZSB0aGUgcGFkZGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxlIC0gb3ZlcnJpZGUgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIG92ZXJyaWRlIHRoZSBudW1iZXJpbmdTeXN0ZW0gb2YgdGhpcyBEYXRlVGltZS4gVGhlIEludGwgc3lzdGVtIG1heSBjaG9vc2Ugbm90IHRvIGhvbm9yIHRoaXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCJpbiAxIGRheVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZShcImVzXCIpLnRvUmVsYXRpdmUoeyBkYXlzOiAxIH0pIC8vPT4gXCJkZW50cm8gZGUgMSBkw61hXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSh7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkYW5zIDIzIGhldXJlc1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSh7IHVuaXQ6IFwiaG91cnNcIiB9KSAvLz0+IFwiNDggaG91cnMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBob3VyczogMzYgfSkudG9SZWxhdGl2ZSh7IHJvdW5kOiBmYWxzZSB9KSAvLz0+IFwiMS41IGRheXMgYWdvXCJcbiAgICovXG4gIHRvUmVsYXRpdmUob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHpvbmU6IHRoaXMuem9uZSB9KSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcgPyAodGhpcyA8IGJhc2UgPyAtb3B0aW9ucy5wYWRkaW5nIDogb3B0aW9ucy5wYWRkaW5nKSA6IDA7XG4gICAgbGV0IHVuaXRzID0gW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiXTtcbiAgICBsZXQgdW5pdCA9IG9wdGlvbnMudW5pdDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnVuaXQpKSB7XG4gICAgICB1bml0cyA9IG9wdGlvbnMudW5pdDtcbiAgICAgIHVuaXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBkaWZmUmVsYXRpdmUoXG4gICAgICBiYXNlLFxuICAgICAgdGhpcy5wbHVzKHBhZGRpbmcpLFxuICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG4gICAgICAgIG51bWVyaWM6IFwiYWx3YXlzXCIsXG4gICAgICAgIHVuaXRzLFxuICAgICAgICB1bml0XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGRhdGUgcmVsYXRpdmUgdG8gdG9kYXksIHN1Y2ggYXMgXCJ5ZXN0ZXJkYXlcIiBvciBcIm5leHQgbW9udGhcIi5cbiAgICogT25seSBpbnRlcm5hdGlvbmFsaXplcyBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxlIC0gb3ZlcnJpZGUgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0OyBpZiBvbWl0dGVkLCB0aGUgbWV0aG9kIHdpbGwgcGljayB0aGUgdW5pdC4gVXNlIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBvciBcImRheXNcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSBvdmVycmlkZSB0aGUgbnVtYmVyaW5nU3lzdGVtIG9mIHRoaXMgRGF0ZVRpbWUuIFRoZSBJbnRsIHN5c3RlbSBtYXkgY2hvb3NlIG5vdCB0byBob25vciB0aGlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcigpIC8vPT4gXCJ0b21vcnJvd1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZShcImVzXCIpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiXCJtYcOxYW5hXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiBcImRlbWFpblwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoKSAvLz0+IFwiMiBkYXlzIGFnb1wiXG4gICAqL1xuICB0b1JlbGF0aXZlQ2FsZW5kYXIob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIGRpZmZSZWxhdGl2ZShcbiAgICAgIG9wdGlvbnMuYmFzZSB8fCBEYXRlVGltZS5mcm9tT2JqZWN0KHsgem9uZTogdGhpcy56b25lIH0pLFxuICAgICAgdGhpcyxcbiAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuICAgICAgICBudW1lcmljOiBcImF1dG9cIixcbiAgICAgICAgdW5pdHM6IFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwiZGF5c1wiXSxcbiAgICAgICAgY2FsZW5kYXJ5OiB0cnVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtaW4gb2Ygc2V2ZXJhbCBkYXRlIHRpbWVzXG4gICAqIEBwYXJhbSB7Li4uRGF0ZVRpbWV9IGRhdGVUaW1lcyAtIHRoZSBEYXRlVGltZXMgZnJvbSB3aGljaCB0byBjaG9vc2UgdGhlIG1pbmltdW1cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9IHRoZSBtaW4gRGF0ZVRpbWUsIG9yIHVuZGVmaW5lZCBpZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudFxuICAgKi9cbiAgc3RhdGljIG1pbiguLi5kYXRlVGltZXMpIHtcbiAgICBpZiAoIWRhdGVUaW1lcy5ldmVyeShEYXRlVGltZS5pc0RhdGVUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWluIHJlcXVpcmVzIGFsbCBhcmd1bWVudHMgYmUgRGF0ZVRpbWVzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdEJ5KGRhdGVUaW1lcywgaSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5taW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4IG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtYXhpbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWF4IERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtYXgoLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1heCByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIGkgPT4gaS52YWx1ZU9mKCksIE1hdGgubWF4KTtcbiAgfVxuXG4gIC8vIE1JU0NcblxuICAvKipcbiAgICogRXhwbGFpbiBob3cgYSBzdHJpbmcgd291bGQgYmUgcGFyc2VkIGJ5IGZyb21Gb3JtYXQoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIGRlc2NyaXB0aW9uKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGFrZW4gYnkgZnJvbUZvcm1hdCgpXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRm9ybWF0RXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCB9ID0gb3B0aW9ucyxcbiAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGRlZmF1bHRUb0VOOiB0cnVlXG4gICAgICB9KTtcbiAgICByZXR1cm4gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXRFeHBsYWluIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nRXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tRm9ybWF0RXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gRk9STUFUIFBSRVNFVFNcblxuICAvKipcbiAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAxMC8xNC8xOTgzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfU0hPUlQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfTUVEKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfTUVEO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaSwgT2N0IDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfRlVMTCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnVHVlc2RheSwgT2N0b2JlciAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfSFVHRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1NJTVBMRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1NJTVBMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX1NIT1JUX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfTE9OR19PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfU0lNUExFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVEVCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRWFzdGVybiBEYXlsaWdodCBUaW1lJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9TSE9SVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcxMC8xNC8xOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRUQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIDE0IE9jdCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9GVUxMKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0hVR0U7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwOjMzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUztcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmllbmRseURhdGVUaW1lKGRhdGVUaW1laXNoKSB7XG4gIGlmIChEYXRlVGltZS5pc0RhdGVUaW1lKGRhdGVUaW1laXNoKSkge1xuICAgIHJldHVybiBkYXRlVGltZWlzaDtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiBkYXRlVGltZWlzaC52YWx1ZU9mICYmIGlzTnVtYmVyKGRhdGVUaW1laXNoLnZhbHVlT2YoKSkpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUpTRGF0ZShkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSBpZiAoZGF0ZVRpbWVpc2ggJiYgdHlwZW9mIGRhdGVUaW1laXNoID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21PYmplY3QoZGF0ZVRpbWVpc2gpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgIGBVbmtub3duIGRhdGV0aW1lIGFyZ3VtZW50OiAke2RhdGVUaW1laXNofSwgb2YgdHlwZSAke3R5cGVvZiBkYXRlVGltZWlzaH1gXG4gICAgKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkR1cmF0aW9uIiwiZnJpZW5kbHlEdXJhdGlvbiIsIkludGVydmFsIiwiU2V0dGluZ3MiLCJJbmZvIiwiRm9ybWF0dGVyIiwiRml4ZWRPZmZzZXRab25lIiwiTG9jYWxlIiwiaXNVbmRlZmluZWQiLCJtYXliZUFycmF5IiwiaXNEYXRlIiwiaXNOdW1iZXIiLCJiZXN0QnkiLCJkYXlzSW5Nb250aCIsImRheXNJblllYXIiLCJpc0xlYXBZZWFyIiwid2Vla3NJbldlZWtZZWFyIiwibm9ybWFsaXplT2JqZWN0Iiwicm91bmRUbyIsIm9ialRvTG9jYWxUUyIsIm5vcm1hbGl6ZVpvbmUiLCJkaWZmIiwicGFyc2VSRkMyODIyRGF0ZSIsInBhcnNlSVNPRGF0ZSIsInBhcnNlSFRUUERhdGUiLCJwYXJzZVNRTCIsInBhcnNlRnJvbVRva2VucyIsImV4cGxhaW5Gcm9tVG9rZW5zIiwiZ3JlZ29yaWFuVG9XZWVrIiwid2Vla1RvR3JlZ29yaWFuIiwiZ3JlZ29yaWFuVG9PcmRpbmFsIiwib3JkaW5hbFRvR3JlZ29yaWFuIiwiaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEiLCJoYXNJbnZhbGlkV2Vla0RhdGEiLCJoYXNJbnZhbGlkT3JkaW5hbERhdGEiLCJoYXNJbnZhbGlkVGltZURhdGEiLCJGb3JtYXRzIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciIsIkludmFsaWRVbml0RXJyb3IiLCJJbnZhbGlkRGF0ZVRpbWVFcnJvciIsIkludmFsaWQiLCJJTlZBTElEIiwiTUFYX0RBVEUiLCJ1bnN1cHBvcnRlZFpvbmUiLCJ6b25lIiwibmFtZSIsInBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEiLCJkdCIsIndlZWtEYXRhIiwiYyIsImNsb25lIiwiaW5zdCIsImFsdHMiLCJjdXJyZW50IiwidHMiLCJvIiwibG9jIiwiaW52YWxpZCIsIkRhdGVUaW1lIiwiT2JqZWN0IiwiYXNzaWduIiwib2xkIiwiZml4T2Zmc2V0IiwibG9jYWxUUyIsInR6IiwidXRjR3Vlc3MiLCJvMiIsIm9mZnNldCIsIm8zIiwiTWF0aCIsIm1pbiIsIm1heCIsInRzVG9PYmoiLCJkIiwiRGF0ZSIsInllYXIiLCJnZXRVVENGdWxsWWVhciIsIm1vbnRoIiwiZ2V0VVRDTW9udGgiLCJkYXkiLCJnZXRVVENEYXRlIiwiaG91ciIsImdldFVUQ0hvdXJzIiwibWludXRlIiwiZ2V0VVRDTWludXRlcyIsInNlY29uZCIsImdldFVUQ1NlY29uZHMiLCJtaWxsaXNlY29uZCIsImdldFVUQ01pbGxpc2Vjb25kcyIsIm9ialRvVFMiLCJvYmoiLCJhZGp1c3RUaW1lIiwiZHVyIiwib1ByZSIsInRydW5jIiwieWVhcnMiLCJtb250aHMiLCJxdWFydGVycyIsImRheXMiLCJ3ZWVrcyIsIm1pbGxpc1RvQWRkIiwiZnJvbU9iamVjdCIsImhvdXJzIiwibWludXRlcyIsInNlY29uZHMiLCJtaWxsaXNlY29uZHMiLCJhcyIsInBhcnNlRGF0YVRvRGF0ZVRpbWUiLCJwYXJzZWQiLCJwYXJzZWRab25lIiwib3B0cyIsImZvcm1hdCIsInRleHQiLCJzZXRab25lIiwia2V5cyIsImxlbmd0aCIsImludGVycHJldGF0aW9uWm9uZSIsInVuZGVmaW5lZCIsInRvVGVjaEZvcm1hdCIsImFsbG93WiIsImlzVmFsaWQiLCJjcmVhdGUiLCJmb3JjZVNpbXBsZSIsImZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyIsInRvVGVjaFRpbWVGb3JtYXQiLCJzdXBwcmVzc1NlY29uZHMiLCJzdXBwcmVzc01pbGxpc2Vjb25kcyIsImluY2x1ZGVPZmZzZXQiLCJpbmNsdWRlUHJlZml4IiwiaW5jbHVkZVpvbmUiLCJzcGFjZVpvbmUiLCJmbXQiLCJzdHIiLCJkZWZhdWx0VW5pdFZhbHVlcyIsImRlZmF1bHRXZWVrVW5pdFZhbHVlcyIsIndlZWtOdW1iZXIiLCJ3ZWVrZGF5IiwiZGVmYXVsdE9yZGluYWxVbml0VmFsdWVzIiwib3JkaW5hbCIsIm9yZGVyZWRVbml0cyIsIm9yZGVyZWRXZWVrVW5pdHMiLCJvcmRlcmVkT3JkaW5hbFVuaXRzIiwibm9ybWFsaXplVW5pdCIsInVuaXQiLCJub3JtYWxpemVkIiwicXVhcnRlciIsIndlZWtkYXlzIiwid2Vla251bWJlciIsIndlZWtzbnVtYmVyIiwid2Vla251bWJlcnMiLCJ3ZWVreWVhciIsIndlZWt5ZWFycyIsInRvTG93ZXJDYXNlIiwicXVpY2tEVCIsInUiLCJ0c05vdyIsIm5vdyIsIm9mZnNldFByb3ZpcyIsImRpZmZSZWxhdGl2ZSIsInN0YXJ0IiwiZW5kIiwicm91bmQiLCJjYWxlbmRhcnkiLCJmb3JtYXR0ZXIiLCJyZWxGb3JtYXR0ZXIiLCJkaWZmZXIiLCJoYXNTYW1lIiwic3RhcnRPZiIsImdldCIsInVuaXRzIiwiY291bnQiLCJhYnMiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImRlZmF1bHRab25lIiwiTnVtYmVyIiwiaXNOYU4iLCJ1bmNoYW5nZWQiLCJlcXVhbHMiLCJvdCIsIl96b25lIiwiaXNMdXhvbkRhdGVUaW1lIiwibG9jYWwiLCJ1dGMiLCJ1dGNJbnN0YW5jZSIsImZyb21KU0RhdGUiLCJkYXRlIiwib3B0aW9ucyIsInZhbHVlT2YiLCJOYU4iLCJ6b25lVG9Vc2UiLCJmcm9tTWlsbGlzIiwiZnJvbVNlY29uZHMiLCJjb250YWluc09yZGluYWwiLCJjb250YWluc0dyZWdvclllYXIiLCJjb250YWluc0dyZWdvck1EIiwiY29udGFpbnNHcmVnb3IiLCJkZWZpbml0ZVdlZWtEZWYiLCJ3ZWVrWWVhciIsInVzZVdlZWtEYXRhIiwiZGVmYXVsdFZhbHVlcyIsIm9iak5vdyIsImZvdW5kRmlyc3QiLCJ2IiwiaGlnaGVyT3JkZXJJbnZhbGlkIiwiZ3JlZ29yaWFuIiwidHNGaW5hbCIsIm9mZnNldEZpbmFsIiwidG9JU08iLCJmcm9tSVNPIiwidmFscyIsImZyb21SRkMyODIyIiwiZnJvbUhUVFAiLCJmcm9tRm9ybWF0IiwibG9jYWxlIiwibnVtYmVyaW5nU3lzdGVtIiwibG9jYWxlVG9Vc2UiLCJmcm9tT3B0cyIsImRlZmF1bHRUb0VOIiwiZnJvbVN0cmluZyIsImZyb21TUUwiLCJyZWFzb24iLCJleHBsYW5hdGlvbiIsInRocm93T25JbnZhbGlkIiwiaXNEYXRlVGltZSIsImludmFsaWRSZWFzb24iLCJpbnZhbGlkRXhwbGFuYXRpb24iLCJvdXRwdXRDYWxlbmRhciIsInpvbmVOYW1lIiwiY2VpbCIsIm1vbnRoU2hvcnQiLCJsb2NPYmoiLCJtb250aExvbmciLCJ3ZWVrZGF5U2hvcnQiLCJ3ZWVrZGF5TG9uZyIsIm9mZnNldE5hbWVTaG9ydCIsIm9mZnNldE5hbWUiLCJvZmZzZXROYW1lTG9uZyIsImlzT2Zmc2V0Rml4ZWQiLCJ1bml2ZXJzYWwiLCJpc0luRFNUIiwic2V0IiwiaXNJbkxlYXBZZWFyIiwicmVzb2x2ZWRMb2NhbGVPcHRzIiwiY2FsZW5kYXIiLCJyZXNvbHZlZE9wdGlvbnMiLCJ0b1VUQyIsImluc3RhbmNlIiwidG9Mb2NhbCIsImtlZXBMb2NhbFRpbWUiLCJrZWVwQ2FsZW5kYXJUaW1lIiwibmV3VFMiLCJvZmZzZXRHdWVzcyIsImFzT2JqIiwidG9PYmplY3QiLCJyZWNvbmZpZ3VyZSIsInNldExvY2FsZSIsInZhbHVlcyIsInNldHRpbmdXZWVrU3R1ZmYiLCJtaXhlZCIsInBsdXMiLCJkdXJhdGlvbiIsIm1pbnVzIiwibmVnYXRlIiwibm9ybWFsaXplZFVuaXQiLCJxIiwiZW5kT2YiLCJ0b0Zvcm1hdCIsInJlZGVmYXVsdFRvRU4iLCJ0b0xvY2FsZVN0cmluZyIsIkRBVEVfU0hPUlQiLCJmb3JtYXREYXRlVGltZSIsInRvTG9jYWxlUGFydHMiLCJmb3JtYXREYXRlVGltZVBhcnRzIiwidG9JU09EYXRlIiwidG9JU09UaW1lIiwidG9JU09XZWVrRGF0ZSIsInRvUkZDMjgyMiIsInRvSFRUUCIsInRvU1FMRGF0ZSIsInRvU1FMVGltZSIsInRvU1FMIiwidG9TdHJpbmciLCJ0b01pbGxpcyIsInRvU2Vjb25kcyIsInRvSlNPTiIsInRvQlNPTiIsInRvSlNEYXRlIiwiYmFzZSIsImluY2x1ZGVDb25maWciLCJvdGhlckRhdGVUaW1lIiwiZHVyT3B0cyIsIm1hcCIsIm90aGVySXNMYXRlciIsImVhcmxpZXIiLCJsYXRlciIsImRpZmZlZCIsImRpZmZOb3ciLCJ1bnRpbCIsImZyb21EYXRlVGltZXMiLCJpbnB1dE1zIiwib3RoZXJab25lRGF0ZVRpbWUiLCJvdGhlciIsInRvUmVsYXRpdmUiLCJwYWRkaW5nIiwiQXJyYXkiLCJpc0FycmF5IiwibnVtZXJpYyIsInRvUmVsYXRpdmVDYWxlbmRhciIsImRhdGVUaW1lcyIsImV2ZXJ5IiwiaSIsImZyb21Gb3JtYXRFeHBsYWluIiwiZnJvbVN0cmluZ0V4cGxhaW4iLCJEQVRFX01FRCIsIkRBVEVfTUVEX1dJVEhfV0VFS0RBWSIsIkRBVEVfRlVMTCIsIkRBVEVfSFVHRSIsIlRJTUVfU0lNUExFIiwiVElNRV9XSVRIX1NFQ09ORFMiLCJUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUIiwiVElNRV9XSVRIX0xPTkdfT0ZGU0VUIiwiVElNRV8yNF9TSU1QTEUiLCJUSU1FXzI0X1dJVEhfU0VDT05EUyIsIlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQiLCJUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQiLCJEQVRFVElNRV9TSE9SVCIsIkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyIsIkRBVEVUSU1FX01FRCIsIkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMiLCJEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZIiwiREFURVRJTUVfRlVMTCIsIkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTIiwiREFURVRJTUVfSFVHRSIsIkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTIiwiZnJpZW5kbHlEYXRlVGltZSIsImRhdGVUaW1laXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/datetime.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/duration.js":
/*!********************************************!*\
  !*** ./node_modules/luxon/src/duration.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Duration),\n/* harmony export */   friendlyDuration: () => (/* binding */ friendlyDuration)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/formatter.js */ \"(rsc)/./node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/invalid.js */ \"(rsc)/./node_modules/luxon/src/impl/invalid.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./impl/locale.js */ \"(rsc)/./node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _impl_regexParser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./impl/regexParser.js */ \"(rsc)/./node_modules/luxon/src/impl/regexParser.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./impl/util.js */ \"(rsc)/./node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./settings.js */ \"(rsc)/./node_modules/luxon/src/settings.js\");\n\n\n\n\n\n\n\nconst INVALID = \"Invalid Duration\";\n// unit conversion constants\nconst lowOrderMatrix = {\n    weeks: {\n        days: 7,\n        hours: 7 * 24,\n        minutes: 7 * 24 * 60,\n        seconds: 7 * 24 * 60 * 60,\n        milliseconds: 7 * 24 * 60 * 60 * 1000\n    },\n    days: {\n        hours: 24,\n        minutes: 24 * 60,\n        seconds: 24 * 60 * 60,\n        milliseconds: 24 * 60 * 60 * 1000\n    },\n    hours: {\n        minutes: 60,\n        seconds: 60 * 60,\n        milliseconds: 60 * 60 * 1000\n    },\n    minutes: {\n        seconds: 60,\n        milliseconds: 60 * 1000\n    },\n    seconds: {\n        milliseconds: 1000\n    }\n}, casualMatrix = Object.assign({\n    years: {\n        quarters: 4,\n        months: 12,\n        weeks: 52,\n        days: 365,\n        hours: 365 * 24,\n        minutes: 365 * 24 * 60,\n        seconds: 365 * 24 * 60 * 60,\n        milliseconds: 365 * 24 * 60 * 60 * 1000\n    },\n    quarters: {\n        months: 3,\n        weeks: 13,\n        days: 91,\n        hours: 91 * 24,\n        minutes: 91 * 24 * 60,\n        seconds: 91 * 24 * 60 * 60,\n        milliseconds: 91 * 24 * 60 * 60 * 1000\n    },\n    months: {\n        weeks: 4,\n        days: 30,\n        hours: 30 * 24,\n        minutes: 30 * 24 * 60,\n        seconds: 30 * 24 * 60 * 60,\n        milliseconds: 30 * 24 * 60 * 60 * 1000\n    }\n}, lowOrderMatrix), daysInYearAccurate = 146097.0 / 400, daysInMonthAccurate = 146097.0 / 4800, accurateMatrix = Object.assign({\n    years: {\n        quarters: 4,\n        months: 12,\n        weeks: daysInYearAccurate / 7,\n        days: daysInYearAccurate,\n        hours: daysInYearAccurate * 24,\n        minutes: daysInYearAccurate * 24 * 60,\n        seconds: daysInYearAccurate * 24 * 60 * 60,\n        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000\n    },\n    quarters: {\n        months: 3,\n        weeks: daysInYearAccurate / 28,\n        days: daysInYearAccurate / 4,\n        hours: daysInYearAccurate * 24 / 4,\n        minutes: daysInYearAccurate * 24 * 60 / 4,\n        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,\n        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4\n    },\n    months: {\n        weeks: daysInMonthAccurate / 7,\n        days: daysInMonthAccurate,\n        hours: daysInMonthAccurate * 24,\n        minutes: daysInMonthAccurate * 24 * 60,\n        seconds: daysInMonthAccurate * 24 * 60 * 60,\n        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000\n    }\n}, lowOrderMatrix);\n// units ordered by size\nconst orderedUnits = [\n    \"years\",\n    \"quarters\",\n    \"months\",\n    \"weeks\",\n    \"days\",\n    \"hours\",\n    \"minutes\",\n    \"seconds\",\n    \"milliseconds\"\n];\nconst reverseUnits = orderedUnits.slice(0).reverse();\n// clone really means \"create another instance just like this one, but with these changes\"\nfunction clone(dur, alts, clear = false) {\n    // deep merge for vals\n    const conf = {\n        values: clear ? alts.values : Object.assign({}, dur.values, alts.values || {}),\n        loc: dur.loc.clone(alts.loc),\n        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy\n    };\n    return new Duration(conf);\n}\nfunction antiTrunc(n) {\n    return n < 0 ? Math.floor(n) : Math.ceil(n);\n}\n// NB: mutates parameters\nfunction convert(matrix, fromMap, fromUnit, toMap, toUnit) {\n    const conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), // ok, so this is wild, but see the matrix in the tests\n    added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);\n    toMap[toUnit] += added;\n    fromMap[fromUnit] -= added * conv;\n}\n// NB: mutates parameters\nfunction normalizeValues(matrix, vals) {\n    reverseUnits.reduce((previous, current)=>{\n        if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(vals[current])) {\n            if (previous) {\n                convert(matrix, vals, previous, vals, current);\n            }\n            return current;\n        } else {\n            return previous;\n        }\n    }, null);\n}\n/**\n * A Duration object represents a period of time, like \"2 months\" or \"1 day, 1 hour\". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime.plus} to add a Duration object to a DateTime, producing another DateTime.\n *\n * Here is a brief overview of commonly used methods and getters in Duration:\n *\n * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.\n * * **Unit values** See the {@link Duration.years}, {@link Duration.months}, {@link Duration.weeks}, {@link Duration.days}, {@link Duration.hours}, {@link Duration.minutes}, {@link Duration.seconds}, {@link Duration.milliseconds} accessors.\n * * **Configuration** See  {@link Duration.locale} and {@link Duration.numberingSystem} accessors.\n * * **Transformation** To create new Durations out of old ones use {@link Duration.plus}, {@link Duration.minus}, {@link Duration.normalize}, {@link Duration.set}, {@link Duration.reconfigure}, {@link Duration.shiftTo}, and {@link Duration.negate}.\n * * **Output** To convert the Duration into other representations, see {@link Duration.as}, {@link Duration.toISO}, {@link Duration.toFormat}, and {@link Duration.toJSON}\n *\n * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.\n */ class Duration {\n    /**\n   * @private\n   */ constructor(config){\n        const accurate = config.conversionAccuracy === \"longterm\" || false;\n        /**\n     * @access private\n     */ this.values = config.values;\n        /**\n     * @access private\n     */ this.loc = config.loc || _impl_locale_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create();\n        /**\n     * @access private\n     */ this.conversionAccuracy = accurate ? \"longterm\" : \"casual\";\n        /**\n     * @access private\n     */ this.invalid = config.invalid || null;\n        /**\n     * @access private\n     */ this.matrix = accurate ? accurateMatrix : casualMatrix;\n        /**\n     * @access private\n     */ this.isLuxonDuration = true;\n    }\n    /**\n   * Create Duration from a number of milliseconds.\n   * @param {number} count of milliseconds\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */ static fromMillis(count, opts) {\n        return Duration.fromObject(Object.assign({\n            milliseconds: count\n        }, opts));\n    }\n    /**\n   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.\n   * If this object is empty then a zero milliseconds duration is returned.\n   * @param {Object} obj - the object to create the DateTime from\n   * @param {number} obj.years\n   * @param {number} obj.quarters\n   * @param {number} obj.months\n   * @param {number} obj.weeks\n   * @param {number} obj.days\n   * @param {number} obj.hours\n   * @param {number} obj.minutes\n   * @param {number} obj.seconds\n   * @param {number} obj.milliseconds\n   * @param {string} [obj.locale='en-US'] - the locale to use\n   * @param {string} obj.numberingSystem - the numbering system to use\n   * @param {string} [obj.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */ static fromObject(obj) {\n        if (obj == null || typeof obj !== \"object\") {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? \"null\" : typeof obj}`);\n        }\n        return new Duration({\n            values: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeObject)(obj, Duration.normalizeUnit, [\n                \"locale\",\n                \"numberingSystem\",\n                \"conversionAccuracy\",\n                \"zone\" // a bit of debt; it's super inconvenient internally not to be able to blindly pass this\n            ]),\n            loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromObject(obj),\n            conversionAccuracy: obj.conversionAccuracy\n        });\n    }\n    /**\n   * Create a Duration from an ISO 8601 duration string.\n   * @param {string} text - text to parse\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }\n   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }\n   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }\n   * @return {Duration}\n   */ static fromISO(text, opts) {\n        const [parsed] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_3__.parseISODuration)(text);\n        if (parsed) {\n            const obj = Object.assign(parsed, opts);\n            return Duration.fromObject(obj);\n        } else {\n            return Duration.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n        }\n    }\n    /**\n   * Create a Duration from an ISO 8601 time string.\n   * @param {string} text - text to parse\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }\n   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @return {Duration}\n   */ static fromISOTime(text, opts) {\n        const [parsed] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_3__.parseISOTimeOnly)(text);\n        if (parsed) {\n            const obj = Object.assign(parsed, opts);\n            return Duration.fromObject(obj);\n        } else {\n            return Duration.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n        }\n    }\n    /**\n   * Create an invalid Duration.\n   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {Duration}\n   */ static invalid(reason, explanation = null) {\n        if (!reason) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidArgumentError(\"need to specify a reason the Duration is invalid\");\n        }\n        const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](reason, explanation);\n        if (_settings_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].throwOnInvalid) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidDurationError(invalid);\n        } else {\n            return new Duration({\n                invalid\n            });\n        }\n    }\n    /**\n   * @private\n   */ static normalizeUnit(unit) {\n        const normalized = {\n            year: \"years\",\n            years: \"years\",\n            quarter: \"quarters\",\n            quarters: \"quarters\",\n            month: \"months\",\n            months: \"months\",\n            week: \"weeks\",\n            weeks: \"weeks\",\n            day: \"days\",\n            days: \"days\",\n            hour: \"hours\",\n            hours: \"hours\",\n            minute: \"minutes\",\n            minutes: \"minutes\",\n            second: \"seconds\",\n            seconds: \"seconds\",\n            millisecond: \"milliseconds\",\n            milliseconds: \"milliseconds\"\n        }[unit ? unit.toLowerCase() : unit];\n        if (!normalized) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidUnitError(unit);\n        return normalized;\n    }\n    /**\n   * Check if an object is a Duration. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */ static isDuration(o) {\n        return o && o.isLuxonDuration || false;\n    }\n    /**\n   * Get  the locale of a Duration, such 'en-GB'\n   * @type {string}\n   */ get locale() {\n        return this.isValid ? this.loc.locale : null;\n    }\n    /**\n   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration\n   *\n   * @type {string}\n   */ get numberingSystem() {\n        return this.isValid ? this.loc.numberingSystem : null;\n    }\n    /**\n   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:\n   * * `S` for milliseconds\n   * * `s` for seconds\n   * * `m` for minutes\n   * * `h` for hours\n   * * `d` for days\n   * * `M` for months\n   * * `y` for years\n   * Notes:\n   * * Add padding by repeating the token, e.g. \"yy\" pads the years to two digits, \"hhhh\" pads the hours out to four digits\n   * * The duration will be converted to the set of units in the format string using {@link Duration.shiftTo} and the Durations's conversion accuracy setting.\n   * @param {string} fmt - the format string\n   * @param {Object} opts - options\n   * @param {boolean} [opts.floor=true] - floor numerical values\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"y d s\") //=> \"1 6 2\"\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"yy dd sss\") //=> \"01 06 002\"\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"M S\") //=> \"12 518402000\"\n   * @return {string}\n   */ toFormat(fmt, opts = {}) {\n        // reverse-compat since 1.2; we always round down now, never up, and we do it by default\n        const fmtOpts = Object.assign({}, opts, {\n            floor: opts.round !== false && opts.floor !== false\n        });\n        return this.isValid ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;\n    }\n    /**\n   * Returns a JavaScript object with this Duration's values.\n   * @param opts - options for generating the object\n   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }\n   * @return {Object}\n   */ toObject(opts = {}) {\n        if (!this.isValid) return {};\n        const base = Object.assign({}, this.values);\n        if (opts.includeConfig) {\n            base.conversionAccuracy = this.conversionAccuracy;\n            base.numberingSystem = this.loc.numberingSystem;\n            base.locale = this.loc.locale;\n        }\n        return base;\n    }\n    /**\n   * Returns an ISO 8601-compliant string representation of this Duration.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'\n   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'\n   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'\n   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'\n   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'\n   * @return {string}\n   */ toISO() {\n        // we could use the formatter, but this is an easier way to get the minimum string\n        if (!this.isValid) return null;\n        let s = \"P\";\n        if (this.years !== 0) s += this.years + \"Y\";\n        if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + \"M\";\n        if (this.weeks !== 0) s += this.weeks + \"W\";\n        if (this.days !== 0) s += this.days + \"D\";\n        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) s += \"T\";\n        if (this.hours !== 0) s += this.hours + \"H\";\n        if (this.minutes !== 0) s += this.minutes + \"M\";\n        if (this.seconds !== 0 || this.milliseconds !== 0) // this will handle \"floating point madness\" by removing extra decimal places\n        // https://stackoverflow.com/questions/588004/is-floating-point-math-broken\n        s += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.roundTo)(this.seconds + this.milliseconds / 1000, 3) + \"S\";\n        if (s === \"P\") s += \"T0S\";\n        return s;\n    }\n    /**\n   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.\n   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'\n   * @return {string}\n   */ toISOTime(opts = {}) {\n        if (!this.isValid) return null;\n        const millis = this.toMillis();\n        if (millis < 0 || millis >= 86400000) return null;\n        opts = Object.assign({\n            suppressMilliseconds: false,\n            suppressSeconds: false,\n            includePrefix: false,\n            format: \"extended\"\n        }, opts);\n        const value = this.shiftTo(\"hours\", \"minutes\", \"seconds\", \"milliseconds\");\n        let fmt = opts.format === \"basic\" ? \"hhmm\" : \"hh:mm\";\n        if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {\n            fmt += opts.format === \"basic\" ? \"ss\" : \":ss\";\n            if (!opts.suppressMilliseconds || value.milliseconds !== 0) {\n                fmt += \".SSS\";\n            }\n        }\n        let str = value.toFormat(fmt);\n        if (opts.includePrefix) {\n            str = \"T\" + str;\n        }\n        return str;\n    }\n    /**\n   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.\n   * @return {string}\n   */ toJSON() {\n        return this.toISO();\n    }\n    /**\n   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.\n   * @return {string}\n   */ toString() {\n        return this.toISO();\n    }\n    /**\n   * Returns an milliseconds value of this Duration.\n   * @return {number}\n   */ toMillis() {\n        return this.as(\"milliseconds\");\n    }\n    /**\n   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}\n   * @return {number}\n   */ valueOf() {\n        return this.toMillis();\n    }\n    /**\n   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.\n   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @return {Duration}\n   */ plus(duration) {\n        if (!this.isValid) return this;\n        const dur = friendlyDuration(duration), result = {};\n        for (const k of orderedUnits){\n            if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(dur.values, k) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.values, k)) {\n                result[k] = dur.get(k) + this.get(k);\n            }\n        }\n        return clone(this, {\n            values: result\n        }, true);\n    }\n    /**\n   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.\n   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @return {Duration}\n   */ minus(duration) {\n        if (!this.isValid) return this;\n        const dur = friendlyDuration(duration);\n        return this.plus(dur.negate());\n    }\n    /**\n   * Scale this Duration by the specified amount. Return a newly-constructed Duration.\n   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.\n   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnit(x => x * 2) //=> { hours: 2, minutes: 60 }\n   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnit((x, u) => u === \"hour\" ? x * 2 : x) //=> { hours: 2, minutes: 30 }\n   * @return {Duration}\n   */ mapUnits(fn) {\n        if (!this.isValid) return this;\n        const result = {};\n        for (const k of Object.keys(this.values)){\n            result[k] = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.asNumber)(fn(this.values[k], k));\n        }\n        return clone(this, {\n            values: result\n        }, true);\n    }\n    /**\n   * Get the value of unit.\n   * @param {string} unit - a unit such as 'minute' or 'day'\n   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2\n   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0\n   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3\n   * @return {number}\n   */ get(unit) {\n        return this[Duration.normalizeUnit(unit)];\n    }\n    /**\n   * \"Set\" the values of specified units. Return a newly-constructed Duration.\n   * @param {Object} values - a mapping of units to numbers\n   * @example dur.set({ years: 2017 })\n   * @example dur.set({ hours: 8, minutes: 30 })\n   * @return {Duration}\n   */ set(values) {\n        if (!this.isValid) return this;\n        const mixed = Object.assign(this.values, (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeObject)(values, Duration.normalizeUnit, []));\n        return clone(this, {\n            values: mixed\n        });\n    }\n    /**\n   * \"Set\" the locale and/or numberingSystem.  Returns a newly-constructed Duration.\n   * @example dur.reconfigure({ locale: 'en-GB' })\n   * @return {Duration}\n   */ reconfigure({ locale, numberingSystem, conversionAccuracy } = {}) {\n        const loc = this.loc.clone({\n            locale,\n            numberingSystem\n        }), opts = {\n            loc\n        };\n        if (conversionAccuracy) {\n            opts.conversionAccuracy = conversionAccuracy;\n        }\n        return clone(this, opts);\n    }\n    /**\n   * Return the length of the duration in the specified unit.\n   * @param {string} unit - a unit such as 'minutes' or 'days'\n   * @example Duration.fromObject({years: 1}).as('days') //=> 365\n   * @example Duration.fromObject({years: 1}).as('months') //=> 12\n   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5\n   * @return {number}\n   */ as(unit) {\n        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;\n    }\n    /**\n   * Reduce this Duration to its canonical representation in its current units.\n   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }\n   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }\n   * @return {Duration}\n   */ normalize() {\n        if (!this.isValid) return this;\n        const vals = this.toObject();\n        normalizeValues(this.matrix, vals);\n        return clone(this, {\n            values: vals\n        }, true);\n    }\n    /**\n   * Convert this Duration into its representation in a different set of units.\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }\n   * @return {Duration}\n   */ shiftTo(...units) {\n        if (!this.isValid) return this;\n        if (units.length === 0) {\n            return this;\n        }\n        units = units.map((u)=>Duration.normalizeUnit(u));\n        const built = {}, accumulated = {}, vals = this.toObject();\n        let lastUnit;\n        for (const k of orderedUnits){\n            if (units.indexOf(k) >= 0) {\n                lastUnit = k;\n                let own = 0;\n                // anything we haven't boiled down yet should get boiled to this unit\n                for(const ak in accumulated){\n                    own += this.matrix[ak][k] * accumulated[ak];\n                    accumulated[ak] = 0;\n                }\n                // plus anything that's already in this unit\n                if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(vals[k])) {\n                    own += vals[k];\n                }\n                const i = Math.trunc(own);\n                built[k] = i;\n                accumulated[k] = own - i; // we'd like to absorb these fractions in another unit\n                // plus anything further down the chain that should be rolled up in to this\n                for(const down in vals){\n                    if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k)) {\n                        convert(this.matrix, vals, down, built, k);\n                    }\n                }\n            // otherwise, keep it in the wings to boil it later\n            } else if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(vals[k])) {\n                accumulated[k] = vals[k];\n            }\n        }\n        // anything leftover becomes the decimal for the last unit\n        // lastUnit must be defined since units is not empty\n        for(const key in accumulated){\n            if (accumulated[key] !== 0) {\n                built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];\n            }\n        }\n        return clone(this, {\n            values: built\n        }, true).normalize();\n    }\n    /**\n   * Return the negative of this Duration.\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }\n   * @return {Duration}\n   */ negate() {\n        if (!this.isValid) return this;\n        const negated = {};\n        for (const k of Object.keys(this.values)){\n            negated[k] = -this.values[k];\n        }\n        return clone(this, {\n            values: negated\n        }, true);\n    }\n    /**\n   * Get the years.\n   * @type {number}\n   */ get years() {\n        return this.isValid ? this.values.years || 0 : NaN;\n    }\n    /**\n   * Get the quarters.\n   * @type {number}\n   */ get quarters() {\n        return this.isValid ? this.values.quarters || 0 : NaN;\n    }\n    /**\n   * Get the months.\n   * @type {number}\n   */ get months() {\n        return this.isValid ? this.values.months || 0 : NaN;\n    }\n    /**\n   * Get the weeks\n   * @type {number}\n   */ get weeks() {\n        return this.isValid ? this.values.weeks || 0 : NaN;\n    }\n    /**\n   * Get the days.\n   * @type {number}\n   */ get days() {\n        return this.isValid ? this.values.days || 0 : NaN;\n    }\n    /**\n   * Get the hours.\n   * @type {number}\n   */ get hours() {\n        return this.isValid ? this.values.hours || 0 : NaN;\n    }\n    /**\n   * Get the minutes.\n   * @type {number}\n   */ get minutes() {\n        return this.isValid ? this.values.minutes || 0 : NaN;\n    }\n    /**\n   * Get the seconds.\n   * @return {number}\n   */ get seconds() {\n        return this.isValid ? this.values.seconds || 0 : NaN;\n    }\n    /**\n   * Get the milliseconds.\n   * @return {number}\n   */ get milliseconds() {\n        return this.isValid ? this.values.milliseconds || 0 : NaN;\n    }\n    /**\n   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations\n   * on invalid DateTimes or Intervals.\n   * @return {boolean}\n   */ get isValid() {\n        return this.invalid === null;\n    }\n    /**\n   * Returns an error code if this Duration became invalid, or null if the Duration is valid\n   * @return {string}\n   */ get invalidReason() {\n        return this.invalid ? this.invalid.reason : null;\n    }\n    /**\n   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid\n   * @type {string}\n   */ get invalidExplanation() {\n        return this.invalid ? this.invalid.explanation : null;\n    }\n    /**\n   * Equality check\n   * Two Durations are equal iff they have the same units and the same values for each unit.\n   * @param {Duration} other\n   * @return {boolean}\n   */ equals(other) {\n        if (!this.isValid || !other.isValid) {\n            return false;\n        }\n        if (!this.loc.equals(other.loc)) {\n            return false;\n        }\n        function eq(v1, v2) {\n            // Consider 0 and undefined as equal\n            if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;\n            return v1 === v2;\n        }\n        for (const u of orderedUnits){\n            if (!eq(this.values[u], other.values[u])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n/**\n * @private\n */ function friendlyDuration(durationish) {\n    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(durationish)) {\n        return Duration.fromMillis(durationish);\n    } else if (Duration.isDuration(durationish)) {\n        return durationish;\n    } else if (typeof durationish === \"object\") {\n        return Duration.fromObject(durationish);\n    } else {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidArgumentError(`Unknown duration argument ${durationish} of type ${typeof durationish}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2R1cmF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEyRjtBQUMvQztBQUNKO0FBQ0Y7QUFDcUM7QUFRbkQ7QUFDYTtBQUVyQyxNQUFNZSxVQUFVO0FBRWhCLDRCQUE0QjtBQUM1QixNQUFNQyxpQkFBaUI7SUFDbkJDLE9BQU87UUFDTEMsTUFBTTtRQUNOQyxPQUFPLElBQUk7UUFDWEMsU0FBUyxJQUFJLEtBQUs7UUFDbEJDLFNBQVMsSUFBSSxLQUFLLEtBQUs7UUFDdkJDLGNBQWMsSUFBSSxLQUFLLEtBQUssS0FBSztJQUNuQztJQUNBSixNQUFNO1FBQ0pDLE9BQU87UUFDUEMsU0FBUyxLQUFLO1FBQ2RDLFNBQVMsS0FBSyxLQUFLO1FBQ25CQyxjQUFjLEtBQUssS0FBSyxLQUFLO0lBQy9CO0lBQ0FILE9BQU87UUFBRUMsU0FBUztRQUFJQyxTQUFTLEtBQUs7UUFBSUMsY0FBYyxLQUFLLEtBQUs7SUFBSztJQUNyRUYsU0FBUztRQUFFQyxTQUFTO1FBQUlDLGNBQWMsS0FBSztJQUFLO0lBQ2hERCxTQUFTO1FBQUVDLGNBQWM7SUFBSztBQUNoQyxHQUNBQyxlQUFlQyxPQUFPQyxNQUFNLENBQzFCO0lBQ0VDLE9BQU87UUFDTEMsVUFBVTtRQUNWQyxRQUFRO1FBQ1JYLE9BQU87UUFDUEMsTUFBTTtRQUNOQyxPQUFPLE1BQU07UUFDYkMsU0FBUyxNQUFNLEtBQUs7UUFDcEJDLFNBQVMsTUFBTSxLQUFLLEtBQUs7UUFDekJDLGNBQWMsTUFBTSxLQUFLLEtBQUssS0FBSztJQUNyQztJQUNBSyxVQUFVO1FBQ1JDLFFBQVE7UUFDUlgsT0FBTztRQUNQQyxNQUFNO1FBQ05DLE9BQU8sS0FBSztRQUNaQyxTQUFTLEtBQUssS0FBSztRQUNuQkMsU0FBUyxLQUFLLEtBQUssS0FBSztRQUN4QkMsY0FBYyxLQUFLLEtBQUssS0FBSyxLQUFLO0lBQ3BDO0lBQ0FNLFFBQVE7UUFDTlgsT0FBTztRQUNQQyxNQUFN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QUNuQyxPQUFPO1FBQ1Q7UUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDNUQsR0FBRyxDQUFDc0gsTUFBTSxDQUFDQyxNQUFNdkgsR0FBRyxHQUFHO1lBQy9CLE9BQU87UUFDVDtRQUVBLFNBQVN3SCxHQUFHQyxFQUFFLEVBQUVDLEVBQUU7WUFDaEIsb0NBQW9DO1lBQ3BDLElBQUlELE9BQU9FLGFBQWFGLE9BQU8sR0FBRyxPQUFPQyxPQUFPQyxhQUFhRCxPQUFPO1lBQ3BFLE9BQU9ELE9BQU9DO1FBQ2hCO1FBRUEsS0FBSyxNQUFNakIsS0FBS25ILGFBQWM7WUFDNUIsSUFBSSxDQUFDa0ksR0FBRyxJQUFJLENBQUN6SCxNQUFNLENBQUMwRyxFQUFFLEVBQUVjLE1BQU14SCxNQUFNLENBQUMwRyxFQUFFLEdBQUc7Z0JBQ3hDLE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNqQixpQkFBaUJvQyxXQUFXO0lBQzFDLElBQUk1Six1REFBUUEsQ0FBQzRKLGNBQWM7UUFDekIsT0FBTzFILFNBQVM4QixVQUFVLENBQUM0RjtJQUM3QixPQUFPLElBQUkxSCxTQUFTdUQsVUFBVSxDQUFDbUUsY0FBYztRQUMzQyxPQUFPQTtJQUNULE9BQU8sSUFBSSxPQUFPQSxnQkFBZ0IsVUFBVTtRQUMxQyxPQUFPMUgsU0FBU2lDLFVBQVUsQ0FBQ3lGO0lBQzdCLE9BQU87UUFDTCxNQUFNLElBQUl0Syw0REFBb0JBLENBQzVCLENBQUMsMEJBQTBCLEVBQUVzSyxZQUFZLFNBQVMsRUFBRSxPQUFPQSxZQUFZLENBQUM7SUFFNUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2lhdG9vbHMtbmV4dC8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZHVyYXRpb24uanM/OWFiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW52YWxpZER1cmF0aW9uRXJyb3IsIEludmFsaWRVbml0RXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vaW1wbC9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ltcGwvaW52YWxpZC5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IHsgcGFyc2VJU09EdXJhdGlvbiwgcGFyc2VJU09UaW1lT25seSB9IGZyb20gXCIuL2ltcGwvcmVnZXhQYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIGFzTnVtYmVyLFxuICBoYXNPd25Qcm9wZXJ0eSxcbiAgaXNOdW1iZXIsXG4gIGlzVW5kZWZpbmVkLFxuICBub3JtYWxpemVPYmplY3QsXG4gIHJvdW5kVG9cbn0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcblxuY29uc3QgSU5WQUxJRCA9IFwiSW52YWxpZCBEdXJhdGlvblwiO1xuXG4vLyB1bml0IGNvbnZlcnNpb24gY29uc3RhbnRzXG5jb25zdCBsb3dPcmRlck1hdHJpeCA9IHtcbiAgICB3ZWVrczoge1xuICAgICAgZGF5czogNyxcbiAgICAgIGhvdXJzOiA3ICogMjQsXG4gICAgICBtaW51dGVzOiA3ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwXG4gICAgfSxcbiAgICBkYXlzOiB7XG4gICAgICBob3VyczogMjQsXG4gICAgICBtaW51dGVzOiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAyNCAqIDYwICogNjAgKiAxMDAwXG4gICAgfSxcbiAgICBob3VyczogeyBtaW51dGVzOiA2MCwgc2Vjb25kczogNjAgKiA2MCwgbWlsbGlzZWNvbmRzOiA2MCAqIDYwICogMTAwMCB9LFxuICAgIG1pbnV0ZXM6IHsgc2Vjb25kczogNjAsIG1pbGxpc2Vjb25kczogNjAgKiAxMDAwIH0sXG4gICAgc2Vjb25kczogeyBtaWxsaXNlY29uZHM6IDEwMDAgfVxuICB9LFxuICBjYXN1YWxNYXRyaXggPSBPYmplY3QuYXNzaWduKFxuICAgIHtcbiAgICAgIHllYXJzOiB7XG4gICAgICAgIHF1YXJ0ZXJzOiA0LFxuICAgICAgICBtb250aHM6IDEyLFxuICAgICAgICB3ZWVrczogNTIsXG4gICAgICAgIGRheXM6IDM2NSxcbiAgICAgICAgaG91cnM6IDM2NSAqIDI0LFxuICAgICAgICBtaW51dGVzOiAzNjUgKiAyNCAqIDYwLFxuICAgICAgICBzZWNvbmRzOiAzNjUgKiAyNCAqIDYwICogNjAsXG4gICAgICAgIG1pbGxpc2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMFxuICAgICAgfSxcbiAgICAgIHF1YXJ0ZXJzOiB7XG4gICAgICAgIG1vbnRoczogMyxcbiAgICAgICAgd2Vla3M6IDEzLFxuICAgICAgICBkYXlzOiA5MSxcbiAgICAgICAgaG91cnM6IDkxICogMjQsXG4gICAgICAgIG1pbnV0ZXM6IDkxICogMjQgKiA2MCxcbiAgICAgICAgc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAsXG4gICAgICAgIG1pbGxpc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAgKiAxMDAwXG4gICAgICB9LFxuICAgICAgbW9udGhzOiB7XG4gICAgICAgIHdlZWtzOiA0LFxuICAgICAgICBkYXlzOiAzMCxcbiAgICAgICAgaG91cnM6IDMwICogMjQsXG4gICAgICAgIG1pbnV0ZXM6IDMwICogMjQgKiA2MCxcbiAgICAgICAgc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjAsXG4gICAgICAgIG1pbGxpc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwXG4gICAgICB9XG4gICAgfSxcbiAgICBsb3dPcmRlck1hdHJpeFxuICApLFxuICBkYXlzSW5ZZWFyQWNjdXJhdGUgPSAxNDYwOTcuMCAvIDQwMCxcbiAgZGF5c0luTW9udGhBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDgwMCxcbiAgYWNjdXJhdGVNYXRyaXggPSBPYmplY3QuYXNzaWduKFxuICAgIHtcbiAgICAgIHllYXJzOiB7XG4gICAgICAgIHF1YXJ0ZXJzOiA0LFxuICAgICAgICBtb250aHM6IDEyLFxuICAgICAgICB3ZWVrczogZGF5c0luWWVhckFjY3VyYXRlIC8gNyxcbiAgICAgICAgZGF5czogZGF5c0luWWVhckFjY3VyYXRlLFxuICAgICAgICBob3VyczogZGF5c0luWWVhckFjY3VyYXRlICogMjQsXG4gICAgICAgIG1pbnV0ZXM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAsXG4gICAgICAgIHNlY29uZHM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwXG4gICAgICB9LFxuICAgICAgcXVhcnRlcnM6IHtcbiAgICAgICAgbW9udGhzOiAzLFxuICAgICAgICB3ZWVrczogZGF5c0luWWVhckFjY3VyYXRlIC8gMjgsXG4gICAgICAgIGRheXM6IGRheXNJblllYXJBY2N1cmF0ZSAvIDQsXG4gICAgICAgIGhvdXJzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQpIC8gNCxcbiAgICAgICAgbWludXRlczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjApIC8gNCxcbiAgICAgICAgc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCkgLyA0LFxuICAgICAgICBtaWxsaXNlY29uZHM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwKSAvIDRcbiAgICAgIH0sXG4gICAgICBtb250aHM6IHtcbiAgICAgICAgd2Vla3M6IGRheXNJbk1vbnRoQWNjdXJhdGUgLyA3LFxuICAgICAgICBkYXlzOiBkYXlzSW5Nb250aEFjY3VyYXRlLFxuICAgICAgICBob3VyczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0LFxuICAgICAgICBtaW51dGVzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCxcbiAgICAgICAgc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMFxuICAgICAgfVxuICAgIH0sXG4gICAgbG93T3JkZXJNYXRyaXhcbiAgKTtcblxuLy8gdW5pdHMgb3JkZXJlZCBieSBzaXplXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXG4gIFwieWVhcnNcIixcbiAgXCJxdWFydGVyc1wiLFxuICBcIm1vbnRoc1wiLFxuICBcIndlZWtzXCIsXG4gIFwiZGF5c1wiLFxuICBcImhvdXJzXCIsXG4gIFwibWludXRlc1wiLFxuICBcInNlY29uZHNcIixcbiAgXCJtaWxsaXNlY29uZHNcIlxuXTtcblxuY29uc3QgcmV2ZXJzZVVuaXRzID0gb3JkZXJlZFVuaXRzLnNsaWNlKDApLnJldmVyc2UoKTtcblxuLy8gY2xvbmUgcmVhbGx5IG1lYW5zIFwiY3JlYXRlIGFub3RoZXIgaW5zdGFuY2UganVzdCBsaWtlIHRoaXMgb25lLCBidXQgd2l0aCB0aGVzZSBjaGFuZ2VzXCJcbmZ1bmN0aW9uIGNsb25lKGR1ciwgYWx0cywgY2xlYXIgPSBmYWxzZSkge1xuICAvLyBkZWVwIG1lcmdlIGZvciB2YWxzXG4gIGNvbnN0IGNvbmYgPSB7XG4gICAgdmFsdWVzOiBjbGVhciA/IGFsdHMudmFsdWVzIDogT2JqZWN0LmFzc2lnbih7fSwgZHVyLnZhbHVlcywgYWx0cy52YWx1ZXMgfHwge30pLFxuICAgIGxvYzogZHVyLmxvYy5jbG9uZShhbHRzLmxvYyksXG4gICAgY29udmVyc2lvbkFjY3VyYWN5OiBhbHRzLmNvbnZlcnNpb25BY2N1cmFjeSB8fCBkdXIuY29udmVyc2lvbkFjY3VyYWN5XG4gIH07XG4gIHJldHVybiBuZXcgRHVyYXRpb24oY29uZik7XG59XG5cbmZ1bmN0aW9uIGFudGlUcnVuYyhuKSB7XG4gIHJldHVybiBuIDwgMCA/IE1hdGguZmxvb3IobikgOiBNYXRoLmNlaWwobik7XG59XG5cbi8vIE5COiBtdXRhdGVzIHBhcmFtZXRlcnNcbmZ1bmN0aW9uIGNvbnZlcnQobWF0cml4LCBmcm9tTWFwLCBmcm9tVW5pdCwgdG9NYXAsIHRvVW5pdCkge1xuICBjb25zdCBjb252ID0gbWF0cml4W3RvVW5pdF1bZnJvbVVuaXRdLFxuICAgIHJhdyA9IGZyb21NYXBbZnJvbVVuaXRdIC8gY29udixcbiAgICBzYW1lU2lnbiA9IE1hdGguc2lnbihyYXcpID09PSBNYXRoLnNpZ24odG9NYXBbdG9Vbml0XSksXG4gICAgLy8gb2ssIHNvIHRoaXMgaXMgd2lsZCwgYnV0IHNlZSB0aGUgbWF0cml4IGluIHRoZSB0ZXN0c1xuICAgIGFkZGVkID1cbiAgICAgICFzYW1lU2lnbiAmJiB0b01hcFt0b1VuaXRdICE9PSAwICYmIE1hdGguYWJzKHJhdykgPD0gMSA/IGFudGlUcnVuYyhyYXcpIDogTWF0aC50cnVuYyhyYXcpO1xuICB0b01hcFt0b1VuaXRdICs9IGFkZGVkO1xuICBmcm9tTWFwW2Zyb21Vbml0XSAtPSBhZGRlZCAqIGNvbnY7XG59XG5cbi8vIE5COiBtdXRhdGVzIHBhcmFtZXRlcnNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlcyhtYXRyaXgsIHZhbHMpIHtcbiAgcmV2ZXJzZVVuaXRzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbHNbY3VycmVudF0pKSB7XG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgY29udmVydChtYXRyaXgsIHZhbHMsIHByZXZpb3VzLCB2YWxzLCBjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuICB9LCBudWxsKTtcbn1cblxuLyoqXG4gKiBBIER1cmF0aW9uIG9iamVjdCByZXByZXNlbnRzIGEgcGVyaW9kIG9mIHRpbWUsIGxpa2UgXCIyIG1vbnRoc1wiIG9yIFwiMSBkYXksIDEgaG91clwiLiBDb25jZXB0dWFsbHksIGl0J3MganVzdCBhIG1hcCBvZiB1bml0cyB0byB0aGVpciBxdWFudGl0aWVzLCBhY2NvbXBhbmllZCBieSBzb21lIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBhbmQgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS4gVGhleSBjYW4gYmUgdXNlZCBvbiB0aGVpciBvd24gb3IgaW4gY29uanVuY3Rpb24gd2l0aCBvdGhlciBMdXhvbiB0eXBlczsgZm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlIHtAbGluayBEYXRlVGltZS5wbHVzfSB0byBhZGQgYSBEdXJhdGlvbiBvYmplY3QgdG8gYSBEYXRlVGltZSwgcHJvZHVjaW5nIGFub3RoZXIgRGF0ZVRpbWUuXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIGNvbW1vbmx5IHVzZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBpbiBEdXJhdGlvbjpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKiBUbyBjcmVhdGUgYSBEdXJhdGlvbiwgdXNlIHtAbGluayBEdXJhdGlvbi5mcm9tTWlsbGlzfSwge0BsaW5rIER1cmF0aW9uLmZyb21PYmplY3R9LCBvciB7QGxpbmsgRHVyYXRpb24uZnJvbUlTT30uXG4gKiAqICoqVW5pdCB2YWx1ZXMqKiBTZWUgdGhlIHtAbGluayBEdXJhdGlvbi55ZWFyc30sIHtAbGluayBEdXJhdGlvbi5tb250aHN9LCB7QGxpbmsgRHVyYXRpb24ud2Vla3N9LCB7QGxpbmsgRHVyYXRpb24uZGF5c30sIHtAbGluayBEdXJhdGlvbi5ob3Vyc30sIHtAbGluayBEdXJhdGlvbi5taW51dGVzfSwge0BsaW5rIER1cmF0aW9uLnNlY29uZHN9LCB7QGxpbmsgRHVyYXRpb24ubWlsbGlzZWNvbmRzfSBhY2Nlc3NvcnMuXG4gKiAqICoqQ29uZmlndXJhdGlvbioqIFNlZSAge0BsaW5rIER1cmF0aW9uLmxvY2FsZX0gYW5kIHtAbGluayBEdXJhdGlvbi5udW1iZXJpbmdTeXN0ZW19IGFjY2Vzc29ycy5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqIFRvIGNyZWF0ZSBuZXcgRHVyYXRpb25zIG91dCBvZiBvbGQgb25lcyB1c2Uge0BsaW5rIER1cmF0aW9uLnBsdXN9LCB7QGxpbmsgRHVyYXRpb24ubWludXN9LCB7QGxpbmsgRHVyYXRpb24ubm9ybWFsaXplfSwge0BsaW5rIER1cmF0aW9uLnNldH0sIHtAbGluayBEdXJhdGlvbi5yZWNvbmZpZ3VyZX0sIHtAbGluayBEdXJhdGlvbi5zaGlmdFRvfSwgYW5kIHtAbGluayBEdXJhdGlvbi5uZWdhdGV9LlxuICogKiAqKk91dHB1dCoqIFRvIGNvbnZlcnQgdGhlIER1cmF0aW9uIGludG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCBzZWUge0BsaW5rIER1cmF0aW9uLmFzfSwge0BsaW5rIER1cmF0aW9uLnRvSVNPfSwge0BsaW5rIER1cmF0aW9uLnRvRm9ybWF0fSwgYW5kIHtAbGluayBEdXJhdGlvbi50b0pTT059XG4gKlxuICogVGhlcmUncyBhcmUgbW9yZSBtZXRob2RzIGRvY3VtZW50ZWQgYmVsb3cuIEluIGFkZGl0aW9uLCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdWJ0bGVyIHRvcGljcyBsaWtlIGludGVybmF0aW9uYWxpemF0aW9uIGFuZCB2YWxpZGl0eSwgc2VlIHRoZSBleHRlcm5hbCBkb2N1bWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEdXJhdGlvbiB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3QgYWNjdXJhdGUgPSBjb25maWcuY29udmVyc2lvbkFjY3VyYWN5ID09PSBcImxvbmd0ZXJtXCIgfHwgZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy52YWx1ZXMgPSBjb25maWcudmFsdWVzO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9jID0gY29uZmlnLmxvYyB8fCBMb2NhbGUuY3JlYXRlKCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jb252ZXJzaW9uQWNjdXJhY3kgPSBhY2N1cmF0ZSA/IFwibG9uZ3Rlcm1cIiA6IFwiY2FzdWFsXCI7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gY29uZmlnLmludmFsaWQgfHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1hdHJpeCA9IGFjY3VyYXRlID8gYWNjdXJhdGVNYXRyaXggOiBjYXN1YWxNYXRyaXg7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uRHVyYXRpb24gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBEdXJhdGlvbiBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IG9mIG1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbU1pbGxpcyhjb3VudCwgb3B0cykge1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KE9iamVjdC5hc3NpZ24oeyBtaWxsaXNlY29uZHM6IGNvdW50IH0sIG9wdHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXJzJyBhbmQgJ2hvdXJzJy5cbiAgICogSWYgdGhpcyBvYmplY3QgaXMgZW1wdHkgdGhlbiBhIHplcm8gbWlsbGlzZWNvbmRzIGR1cmF0aW9uIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBjcmVhdGUgdGhlIERhdGVUaW1lIGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai55ZWFyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnF1YXJ0ZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGhzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5kYXlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouaG91cnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taW51dGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29iai5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29iai5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tT2JqZWN0KG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBEdXJhdGlvbi5mcm9tT2JqZWN0OiBhcmd1bWVudCBleHBlY3RlZCB0byBiZSBhbiBvYmplY3QsIGdvdCAke1xuICAgICAgICAgIG9iaiA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIG9ialxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEdXJhdGlvbih7XG4gICAgICB2YWx1ZXM6IG5vcm1hbGl6ZU9iamVjdChvYmosIER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQsIFtcbiAgICAgICAgXCJsb2NhbGVcIixcbiAgICAgICAgXCJudW1iZXJpbmdTeXN0ZW1cIixcbiAgICAgICAgXCJjb252ZXJzaW9uQWNjdXJhY3lcIixcbiAgICAgICAgXCJ6b25lXCIgLy8gYSBiaXQgb2YgZGVidDsgaXQncyBzdXBlciBpbmNvbnZlbmllbnQgaW50ZXJuYWxseSBub3QgdG8gYmUgYWJsZSB0byBibGluZGx5IHBhc3MgdGhpc1xuICAgICAgXSksXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9iaiksXG4gICAgICBjb252ZXJzaW9uQWNjdXJhY3k6IG9iai5jb252ZXJzaW9uQWNjdXJhY3lcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIGR1cmF0aW9uIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQM1k2TTFXNERUMTJIMzBNNVMnKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMywgbW9udGhzOiA2LCB3ZWVrczogMSwgZGF5czogNCwgaG91cnM6IDEyLCBtaW51dGVzOiAzMCwgc2Vjb25kczogNSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1BUMjNIJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDIzIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUDVZM00nKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogNSwgbW9udGhzOiAzIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3BhcnNlZF0gPSBwYXJzZUlTT0R1cmF0aW9uKHRleHQpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5hc3NpZ24ocGFyc2VkLCBvcHRzKTtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIHRpbWUgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjIyOjMzLjQ0NCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMjIsIHNlY29uZHM6IDMzLCBtaWxsaXNlY29uZHM6IDQ0NCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTE6MDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21JU09UaW1lKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcGFyc2VkXSA9IHBhcnNlSVNPVGltZU9ubHkodGV4dCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmFzc2lnbihwYXJzZWQsIG9wdHMpO1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3Qob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBkYXRldGltZSBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIER1cmF0aW9uIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREdXJhdGlvbkVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgICAgeWVhcjogXCJ5ZWFyc1wiLFxuICAgICAgeWVhcnM6IFwieWVhcnNcIixcbiAgICAgIHF1YXJ0ZXI6IFwicXVhcnRlcnNcIixcbiAgICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJzXCIsXG4gICAgICBtb250aDogXCJtb250aHNcIixcbiAgICAgIG1vbnRoczogXCJtb250aHNcIixcbiAgICAgIHdlZWs6IFwid2Vla3NcIixcbiAgICAgIHdlZWtzOiBcIndlZWtzXCIsXG4gICAgICBkYXk6IFwiZGF5c1wiLFxuICAgICAgZGF5czogXCJkYXlzXCIsXG4gICAgICBob3VyOiBcImhvdXJzXCIsXG4gICAgICBob3VyczogXCJob3Vyc1wiLFxuICAgICAgbWludXRlOiBcIm1pbnV0ZXNcIixcbiAgICAgIG1pbnV0ZXM6IFwibWludXRlc1wiLFxuICAgICAgc2Vjb25kOiBcInNlY29uZHNcIixcbiAgICAgIHNlY29uZHM6IFwic2Vjb25kc1wiLFxuICAgICAgbWlsbGlzZWNvbmQ6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZHM6IFwibWlsbGlzZWNvbmRzXCJcbiAgICB9W3VuaXQgPyB1bml0LnRvTG93ZXJDYXNlKCkgOiB1bml0XTtcblxuICAgIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBEdXJhdGlvbi4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRHVyYXRpb24obykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25EdXJhdGlvbikgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0ICB0aGUgbG9jYWxlIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2VuLUdCJ1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubG9jYWxlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlcmluZyBzeXN0ZW0gb2YgYSBEdXJhdGlvbiwgc3VjaCAnYmVuZycuIFRoZSBudW1iZXJpbmcgc3lzdGVtIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEdXJhdGlvblxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuIFlvdSBtYXkgdXNlIHRoZXNlIHRva2VuczpcbiAgICogKiBgU2AgZm9yIG1pbGxpc2Vjb25kc1xuICAgKiAqIGBzYCBmb3Igc2Vjb25kc1xuICAgKiAqIGBtYCBmb3IgbWludXRlc1xuICAgKiAqIGBoYCBmb3IgaG91cnNcbiAgICogKiBgZGAgZm9yIGRheXNcbiAgICogKiBgTWAgZm9yIG1vbnRoc1xuICAgKiAqIGB5YCBmb3IgeWVhcnNcbiAgICogTm90ZXM6XG4gICAqICogQWRkIHBhZGRpbmcgYnkgcmVwZWF0aW5nIHRoZSB0b2tlbiwgZS5nLiBcInl5XCIgcGFkcyB0aGUgeWVhcnMgdG8gdHdvIGRpZ2l0cywgXCJoaGhoXCIgcGFkcyB0aGUgaG91cnMgb3V0IHRvIGZvdXIgZGlnaXRzXG4gICAqICogVGhlIGR1cmF0aW9uIHdpbGwgYmUgY29udmVydGVkIHRvIHRoZSBzZXQgb2YgdW5pdHMgaW4gdGhlIGZvcm1hdCBzdHJpbmcgdXNpbmcge0BsaW5rIER1cmF0aW9uLnNoaWZ0VG99IGFuZCB0aGUgRHVyYXRpb25zJ3MgY29udmVyc2lvbiBhY2N1cmFjeSBzZXR0aW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZmxvb3I9dHJ1ZV0gLSBmbG9vciBudW1lcmljYWwgdmFsdWVzXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcInkgZCBzXCIpIC8vPT4gXCIxIDYgMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcInl5IGRkIHNzc1wiKSAvLz0+IFwiMDEgMDYgMDAyXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvRm9ybWF0KFwiTSBTXCIpIC8vPT4gXCIxMiA1MTg0MDIwMDBcIlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChmbXQsIG9wdHMgPSB7fSkge1xuICAgIC8vIHJldmVyc2UtY29tcGF0IHNpbmNlIDEuMjsgd2UgYWx3YXlzIHJvdW5kIGRvd24gbm93LCBuZXZlciB1cCwgYW5kIHdlIGRvIGl0IGJ5IGRlZmF1bHRcbiAgICBjb25zdCBmbXRPcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge1xuICAgICAgZmxvb3I6IG9wdHMucm91bmQgIT09IGZhbHNlICYmIG9wdHMuZmxvb3IgIT09IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLCBmbXRPcHRzKS5mb3JtYXREdXJhdGlvbkZyb21TdHJpbmcodGhpcywgZm10KVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoaXMgRHVyYXRpb24ncyB2YWx1ZXMuXG4gICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBmb3IgZ2VuZXJhdGluZyB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZUNvbmZpZz1mYWxzZV0gLSBpbmNsdWRlIGNvbmZpZ3VyYXRpb24gYXR0cmlidXRlcyBpbiB0aGUgb3V0cHV0XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvT2JqZWN0KG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4ge307XG5cbiAgICBjb25zdCBiYXNlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52YWx1ZXMpO1xuXG4gICAgaWYgKG9wdHMuaW5jbHVkZUNvbmZpZykge1xuICAgICAgYmFzZS5jb252ZXJzaW9uQWNjdXJhY3kgPSB0aGlzLmNvbnZlcnNpb25BY2N1cmFjeTtcbiAgICAgIGJhc2UubnVtYmVyaW5nU3lzdGVtID0gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgYmFzZS5sb2NhbGUgPSB0aGlzLmxvYy5sb2NhbGU7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDMsIHNlY29uZHM6IDQ1IH0pLnRvSVNPKCkgLy89PiAnUDNZVDQ1UydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogNCwgc2Vjb25kczogNDUgfSkudG9JU08oKSAvLz0+ICdQNE1UNDVTJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiA1IH0pLnRvSVNPKCkgLy89PiAnUDVNJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogNSB9KS50b0lTTygpIC8vPT4gJ1BUNU0nXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IDYgfSkudG9JU08oKSAvLz0+ICdQVDAuMDA2UydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08oKSB7XG4gICAgLy8gd2UgY291bGQgdXNlIHRoZSBmb3JtYXR0ZXIsIGJ1dCB0aGlzIGlzIGFuIGVhc2llciB3YXkgdG8gZ2V0IHRoZSBtaW5pbXVtIHN0cmluZ1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIGxldCBzID0gXCJQXCI7XG4gICAgaWYgKHRoaXMueWVhcnMgIT09IDApIHMgKz0gdGhpcy55ZWFycyArIFwiWVwiO1xuICAgIGlmICh0aGlzLm1vbnRocyAhPT0gMCB8fCB0aGlzLnF1YXJ0ZXJzICE9PSAwKSBzICs9IHRoaXMubW9udGhzICsgdGhpcy5xdWFydGVycyAqIDMgKyBcIk1cIjtcbiAgICBpZiAodGhpcy53ZWVrcyAhPT0gMCkgcyArPSB0aGlzLndlZWtzICsgXCJXXCI7XG4gICAgaWYgKHRoaXMuZGF5cyAhPT0gMCkgcyArPSB0aGlzLmRheXMgKyBcIkRcIjtcbiAgICBpZiAodGhpcy5ob3VycyAhPT0gMCB8fCB0aGlzLm1pbnV0ZXMgIT09IDAgfHwgdGhpcy5zZWNvbmRzICE9PSAwIHx8IHRoaXMubWlsbGlzZWNvbmRzICE9PSAwKVxuICAgICAgcyArPSBcIlRcIjtcbiAgICBpZiAodGhpcy5ob3VycyAhPT0gMCkgcyArPSB0aGlzLmhvdXJzICsgXCJIXCI7XG4gICAgaWYgKHRoaXMubWludXRlcyAhPT0gMCkgcyArPSB0aGlzLm1pbnV0ZXMgKyBcIk1cIjtcbiAgICBpZiAodGhpcy5zZWNvbmRzICE9PSAwIHx8IHRoaXMubWlsbGlzZWNvbmRzICE9PSAwKVxuICAgICAgLy8gdGhpcyB3aWxsIGhhbmRsZSBcImZsb2F0aW5nIHBvaW50IG1hZG5lc3NcIiBieSByZW1vdmluZyBleHRyYSBkZWNpbWFsIHBsYWNlc1xuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTg4MDA0L2lzLWZsb2F0aW5nLXBvaW50LW1hdGgtYnJva2VuXG4gICAgICBzICs9IHJvdW5kVG8odGhpcy5zZWNvbmRzICsgdGhpcy5taWxsaXNlY29uZHMgLyAxMDAwLCAzKSArIFwiU1wiO1xuICAgIGlmIChzID09PSBcIlBcIikgcyArPSBcIlQwU1wiO1xuICAgIHJldHVybiBzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uLCBmb3JtYXR0ZWQgYXMgYSB0aW1lIG9mIGRheS5cbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgZHVyYXRpb24gaXMgaW52YWxpZCwgbmVnYXRpdmUsIG9yIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAyNCBob3Vycy5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVByZWZpeD1mYWxzZV0gLSBpbmNsdWRlIHRoZSBgVGAgcHJlZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSgpIC8vPT4gJzExOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc01pbGxpc2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcxMTowMDowMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc1NlY29uZHM6IHRydWUgfSkgLy89PiAnMTE6MDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgaW5jbHVkZVByZWZpeDogdHJ1ZSB9KSAvLz0+ICdUMTE6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcxMTAwMDAuMDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgbWlsbGlzID0gdGhpcy50b01pbGxpcygpO1xuICAgIGlmIChtaWxsaXMgPCAwIHx8IG1pbGxpcyA+PSA4NjQwMDAwMCkgcmV0dXJuIG51bGw7XG5cbiAgICBvcHRzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHM6IGZhbHNlLFxuICAgICAgICBzdXBwcmVzc1NlY29uZHM6IGZhbHNlLFxuICAgICAgICBpbmNsdWRlUHJlZml4OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBcImV4dGVuZGVkXCJcbiAgICAgIH0sXG4gICAgICBvcHRzXG4gICAgKTtcblxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zaGlmdFRvKFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiKTtcblxuICAgIGxldCBmbXQgPSBvcHRzLmZvcm1hdCA9PT0gXCJiYXNpY1wiID8gXCJoaG1tXCIgOiBcImhoOm1tXCI7XG5cbiAgICBpZiAoIW9wdHMuc3VwcHJlc3NTZWNvbmRzIHx8IHZhbHVlLnNlY29uZHMgIT09IDAgfHwgdmFsdWUubWlsbGlzZWNvbmRzICE9PSAwKSB7XG4gICAgICBmbXQgKz0gb3B0cy5mb3JtYXQgPT09IFwiYmFzaWNcIiA/IFwic3NcIiA6IFwiOnNzXCI7XG4gICAgICBpZiAoIW9wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHMgfHwgdmFsdWUubWlsbGlzZWNvbmRzICE9PSAwKSB7XG4gICAgICAgIGZtdCArPSBcIi5TU1NcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc3RyID0gdmFsdWUudG9Gb3JtYXQoZm10KTtcblxuICAgIGlmIChvcHRzLmluY2x1ZGVQcmVmaXgpIHtcbiAgICAgIHN0ciA9IFwiVFwiICsgc3RyO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSlNPTi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gZGVidWdnaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvTWlsbGlzKCkge1xuICAgIHJldHVybiB0aGlzLmFzKFwibWlsbGlzZWNvbmRzXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIHRoaXMgRHVyYXRpb24uIEFsaWFzIG9mIHtAbGluayB0b01pbGxpc31cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy50b01pbGxpcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBsb25nZXIgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBhZGQuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgcGx1cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IGR1ciA9IGZyaWVuZGx5RHVyYXRpb24oZHVyYXRpb24pLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGsgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkoZHVyLnZhbHVlcywgaykgfHwgaGFzT3duUHJvcGVydHkodGhpcy52YWx1ZXMsIGspKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IGR1ci5nZXQoaykgKyB0aGlzLmdldChrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHJlc3VsdCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHRoaXMgRHVyYXRpb24gc2hvcnRlciBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIHN1YnRyYWN0LiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgZHVyID0gZnJpZW5kbHlEdXJhdGlvbihkdXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXMucGx1cyhkdXIubmVnYXRlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxlIHRoaXMgRHVyYXRpb24gYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHVuaXQuIEFyaXR5IGlzIDEgb3IgMjogdGhlIHZhbHVlIG9mIHRoZSB1bml0IGFuZCwgb3B0aW9uYWxseSwgdGhlIHVuaXQgbmFtZS4gTXVzdCByZXR1cm4gYSBudW1iZXIuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgbWludXRlczogMzAgfSkubWFwVW5pdCh4ID0+IHggKiAyKSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDYwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0KCh4LCB1KSA9PiB1ID09PSBcImhvdXJcIiA/IHggKiAyIDogeCkgLy89PiB7IGhvdXJzOiAyLCBtaW51dGVzOiAzMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbWFwVW5pdHMoZm4pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKSkge1xuICAgICAgcmVzdWx0W2tdID0gYXNOdW1iZXIoZm4odGhpcy52YWx1ZXNba10sIGspKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiByZXN1bHQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGUnIG9yICdkYXknXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAyLCBkYXlzOiAzfSkuZ2V0KCd5ZWFycycpIC8vPT4gMlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgnbW9udGhzJykgLy89PiAwXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAyLCBkYXlzOiAzfSkuZ2V0KCdkYXlzJykgLy89PiAzXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXNbRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1bml0KV07XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB1bml0cy4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSBhIG1hcHBpbmcgb2YgdW5pdHMgdG8gbnVtYmVyc1xuICAgKiBAZXhhbXBsZSBkdXIuc2V0KHsgeWVhcnM6IDIwMTcgfSlcbiAgICogQGV4YW1wbGUgZHVyLnNldCh7IGhvdXJzOiA4LCBtaW51dGVzOiAzMCB9KVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNldCh2YWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBtaXhlZCA9IE9iamVjdC5hc3NpZ24odGhpcy52YWx1ZXMsIG5vcm1hbGl6ZU9iamVjdCh2YWx1ZXMsIER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQsIFtdKSk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBtaXhlZCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUgYW5kL29yIG51bWJlcmluZ1N5c3RlbS4gIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQGV4YW1wbGUgZHVyLnJlY29uZmlndXJlKHsgbG9jYWxlOiAnZW4tR0InIH0pXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgcmVjb25maWd1cmUoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgY29udmVyc2lvbkFjY3VyYWN5IH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0gfSksXG4gICAgICBvcHRzID0geyBsb2MgfTtcblxuICAgIGlmIChjb252ZXJzaW9uQWNjdXJhY3kpIHtcbiAgICAgIG9wdHMuY29udmVyc2lvbkFjY3VyYWN5ID0gY29udmVyc2lvbkFjY3VyYWN5O1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZSh0aGlzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgZHVyYXRpb24gaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGVzJyBvciAnZGF5cydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDF9KS5hcygnZGF5cycpIC8vPT4gMzY1XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ21vbnRocycpIC8vPT4gMTJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7aG91cnM6IDYwfSkuYXMoJ2RheXMnKSAvLz0+IDIuNVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBhcyh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuc2hpZnRUbyh1bml0KS5nZXQodW5pdCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmVkdWNlIHRoaXMgRHVyYXRpb24gdG8gaXRzIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBpbiBpdHMgY3VycmVudCB1bml0cy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLCBkYXlzOiA1MDAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAxNSwgZGF5czogMjU1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMiwgbWludXRlczogLTQ1IH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMTUgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG5vcm1hbGl6ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmFscyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICBub3JtYWxpemVWYWx1ZXModGhpcy5tYXRyaXgsIHZhbHMpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogdmFscyB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoaXMgRHVyYXRpb24gaW50byBpdHMgcmVwcmVzZW50YXRpb24gaW4gYSBkaWZmZXJlbnQgc2V0IG9mIHVuaXRzLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIHNlY29uZHM6IDMwIH0pLnNoaWZ0VG8oJ21pbnV0ZXMnLCAnbWlsbGlzZWNvbmRzJykudG9PYmplY3QoKSAvLz0+IHsgbWludXRlczogNjAsIG1pbGxpc2Vjb25kczogMzAwMDAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNoaWZ0VG8oLi4udW5pdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1bml0cyA9IHVuaXRzLm1hcCh1ID0+IER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodSkpO1xuXG4gICAgY29uc3QgYnVpbHQgPSB7fSxcbiAgICAgIGFjY3VtdWxhdGVkID0ge30sXG4gICAgICB2YWxzID0gdGhpcy50b09iamVjdCgpO1xuICAgIGxldCBsYXN0VW5pdDtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmICh1bml0cy5pbmRleE9mKGspID49IDApIHtcbiAgICAgICAgbGFzdFVuaXQgPSBrO1xuXG4gICAgICAgIGxldCBvd24gPSAwO1xuXG4gICAgICAgIC8vIGFueXRoaW5nIHdlIGhhdmVuJ3QgYm9pbGVkIGRvd24geWV0IHNob3VsZCBnZXQgYm9pbGVkIHRvIHRoaXMgdW5pdFxuICAgICAgICBmb3IgKGNvbnN0IGFrIGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICAgICAgb3duICs9IHRoaXMubWF0cml4W2FrXVtrXSAqIGFjY3VtdWxhdGVkW2FrXTtcbiAgICAgICAgICBhY2N1bXVsYXRlZFtha10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGx1cyBhbnl0aGluZyB0aGF0J3MgYWxyZWFkeSBpbiB0aGlzIHVuaXRcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgICAgb3duICs9IHZhbHNba107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpID0gTWF0aC50cnVuYyhvd24pO1xuICAgICAgICBidWlsdFtrXSA9IGk7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gb3duIC0gaTsgLy8gd2UnZCBsaWtlIHRvIGFic29yYiB0aGVzZSBmcmFjdGlvbnMgaW4gYW5vdGhlciB1bml0XG5cbiAgICAgICAgLy8gcGx1cyBhbnl0aGluZyBmdXJ0aGVyIGRvd24gdGhlIGNoYWluIHRoYXQgc2hvdWxkIGJlIHJvbGxlZCB1cCBpbiB0byB0aGlzXG4gICAgICAgIGZvciAoY29uc3QgZG93biBpbiB2YWxzKSB7XG4gICAgICAgICAgaWYgKG9yZGVyZWRVbml0cy5pbmRleE9mKGRvd24pID4gb3JkZXJlZFVuaXRzLmluZGV4T2YoaykpIHtcbiAgICAgICAgICAgIGNvbnZlcnQodGhpcy5tYXRyaXgsIHZhbHMsIGRvd24sIGJ1aWx0LCBrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBrZWVwIGl0IGluIHRoZSB3aW5ncyB0byBib2lsIGl0IGxhdGVyXG4gICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gdmFsc1trXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbnl0aGluZyBsZWZ0b3ZlciBiZWNvbWVzIHRoZSBkZWNpbWFsIGZvciB0aGUgbGFzdCB1bml0XG4gICAgLy8gbGFzdFVuaXQgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIHVuaXRzIGlzIG5vdCBlbXB0eVxuICAgIGZvciAoY29uc3Qga2V5IGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICBpZiAoYWNjdW11bGF0ZWRba2V5XSAhPT0gMCkge1xuICAgICAgICBidWlsdFtsYXN0VW5pdF0gKz1cbiAgICAgICAgICBrZXkgPT09IGxhc3RVbml0ID8gYWNjdW11bGF0ZWRba2V5XSA6IGFjY3VtdWxhdGVkW2tleV0gLyB0aGlzLm1hdHJpeFtsYXN0VW5pdF1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IGJ1aWx0IH0sIHRydWUpLm5vcm1hbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmVnYXRpdmUgb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBzZWNvbmRzOiAzMCB9KS5uZWdhdGUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogLTEsIHNlY29uZHM6IC0zMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbmVnYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBuZWdhdGVkID0ge307XG4gICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKSkge1xuICAgICAgbmVnYXRlZFtrXSA9IC10aGlzLnZhbHVlc1trXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBuZWdhdGVkIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeWVhcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeWVhcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnllYXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBxdWFydGVycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBxdWFydGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMucXVhcnRlcnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRocy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtb250aHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1vbnRocyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2Vla3NcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMud2Vla3MgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheXMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuZGF5cyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaG91cnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaG91cnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLmhvdXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW51dGVzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1pbnV0ZXMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZHMuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBzZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5zZWNvbmRzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaWxsaXNlY29uZHMuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBtaWxsaXNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1pbGxpc2Vjb25kcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgRHVyYXRpb24gaXMgaW52YWxpZC4gSW52YWxpZCBkdXJhdGlvbnMgYXJlIHJldHVybmVkIGJ5IGRpZmYgb3BlcmF0aW9uc1xuICAgKiBvbiBpbnZhbGlkIERhdGVUaW1lcyBvciBJbnRlcnZhbHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIER1cmF0aW9uIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEdXJhdGlvbiBpcyB2YWxpZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEdXJhdGlvbiBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRHVyYXRpb24gaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRXF1YWxpdHkgY2hlY2tcbiAgICogVHdvIER1cmF0aW9ucyBhcmUgZXF1YWwgaWZmIHRoZXkgaGF2ZSB0aGUgc2FtZSB1bml0cyBhbmQgdGhlIHNhbWUgdmFsdWVzIGZvciBlYWNoIHVuaXQuXG4gICAqIEBwYXJhbSB7RHVyYXRpb259IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXIuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5sb2MuZXF1YWxzKG90aGVyLmxvYykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcSh2MSwgdjIpIHtcbiAgICAgIC8vIENvbnNpZGVyIDAgYW5kIHVuZGVmaW5lZCBhcyBlcXVhbFxuICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQgfHwgdjEgPT09IDApIHJldHVybiB2MiA9PT0gdW5kZWZpbmVkIHx8IHYyID09PSAwO1xuICAgICAgcmV0dXJuIHYxID09PSB2MjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHUgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAoIWVxKHRoaXMudmFsdWVzW3VdLCBvdGhlci52YWx1ZXNbdV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJpZW5kbHlEdXJhdGlvbihkdXJhdGlvbmlzaCkge1xuICBpZiAoaXNOdW1iZXIoZHVyYXRpb25pc2gpKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLmZyb21NaWxsaXMoZHVyYXRpb25pc2gpO1xuICB9IGVsc2UgaWYgKER1cmF0aW9uLmlzRHVyYXRpb24oZHVyYXRpb25pc2gpKSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uaXNoO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbmlzaCA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KGR1cmF0aW9uaXNoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICBgVW5rbm93biBkdXJhdGlvbiBhcmd1bWVudCAke2R1cmF0aW9uaXNofSBvZiB0eXBlICR7dHlwZW9mIGR1cmF0aW9uaXNofWBcbiAgICApO1xuICB9XG59XG4iXSwibmFtZXMiOlsiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJJbnZhbGlkRHVyYXRpb25FcnJvciIsIkludmFsaWRVbml0RXJyb3IiLCJGb3JtYXR0ZXIiLCJJbnZhbGlkIiwiTG9jYWxlIiwicGFyc2VJU09EdXJhdGlvbiIsInBhcnNlSVNPVGltZU9ubHkiLCJhc051bWJlciIsImhhc093blByb3BlcnR5IiwiaXNOdW1iZXIiLCJpc1VuZGVmaW5lZCIsIm5vcm1hbGl6ZU9iamVjdCIsInJvdW5kVG8iLCJTZXR0aW5ncyIsIklOVkFMSUQiLCJsb3dPcmRlck1hdHJpeCIsIndlZWtzIiwiZGF5cyIsImhvdXJzIiwibWludXRlcyIsInNlY29uZHMiLCJtaWxsaXNlY29uZHMiLCJjYXN1YWxNYXRyaXgiLCJPYmplY3QiLCJhc3NpZ24iLCJ5ZWFycyIsInF1YXJ0ZXJzIiwibW9udGhzIiwiZGF5c0luWWVhckFjY3VyYXRlIiwiZGF5c0luTW9udGhBY2N1cmF0ZSIsImFjY3VyYXRlTWF0cml4Iiwib3JkZXJlZFVuaXRzIiwicmV2ZXJzZVVuaXRzIiwic2xpY2UiLCJyZXZlcnNlIiwiY2xvbmUiLCJkdXIiLCJhbHRzIiwiY2xlYXIiLCJjb25mIiwidmFsdWVzIiwibG9jIiwiY29udmVyc2lvbkFjY3VyYWN5IiwiRHVyYXRpb24iLCJhbnRpVHJ1bmMiLCJuIiwiTWF0aCIsImZsb29yIiwiY2VpbCIsImNvbnZlcnQiLCJtYXRyaXgiLCJmcm9tTWFwIiwiZnJvbVVuaXQiLCJ0b01hcCIsInRvVW5pdCIsImNvbnYiLCJyYXciLCJzYW1lU2lnbiIsInNpZ24iLCJhZGRlZCIsImFicyIsInRydW5jIiwibm9ybWFsaXplVmFsdWVzIiwidmFscyIsInJlZHVjZSIsInByZXZpb3VzIiwiY3VycmVudCIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiYWNjdXJhdGUiLCJjcmVhdGUiLCJpbnZhbGlkIiwiaXNMdXhvbkR1cmF0aW9uIiwiZnJvbU1pbGxpcyIsImNvdW50Iiwib3B0cyIsImZyb21PYmplY3QiLCJvYmoiLCJub3JtYWxpemVVbml0IiwiZnJvbUlTTyIsInRleHQiLCJwYXJzZWQiLCJmcm9tSVNPVGltZSIsInJlYXNvbiIsImV4cGxhbmF0aW9uIiwidGhyb3dPbkludmFsaWQiLCJ1bml0Iiwibm9ybWFsaXplZCIsInllYXIiLCJxdWFydGVyIiwibW9udGgiLCJ3ZWVrIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInNlY29uZCIsIm1pbGxpc2Vjb25kIiwidG9Mb3dlckNhc2UiLCJpc0R1cmF0aW9uIiwibyIsImxvY2FsZSIsImlzVmFsaWQiLCJudW1iZXJpbmdTeXN0ZW0iLCJ0b0Zvcm1hdCIsImZtdCIsImZtdE9wdHMiLCJyb3VuZCIsImZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyIsInRvT2JqZWN0IiwiYmFzZSIsImluY2x1ZGVDb25maWciLCJ0b0lTTyIsInMiLCJ0b0lTT1RpbWUiLCJtaWxsaXMiLCJ0b01pbGxpcyIsInN1cHByZXNzTWlsbGlzZWNvbmRzIiwic3VwcHJlc3NTZWNvbmRzIiwiaW5jbHVkZVByZWZpeCIsImZvcm1hdCIsInZhbHVlIiwic2hpZnRUbyIsInN0ciIsInRvSlNPTiIsInRvU3RyaW5nIiwiYXMiLCJ2YWx1ZU9mIiwicGx1cyIsImR1cmF0aW9uIiwiZnJpZW5kbHlEdXJhdGlvbiIsInJlc3VsdCIsImsiLCJnZXQiLCJtaW51cyIsIm5lZ2F0ZSIsIm1hcFVuaXRzIiwiZm4iLCJrZXlzIiwic2V0IiwibWl4ZWQiLCJyZWNvbmZpZ3VyZSIsIk5hTiIsIm5vcm1hbGl6ZSIsInVuaXRzIiwibGVuZ3RoIiwibWFwIiwidSIsImJ1aWx0IiwiYWNjdW11bGF0ZWQiLCJsYXN0VW5pdCIsImluZGV4T2YiLCJvd24iLCJhayIsImkiLCJkb3duIiwia2V5IiwibmVnYXRlZCIsImludmFsaWRSZWFzb24iLCJpbnZhbGlkRXhwbGFuYXRpb24iLCJlcXVhbHMiLCJvdGhlciIsImVxIiwidjEiLCJ2MiIsInVuZGVmaW5lZCIsImR1cmF0aW9uaXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/duration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/errors.js":
/*!******************************************!*\
  !*** ./node_modules/luxon/src/errors.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConflictingSpecificationError: () => (/* binding */ ConflictingSpecificationError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDateTimeError: () => (/* binding */ InvalidDateTimeError),\n/* harmony export */   InvalidDurationError: () => (/* binding */ InvalidDurationError),\n/* harmony export */   InvalidIntervalError: () => (/* binding */ InvalidIntervalError),\n/* harmony export */   InvalidUnitError: () => (/* binding */ InvalidUnitError),\n/* harmony export */   ZoneIsAbstractError: () => (/* binding */ ZoneIsAbstractError)\n/* harmony export */ });\n// these aren't really private, but nor are they really useful to document\n/**\n * @private\n */ class LuxonError extends Error {\n}\n/**\n * @private\n */ class InvalidDateTimeError extends LuxonError {\n    constructor(reason){\n        super(`Invalid DateTime: ${reason.toMessage()}`);\n    }\n}\n/**\n * @private\n */ class InvalidIntervalError extends LuxonError {\n    constructor(reason){\n        super(`Invalid Interval: ${reason.toMessage()}`);\n    }\n}\n/**\n * @private\n */ class InvalidDurationError extends LuxonError {\n    constructor(reason){\n        super(`Invalid Duration: ${reason.toMessage()}`);\n    }\n}\n/**\n * @private\n */ class ConflictingSpecificationError extends LuxonError {\n}\n/**\n * @private\n */ class InvalidUnitError extends LuxonError {\n    constructor(unit){\n        super(`Invalid unit ${unit}`);\n    }\n}\n/**\n * @private\n */ class InvalidArgumentError extends LuxonError {\n}\n/**\n * @private\n */ class ZoneIsAbstractError extends LuxonError {\n    constructor(){\n        super(\"Zone is an abstract class\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsMEVBQTBFO0FBRTFFOztDQUVDLEdBQ0QsTUFBTUEsbUJBQW1CQztBQUFPO0FBRWhDOztDQUVDLEdBQ00sTUFBTUMsNkJBQTZCRjtJQUN4Q0csWUFBWUMsTUFBTSxDQUFFO1FBQ2xCLEtBQUssQ0FBQyxDQUFDLGtCQUFrQixFQUFFQSxPQUFPQyxTQUFTLEdBQUcsQ0FBQztJQUNqRDtBQUNGO0FBRUE7O0NBRUMsR0FDTSxNQUFNQyw2QkFBNkJOO0lBQ3hDRyxZQUFZQyxNQUFNLENBQUU7UUFDbEIsS0FBSyxDQUFDLENBQUMsa0JBQWtCLEVBQUVBLE9BQU9DLFNBQVMsR0FBRyxDQUFDO0lBQ2pEO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLE1BQU1FLDZCQUE2QlA7SUFDeENHLFlBQVlDLE1BQU0sQ0FBRTtRQUNsQixLQUFLLENBQUMsQ0FBQyxrQkFBa0IsRUFBRUEsT0FBT0MsU0FBUyxHQUFHLENBQUM7SUFDakQ7QUFDRjtBQUVBOztDQUVDLEdBQ00sTUFBTUcsc0NBQXNDUjtBQUFZO0FBRS9EOztDQUVDLEdBQ00sTUFBTVMseUJBQXlCVDtJQUNwQ0csWUFBWU8sSUFBSSxDQUFFO1FBQ2hCLEtBQUssQ0FBQyxDQUFDLGFBQWEsRUFBRUEsS0FBSyxDQUFDO0lBQzlCO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLE1BQU1DLDZCQUE2Qlg7QUFBWTtBQUV0RDs7Q0FFQyxHQUNNLE1BQU1ZLDRCQUE0Qlo7SUFDdkNHLGFBQWM7UUFDWixLQUFLLENBQUM7SUFDUjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWF0b29scy1uZXh0Ly4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9lcnJvcnMuanM/NGU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGVzZSBhcmVuJ3QgcmVhbGx5IHByaXZhdGUsIGJ1dCBub3IgYXJlIHRoZXkgcmVhbGx5IHVzZWZ1bCB0byBkb2N1bWVudFxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEx1eG9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRGF0ZVRpbWVFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBEYXRlVGltZTogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEludGVydmFsRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgSW50ZXJ2YWw6ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREdXJhdGlvbkVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIER1cmF0aW9uOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFVuaXRFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih1bml0KSB7XG4gICAgc3VwZXIoYEludmFsaWQgdW5pdCAke3VuaXR9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEFyZ3VtZW50RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFpvbmVJc0Fic3RyYWN0RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJab25lIGlzIGFuIGFic3RyYWN0IGNsYXNzXCIpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiTHV4b25FcnJvciIsIkVycm9yIiwiSW52YWxpZERhdGVUaW1lRXJyb3IiLCJjb25zdHJ1Y3RvciIsInJlYXNvbiIsInRvTWVzc2FnZSIsIkludmFsaWRJbnRlcnZhbEVycm9yIiwiSW52YWxpZER1cmF0aW9uRXJyb3IiLCJDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciIsIkludmFsaWRVbml0RXJyb3IiLCJ1bml0IiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJab25lSXNBYnN0cmFjdEVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/impl/conversions.js":
/*!****************************************************!*\
  !*** ./node_modules/luxon/src/impl/conversions.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gregorianToOrdinal: () => (/* binding */ gregorianToOrdinal),\n/* harmony export */   gregorianToWeek: () => (/* binding */ gregorianToWeek),\n/* harmony export */   hasInvalidGregorianData: () => (/* binding */ hasInvalidGregorianData),\n/* harmony export */   hasInvalidOrdinalData: () => (/* binding */ hasInvalidOrdinalData),\n/* harmony export */   hasInvalidTimeData: () => (/* binding */ hasInvalidTimeData),\n/* harmony export */   hasInvalidWeekData: () => (/* binding */ hasInvalidWeekData),\n/* harmony export */   ordinalToGregorian: () => (/* binding */ ordinalToGregorian),\n/* harmony export */   weekToGregorian: () => (/* binding */ weekToGregorian)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"(rsc)/./node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _invalid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invalid.js */ \"(rsc)/./node_modules/luxon/src/impl/invalid.js\");\n\n\nconst nonLeapLadder = [\n    0,\n    31,\n    59,\n    90,\n    120,\n    151,\n    181,\n    212,\n    243,\n    273,\n    304,\n    334\n], leapLadder = [\n    0,\n    31,\n    60,\n    91,\n    121,\n    152,\n    182,\n    213,\n    244,\n    274,\n    305,\n    335\n];\nfunction unitOutOfRange(unit, value) {\n    return new _invalid_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"unit out of range\", `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`);\n}\nfunction dayOfWeek(year, month, day) {\n    const js = new Date(Date.UTC(year, month - 1, day)).getUTCDay();\n    return js === 0 ? 7 : js;\n}\nfunction computeOrdinal(year, month, day) {\n    return day + ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.isLeapYear)(year) ? leapLadder : nonLeapLadder)[month - 1];\n}\nfunction uncomputeOrdinal(year, ordinal) {\n    const table = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.isLeapYear)(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i)=>i < ordinal), day = ordinal - table[month0];\n    return {\n        month: month0 + 1,\n        day\n    };\n}\n/**\n * @private\n */ function gregorianToWeek(gregObj) {\n    const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);\n    let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;\n    if (weekNumber < 1) {\n        weekYear = year - 1;\n        weekNumber = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.weeksInWeekYear)(weekYear);\n    } else if (weekNumber > (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.weeksInWeekYear)(year)) {\n        weekYear = year + 1;\n        weekNumber = 1;\n    } else {\n        weekYear = year;\n    }\n    return Object.assign({\n        weekYear,\n        weekNumber,\n        weekday\n    }, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.timeObject)(gregObj));\n}\nfunction weekToGregorian(weekData) {\n    const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.daysInYear)(weekYear);\n    let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;\n    if (ordinal < 1) {\n        year = weekYear - 1;\n        ordinal += (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.daysInYear)(year);\n    } else if (ordinal > yearInDays) {\n        year = weekYear + 1;\n        ordinal -= (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.daysInYear)(weekYear);\n    } else {\n        year = weekYear;\n    }\n    const { month, day } = uncomputeOrdinal(year, ordinal);\n    return Object.assign({\n        year,\n        month,\n        day\n    }, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.timeObject)(weekData));\n}\nfunction gregorianToOrdinal(gregData) {\n    const { year, month, day } = gregData, ordinal = computeOrdinal(year, month, day);\n    return Object.assign({\n        year,\n        ordinal\n    }, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.timeObject)(gregData));\n}\nfunction ordinalToGregorian(ordinalData) {\n    const { year, ordinal } = ordinalData, { month, day } = uncomputeOrdinal(year, ordinal);\n    return Object.assign({\n        year,\n        month,\n        day\n    }, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.timeObject)(ordinalData));\n}\nfunction hasInvalidWeekData(obj) {\n    const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.isInteger)(obj.weekYear), validWeek = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.integerBetween)(obj.weekNumber, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.weeksInWeekYear)(obj.weekYear)), validWeekday = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.integerBetween)(obj.weekday, 1, 7);\n    if (!validYear) {\n        return unitOutOfRange(\"weekYear\", obj.weekYear);\n    } else if (!validWeek) {\n        return unitOutOfRange(\"week\", obj.week);\n    } else if (!validWeekday) {\n        return unitOutOfRange(\"weekday\", obj.weekday);\n    } else return false;\n}\nfunction hasInvalidOrdinalData(obj) {\n    const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.isInteger)(obj.year), validOrdinal = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.integerBetween)(obj.ordinal, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.daysInYear)(obj.year));\n    if (!validYear) {\n        return unitOutOfRange(\"year\", obj.year);\n    } else if (!validOrdinal) {\n        return unitOutOfRange(\"ordinal\", obj.ordinal);\n    } else return false;\n}\nfunction hasInvalidGregorianData(obj) {\n    const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.isInteger)(obj.year), validMonth = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.integerBetween)(obj.month, 1, 12), validDay = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.integerBetween)(obj.day, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.daysInMonth)(obj.year, obj.month));\n    if (!validYear) {\n        return unitOutOfRange(\"year\", obj.year);\n    } else if (!validMonth) {\n        return unitOutOfRange(\"month\", obj.month);\n    } else if (!validDay) {\n        return unitOutOfRange(\"day\", obj.day);\n    } else return false;\n}\nfunction hasInvalidTimeData(obj) {\n    const { hour, minute, second, millisecond } = obj;\n    const validHour = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.integerBetween)(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.integerBetween)(minute, 0, 59), validSecond = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.integerBetween)(second, 0, 59), validMillisecond = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.integerBetween)(millisecond, 0, 999);\n    if (!validHour) {\n        return unitOutOfRange(\"hour\", hour);\n    } else if (!validMinute) {\n        return unitOutOfRange(\"minute\", minute);\n    } else if (!validSecond) {\n        return unitOutOfRange(\"second\", second);\n    } else if (!validMillisecond) {\n        return unitOutOfRange(\"millisecond\", millisecond);\n    } else return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvY29udmVyc2lvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQVFtQjtBQUNnQjtBQUVuQyxNQUFNUSxnQkFBZ0I7SUFBQztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7Q0FBSSxFQUMzRUMsYUFBYTtJQUFDO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztDQUFJO0FBRXRFLFNBQVNDLGVBQWVDLElBQUksRUFBRUMsS0FBSztJQUNqQyxPQUFPLElBQUlMLG1EQUFPQSxDQUNoQixxQkFDQSxDQUFDLGNBQWMsRUFBRUssTUFBTSxVQUFVLEVBQUUsT0FBT0EsTUFBTSxPQUFPLEVBQUVELEtBQUssa0JBQWtCLENBQUM7QUFFckY7QUFFQSxTQUFTRSxVQUFVQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsR0FBRztJQUNqQyxNQUFNQyxLQUFLLElBQUlDLEtBQUtBLEtBQUtDLEdBQUcsQ0FBQ0wsTUFBTUMsUUFBUSxHQUFHQyxNQUFNSSxTQUFTO0lBQzdELE9BQU9ILE9BQU8sSUFBSSxJQUFJQTtBQUN4QjtBQUVBLFNBQVNJLGVBQWVQLElBQUksRUFBRUMsS0FBSyxFQUFFQyxHQUFHO0lBQ3RDLE9BQU9BLE1BQU0sQ0FBQ2Ysb0RBQVVBLENBQUNhLFFBQVFMLGFBQWFELGFBQVksQ0FBRSxDQUFDTyxRQUFRLEVBQUU7QUFDekU7QUFFQSxTQUFTTyxpQkFBaUJSLElBQUksRUFBRVMsT0FBTztJQUNyQyxNQUFNQyxRQUFRdkIsb0RBQVVBLENBQUNhLFFBQVFMLGFBQWFELGVBQzVDaUIsU0FBU0QsTUFBTUUsU0FBUyxDQUFDQyxDQUFBQSxJQUFLQSxJQUFJSixVQUNsQ1AsTUFBTU8sVUFBVUMsS0FBSyxDQUFDQyxPQUFPO0lBQy9CLE9BQU87UUFBRVYsT0FBT1UsU0FBUztRQUFHVDtJQUFJO0FBQ2xD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QUFHLEtBQ3hDSyxjQUFjL0Qsd0RBQWNBLENBQUMyRCxRQUFRLEdBQUcsS0FDeENLLG1CQUFtQmhFLHdEQUFjQSxDQUFDNEQsYUFBYSxHQUFHO0lBRXBELElBQUksQ0FBQ0MsV0FBVztRQUNkLE9BQU9uRCxlQUFlLFFBQVErQztJQUNoQyxPQUFPLElBQUksQ0FBQ0ssYUFBYTtRQUN2QixPQUFPcEQsZUFBZSxVQUFVZ0Q7SUFDbEMsT0FBTyxJQUFJLENBQUNLLGFBQWE7UUFDdkIsT0FBT3JELGVBQWUsVUFBVWlEO0lBQ2xDLE9BQU8sSUFBSSxDQUFDSyxrQkFBa0I7UUFDNUIsT0FBT3RELGVBQWUsZUFBZWtEO0lBQ3ZDLE9BQU8sT0FBTztBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL2lhdG9vbHMtbmV4dC8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9jb252ZXJzaW9ucy5qcz82NThhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGludGVnZXJCZXR3ZWVuLFxuICBpc0xlYXBZZWFyLFxuICB0aW1lT2JqZWN0LFxuICBkYXlzSW5ZZWFyLFxuICBkYXlzSW5Nb250aCxcbiAgd2Vla3NJbldlZWtZZWFyLFxuICBpc0ludGVnZXJcbn0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW52YWxpZC5qc1wiO1xuXG5jb25zdCBub25MZWFwTGFkZGVyID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XSxcbiAgbGVhcExhZGRlciA9IFswLCAzMSwgNjAsIDkxLCAxMjEsIDE1MiwgMTgyLCAyMTMsIDI0NCwgMjc0LCAzMDUsIDMzNV07XG5cbmZ1bmN0aW9uIHVuaXRPdXRPZlJhbmdlKHVuaXQsIHZhbHVlKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcbiAgICBcInVuaXQgb3V0IG9mIHJhbmdlXCIsXG4gICAgYHlvdSBzcGVjaWZpZWQgJHt2YWx1ZX0gKG9mIHR5cGUgJHt0eXBlb2YgdmFsdWV9KSBhcyBhICR7dW5pdH0sIHdoaWNoIGlzIGludmFsaWRgXG4gICk7XG59XG5cbmZ1bmN0aW9uIGRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KSB7XG4gIGNvbnN0IGpzID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXkpKS5nZXRVVENEYXkoKTtcbiAgcmV0dXJuIGpzID09PSAwID8gNyA6IGpzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KSB7XG4gIHJldHVybiBkYXkgKyAoaXNMZWFwWWVhcih5ZWFyKSA/IGxlYXBMYWRkZXIgOiBub25MZWFwTGFkZGVyKVttb250aCAtIDFdO1xufVxuXG5mdW5jdGlvbiB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpIHtcbiAgY29uc3QgdGFibGUgPSBpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIsXG4gICAgbW9udGgwID0gdGFibGUuZmluZEluZGV4KGkgPT4gaSA8IG9yZGluYWwpLFxuICAgIGRheSA9IG9yZGluYWwgLSB0YWJsZVttb250aDBdO1xuICByZXR1cm4geyBtb250aDogbW9udGgwICsgMSwgZGF5IH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ3JlZ29yaWFuVG9XZWVrKGdyZWdPYmopIHtcbiAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBncmVnT2JqLFxuICAgIG9yZGluYWwgPSBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KSxcbiAgICB3ZWVrZGF5ID0gZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpO1xuXG4gIGxldCB3ZWVrTnVtYmVyID0gTWF0aC5mbG9vcigob3JkaW5hbCAtIHdlZWtkYXkgKyAxMCkgLyA3KSxcbiAgICB3ZWVrWWVhcjtcblxuICBpZiAod2Vla051bWJlciA8IDEpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgLSAxO1xuICAgIHdlZWtOdW1iZXIgPSB3ZWVrc0luV2Vla1llYXIod2Vla1llYXIpO1xuICB9IGVsc2UgaWYgKHdlZWtOdW1iZXIgPiB3ZWVrc0luV2Vla1llYXIoeWVhcikpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgKyAxO1xuICAgIHdlZWtOdW1iZXIgPSAxO1xuICB9IGVsc2Uge1xuICAgIHdlZWtZZWFyID0geWVhcjtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHsgd2Vla1llYXIsIHdlZWtOdW1iZXIsIHdlZWtkYXkgfSwgdGltZU9iamVjdChncmVnT2JqKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrVG9HcmVnb3JpYW4od2Vla0RhdGEpIHtcbiAgY29uc3QgeyB3ZWVrWWVhciwgd2Vla051bWJlciwgd2Vla2RheSB9ID0gd2Vla0RhdGEsXG4gICAgd2Vla2RheU9mSmFuNCA9IGRheU9mV2Vlayh3ZWVrWWVhciwgMSwgNCksXG4gICAgeWVhckluRGF5cyA9IGRheXNJblllYXIod2Vla1llYXIpO1xuXG4gIGxldCBvcmRpbmFsID0gd2Vla051bWJlciAqIDcgKyB3ZWVrZGF5IC0gd2Vla2RheU9mSmFuNCAtIDMsXG4gICAgeWVhcjtcblxuICBpZiAob3JkaW5hbCA8IDEpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgLSAxO1xuICAgIG9yZGluYWwgKz0gZGF5c0luWWVhcih5ZWFyKTtcbiAgfSBlbHNlIGlmIChvcmRpbmFsID4geWVhckluRGF5cykge1xuICAgIHllYXIgPSB3ZWVrWWVhciArIDE7XG4gICAgb3JkaW5hbCAtPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcbiAgfSBlbHNlIHtcbiAgICB5ZWFyID0gd2Vla1llYXI7XG4gIH1cblxuICBjb25zdCB7IG1vbnRoLCBkYXkgfSA9IHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCk7XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB5ZWFyLCBtb250aCwgZGF5IH0sIHRpbWVPYmplY3Qod2Vla0RhdGEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyZWdvcmlhblRvT3JkaW5hbChncmVnRGF0YSkge1xuICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGdyZWdEYXRhLFxuICAgIG9yZGluYWwgPSBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHllYXIsIG9yZGluYWwgfSwgdGltZU9iamVjdChncmVnRGF0YSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3JkaW5hbFRvR3JlZ29yaWFuKG9yZGluYWxEYXRhKSB7XG4gIGNvbnN0IHsgeWVhciwgb3JkaW5hbCB9ID0gb3JkaW5hbERhdGEsXG4gICAgeyBtb250aCwgZGF5IH0gPSB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpO1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHsgeWVhciwgbW9udGgsIGRheSB9LCB0aW1lT2JqZWN0KG9yZGluYWxEYXRhKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkV2Vla0RhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoud2Vla1llYXIpLFxuICAgIHZhbGlkV2VlayA9IGludGVnZXJCZXR3ZWVuKG9iai53ZWVrTnVtYmVyLCAxLCB3ZWVrc0luV2Vla1llYXIob2JqLndlZWtZZWFyKSksXG4gICAgdmFsaWRXZWVrZGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLndlZWtkYXksIDEsIDcpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1llYXJcIiwgb2JqLndlZWtZZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRXZWVrKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1wiLCBvYmoud2Vlayk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vla2RheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtkYXlcIiwgb2JqLndlZWtkYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZE9yZGluYWxEYXRhKG9iaikge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLnllYXIpLFxuICAgIHZhbGlkT3JkaW5hbCA9IGludGVnZXJCZXR3ZWVuKG9iai5vcmRpbmFsLCAxLCBkYXlzSW5ZZWFyKG9iai55ZWFyKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRPcmRpbmFsKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwib3JkaW5hbFwiLCBvYmoub3JkaW5hbCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICB2YWxpZE1vbnRoID0gaW50ZWdlckJldHdlZW4ob2JqLm1vbnRoLCAxLCAxMiksXG4gICAgdmFsaWREYXkgPSBpbnRlZ2VyQmV0d2VlbihvYmouZGF5LCAxLCBkYXlzSW5Nb250aChvYmoueWVhciwgb2JqLm1vbnRoKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNb250aCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1vbnRoXCIsIG9iai5tb250aCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkRGF5KSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwiZGF5XCIsIG9iai5kYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZFRpbWVEYXRhKG9iaikge1xuICBjb25zdCB7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9ID0gb2JqO1xuICBjb25zdCB2YWxpZEhvdXIgPVxuICAgICAgaW50ZWdlckJldHdlZW4oaG91ciwgMCwgMjMpIHx8XG4gICAgICAoaG91ciA9PT0gMjQgJiYgbWludXRlID09PSAwICYmIHNlY29uZCA9PT0gMCAmJiBtaWxsaXNlY29uZCA9PT0gMCksXG4gICAgdmFsaWRNaW51dGUgPSBpbnRlZ2VyQmV0d2VlbihtaW51dGUsIDAsIDU5KSxcbiAgICB2YWxpZFNlY29uZCA9IGludGVnZXJCZXR3ZWVuKHNlY29uZCwgMCwgNTkpLFxuICAgIHZhbGlkTWlsbGlzZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihtaWxsaXNlY29uZCwgMCwgOTk5KTtcblxuICBpZiAoIXZhbGlkSG91cikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImhvdXJcIiwgaG91cik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWludXRlKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWludXRlXCIsIG1pbnV0ZSk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkU2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwic2Vjb25kXCIsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWlsbGlzZWNvbmQpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtaWxsaXNlY29uZFwiLCBtaWxsaXNlY29uZCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG4iXSwibmFtZXMiOlsiaW50ZWdlckJldHdlZW4iLCJpc0xlYXBZZWFyIiwidGltZU9iamVjdCIsImRheXNJblllYXIiLCJkYXlzSW5Nb250aCIsIndlZWtzSW5XZWVrWWVhciIsImlzSW50ZWdlciIsIkludmFsaWQiLCJub25MZWFwTGFkZGVyIiwibGVhcExhZGRlciIsInVuaXRPdXRPZlJhbmdlIiwidW5pdCIsInZhbHVlIiwiZGF5T2ZXZWVrIiwieWVhciIsIm1vbnRoIiwiZGF5IiwianMiLCJEYXRlIiwiVVRDIiwiZ2V0VVRDRGF5IiwiY29tcHV0ZU9yZGluYWwiLCJ1bmNvbXB1dGVPcmRpbmFsIiwib3JkaW5hbCIsInRhYmxlIiwibW9udGgwIiwiZmluZEluZGV4IiwiaSIsImdyZWdvcmlhblRvV2VlayIsImdyZWdPYmoiLCJ3ZWVrZGF5Iiwid2Vla051bWJlciIsIk1hdGgiLCJmbG9vciIsIndlZWtZZWFyIiwiT2JqZWN0IiwiYXNzaWduIiwid2Vla1RvR3JlZ29yaWFuIiwid2Vla0RhdGEiLCJ3ZWVrZGF5T2ZKYW40IiwieWVhckluRGF5cyIsImdyZWdvcmlhblRvT3JkaW5hbCIsImdyZWdEYXRhIiwib3JkaW5hbFRvR3JlZ29yaWFuIiwib3JkaW5hbERhdGEiLCJoYXNJbnZhbGlkV2Vla0RhdGEiLCJvYmoiLCJ2YWxpZFllYXIiLCJ2YWxpZFdlZWsiLCJ2YWxpZFdlZWtkYXkiLCJ3ZWVrIiwiaGFzSW52YWxpZE9yZGluYWxEYXRhIiwidmFsaWRPcmRpbmFsIiwiaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEiLCJ2YWxpZE1vbnRoIiwidmFsaWREYXkiLCJoYXNJbnZhbGlkVGltZURhdGEiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwibWlsbGlzZWNvbmQiLCJ2YWxpZEhvdXIiLCJ2YWxpZE1pbnV0ZSIsInZhbGlkU2Vjb25kIiwidmFsaWRNaWxsaXNlY29uZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/impl/conversions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/impl/diff.js":
/*!*********************************************!*\
  !*** ./node_modules/luxon/src/impl/diff.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../duration.js */ \"(rsc)/./node_modules/luxon/src/duration.js\");\n\nfunction dayDiff(earlier, later) {\n    const utcDayStart = (dt)=>dt.toUTC(0, {\n            keepLocalTime: true\n        }).startOf(\"day\").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);\n    return Math.floor(_duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromMillis(ms).as(\"days\"));\n}\nfunction highOrderDiffs(cursor, later, units) {\n    const differs = [\n        [\n            \"years\",\n            (a, b)=>b.year - a.year\n        ],\n        [\n            \"quarters\",\n            (a, b)=>b.quarter - a.quarter\n        ],\n        [\n            \"months\",\n            (a, b)=>b.month - a.month + (b.year - a.year) * 12\n        ],\n        [\n            \"weeks\",\n            (a, b)=>{\n                const days = dayDiff(a, b);\n                return (days - days % 7) / 7;\n            }\n        ],\n        [\n            \"days\",\n            dayDiff\n        ]\n    ];\n    const results = {};\n    let lowestOrder, highWater;\n    for (const [unit, differ] of differs){\n        if (units.indexOf(unit) >= 0) {\n            lowestOrder = unit;\n            let delta = differ(cursor, later);\n            highWater = cursor.plus({\n                [unit]: delta\n            });\n            if (highWater > later) {\n                cursor = cursor.plus({\n                    [unit]: delta - 1\n                });\n                delta -= 1;\n            } else {\n                cursor = highWater;\n            }\n            results[unit] = delta;\n        }\n    }\n    return [\n        cursor,\n        results,\n        highWater,\n        lowestOrder\n    ];\n}\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(earlier, later, units, opts) {\n    let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);\n    const remainingMillis = later - cursor;\n    const lowerOrderUnits = units.filter((u)=>[\n            \"hours\",\n            \"minutes\",\n            \"seconds\",\n            \"milliseconds\"\n        ].indexOf(u) >= 0);\n    if (lowerOrderUnits.length === 0) {\n        if (highWater < later) {\n            highWater = cursor.plus({\n                [lowestOrder]: 1\n            });\n        }\n        if (highWater !== cursor) {\n            results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);\n        }\n    }\n    const duration = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromObject(Object.assign(results, opts));\n    if (lowerOrderUnits.length > 0) {\n        return _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);\n    } else {\n        return duration;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlmZi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFzQztBQUV0QyxTQUFTQyxRQUFRQyxPQUFPLEVBQUVDLEtBQUs7SUFDN0IsTUFBTUMsY0FBY0MsQ0FBQUEsS0FDaEJBLEdBQ0dDLEtBQUssQ0FBQyxHQUFHO1lBQUVDLGVBQWU7UUFBSyxHQUMvQkMsT0FBTyxDQUFDLE9BQ1JDLE9BQU8sSUFDWkMsS0FBS04sWUFBWUQsU0FBU0MsWUFBWUY7SUFDeEMsT0FBT1MsS0FBS0MsS0FBSyxDQUFDWixvREFBUUEsQ0FBQ2EsVUFBVSxDQUFDSCxJQUFJSSxFQUFFLENBQUM7QUFDL0M7QUFFQSxTQUFTQyxlQUFlQyxNQUFNLEVBQUViLEtBQUssRUFBRWMsS0FBSztJQUMxQyxNQUFNQyxVQUFVO1FBQ2Q7WUFBQztZQUFTLENBQUNDLEdBQUdDLElBQU1BLEVBQUVDLElBQUksR0FBR0YsRUFBRUUsSUFBSTtTQUFDO1FBQ3BDO1lBQUM7WUFBWSxDQUFDRixHQUFHQyxJQUFNQSxFQUFFRSxPQUFPLEdBQUdILEVBQUVHLE9BQU87U0FBQztRQUM3QztZQUFDO1lBQVUsQ0FBQ0gsR0FBR0MsSUFBTUEsRUFBRUcsS0FBSyxHQUFHSixFQUFFSSxLQUFLLEdBQUcsQ0FBQ0gsRUFBRUMsSUFBSSxHQUFHRixFQUFFRSxJQUFJLElBQUk7U0FBRztRQUNoRTtZQUNFO1lBQ0EsQ0FBQ0YsR0FBR0M7Z0JBQ0YsTUFBTUksT0FBT3ZCLFFBQVFrQixHQUFHQztnQkFDeEIsT0FBTyxDQUFDSSxPQUFRQSxPQUFPLENBQUMsSUFBSztZQUMvQjtTQUNEO1FBQ0Q7WUFBQztZQUFRdkI7U0FBUTtLQUNsQjtJQUVELE1BQU13QixVQUFVLENBQUM7SUFDakIsSUFBSUMsYUFBYUM7SUFFakIsS0FBSyxNQUFNLENBQUNDLE1BQU1DLE9BQU8sSUFBSVgsUUFBUztRQUNwQyxJQUFJRCxNQUFNYSxPQUFPLENBQUNGLFNBQVMsR0FBRztZQUM1QkYsY0FBY0U7WUFFZCxJQUFJRyxRQUFRRixPQUFPYixRQUFRYjtZQUMzQndCLFlBQVlYLE9BQU9nQixJQUFJLENBQUM7Z0JBQUUsQ0FBQ0osS0FBSyxFQUFFRztZQUFNO1lBRXhDLElBQUlKLFlBQVl4QixPQUFPO2dCQUNyQmEsU0FBU0EsT0FBT2dCLElBQUksQ0FBQztvQkFBRSxDQUFDSixLQUFLLEVBQUVHLFFBQVE7Z0JBQUU7Z0JBQ3pDQSxTQUFTO1lBQ1gsT0FBTztnQkFDTGYsU0FBU1c7WUFDWDtZQUVBRixPQUFPLENBQUNHLEtBQUssR0FBR0c7UUFDbEI7SUFDRjtJQUVBLE9BQU87UUFBQ2Y7UUFBUVM7UUFBU0U7UUFBV0Q7S0FBWTtBQUNsRDtBQUVBLDZCQUFlLG9DQUFTeEIsT0FBTyxFQUFFQyxLQUFLLEVBQUVjLEtBQUssRUFBRWdCLElBQUk7SUFDakQsSUFBSSxDQUFDakIsUUFBUVMsU0FBU0UsV0FBV0QsWUFBWSxHQUFHWCxlQUFlYixTQUFTQyxPQUFPYztJQUUvRSxNQUFNaUIsa0JBQWtCL0IsUUFBUWE7SUFFaEMsTUFBTW1CLGtCQUFrQmxCLE1BQU1tQixNQUFNLENBQ2xDQyxDQUFBQSxJQUFLO1lBQUM7WUFBUztZQUFXO1lBQVc7U0FBZSxDQUFDUCxPQUFPLENBQUNPLE1BQU07SUFHckUsSUFBSUYsZ0JBQWdCRyxNQUFNLEtBQUssR0FBRztRQUNoQyxJQUFJWCxZQUFZeEIsT0FBTztZQUNyQndCLFlBQVlYLE9BQU9nQixJQUFJLENBQUM7Z0JBQUUsQ0FBQ04sWUFBWSxFQUFFO1lBQUU7UUFDN0M7UUFFQSxJQUFJQyxjQUFjWCxRQUFRO1lBQ3hCUyxPQUFPLENBQUNDLFlBQVksR0FBRyxDQUFDRCxPQUFPLENBQUNDLFlBQVksSUFBSSxLQUFLUSxrQkFBbUJQLENBQUFBLFlBQVlYLE1BQUs7UUFDM0Y7SUFDRjtJQUVBLE1BQU11QixXQUFXdkMsb0RBQVFBLENBQUN3QyxVQUFVLENBQUNDLE9BQU9DLE1BQU0sQ0FBQ2pCLFNBQVNRO0lBRTVELElBQUlFLGdCQUFnQkcsTUFBTSxHQUFHLEdBQUc7UUFDOUIsT0FBT3RDLG9EQUFRQSxDQUFDYSxVQUFVLENBQUNxQixpQkFBaUJELE1BQ3pDVSxPQUFPLElBQUlSLGlCQUNYSCxJQUFJLENBQUNPO0lBQ1YsT0FBTztRQUNMLE9BQU9BO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2lhdG9vbHMtbmV4dC8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9kaWZmLmpzPzdiYzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuLi9kdXJhdGlvbi5qc1wiO1xuXG5mdW5jdGlvbiBkYXlEaWZmKGVhcmxpZXIsIGxhdGVyKSB7XG4gIGNvbnN0IHV0Y0RheVN0YXJ0ID0gZHQgPT5cbiAgICAgIGR0XG4gICAgICAgIC50b1VUQygwLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSlcbiAgICAgICAgLnN0YXJ0T2YoXCJkYXlcIilcbiAgICAgICAgLnZhbHVlT2YoKSxcbiAgICBtcyA9IHV0Y0RheVN0YXJ0KGxhdGVyKSAtIHV0Y0RheVN0YXJ0KGVhcmxpZXIpO1xuICByZXR1cm4gTWF0aC5mbG9vcihEdXJhdGlvbi5mcm9tTWlsbGlzKG1zKS5hcyhcImRheXNcIikpO1xufVxuXG5mdW5jdGlvbiBoaWdoT3JkZXJEaWZmcyhjdXJzb3IsIGxhdGVyLCB1bml0cykge1xuICBjb25zdCBkaWZmZXJzID0gW1xuICAgIFtcInllYXJzXCIsIChhLCBiKSA9PiBiLnllYXIgLSBhLnllYXJdLFxuICAgIFtcInF1YXJ0ZXJzXCIsIChhLCBiKSA9PiBiLnF1YXJ0ZXIgLSBhLnF1YXJ0ZXJdLFxuICAgIFtcIm1vbnRoc1wiLCAoYSwgYikgPT4gYi5tb250aCAtIGEubW9udGggKyAoYi55ZWFyIC0gYS55ZWFyKSAqIDEyXSxcbiAgICBbXG4gICAgICBcIndlZWtzXCIsXG4gICAgICAoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBkYXlzID0gZGF5RGlmZihhLCBiKTtcbiAgICAgICAgcmV0dXJuIChkYXlzIC0gKGRheXMgJSA3KSkgLyA3O1xuICAgICAgfVxuICAgIF0sXG4gICAgW1wiZGF5c1wiLCBkYXlEaWZmXVxuICBdO1xuXG4gIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgbGV0IGxvd2VzdE9yZGVyLCBoaWdoV2F0ZXI7XG5cbiAgZm9yIChjb25zdCBbdW5pdCwgZGlmZmVyXSBvZiBkaWZmZXJzKSB7XG4gICAgaWYgKHVuaXRzLmluZGV4T2YodW5pdCkgPj0gMCkge1xuICAgICAgbG93ZXN0T3JkZXIgPSB1bml0O1xuXG4gICAgICBsZXQgZGVsdGEgPSBkaWZmZXIoY3Vyc29yLCBsYXRlcik7XG4gICAgICBoaWdoV2F0ZXIgPSBjdXJzb3IucGx1cyh7IFt1bml0XTogZGVsdGEgfSk7XG5cbiAgICAgIGlmIChoaWdoV2F0ZXIgPiBsYXRlcikge1xuICAgICAgICBjdXJzb3IgPSBjdXJzb3IucGx1cyh7IFt1bml0XTogZGVsdGEgLSAxIH0pO1xuICAgICAgICBkZWx0YSAtPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yID0gaGlnaFdhdGVyO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRzW3VuaXRdID0gZGVsdGE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtjdXJzb3IsIHJlc3VsdHMsIGhpZ2hXYXRlciwgbG93ZXN0T3JkZXJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihlYXJsaWVyLCBsYXRlciwgdW5pdHMsIG9wdHMpIHtcbiAgbGV0IFtjdXJzb3IsIHJlc3VsdHMsIGhpZ2hXYXRlciwgbG93ZXN0T3JkZXJdID0gaGlnaE9yZGVyRGlmZnMoZWFybGllciwgbGF0ZXIsIHVuaXRzKTtcblxuICBjb25zdCByZW1haW5pbmdNaWxsaXMgPSBsYXRlciAtIGN1cnNvcjtcblxuICBjb25zdCBsb3dlck9yZGVyVW5pdHMgPSB1bml0cy5maWx0ZXIoXG4gICAgdSA9PiBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCJdLmluZGV4T2YodSkgPj0gMFxuICApO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGhpZ2hXYXRlciA8IGxhdGVyKSB7XG4gICAgICBoaWdoV2F0ZXIgPSBjdXJzb3IucGx1cyh7IFtsb3dlc3RPcmRlcl06IDEgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhpZ2hXYXRlciAhPT0gY3Vyc29yKSB7XG4gICAgICByZXN1bHRzW2xvd2VzdE9yZGVyXSA9IChyZXN1bHRzW2xvd2VzdE9yZGVyXSB8fCAwKSArIHJlbWFpbmluZ01pbGxpcyAvIChoaWdoV2F0ZXIgLSBjdXJzb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGR1cmF0aW9uID0gRHVyYXRpb24uZnJvbU9iamVjdChPYmplY3QuYXNzaWduKHJlc3VsdHMsIG9wdHMpKTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhyZW1haW5pbmdNaWxsaXMsIG9wdHMpXG4gICAgICAuc2hpZnRUbyguLi5sb3dlck9yZGVyVW5pdHMpXG4gICAgICAucGx1cyhkdXJhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRHVyYXRpb24iLCJkYXlEaWZmIiwiZWFybGllciIsImxhdGVyIiwidXRjRGF5U3RhcnQiLCJkdCIsInRvVVRDIiwia2VlcExvY2FsVGltZSIsInN0YXJ0T2YiLCJ2YWx1ZU9mIiwibXMiLCJNYXRoIiwiZmxvb3IiLCJmcm9tTWlsbGlzIiwiYXMiLCJoaWdoT3JkZXJEaWZmcyIsImN1cnNvciIsInVuaXRzIiwiZGlmZmVycyIsImEiLCJiIiwieWVhciIsInF1YXJ0ZXIiLCJtb250aCIsImRheXMiLCJyZXN1bHRzIiwibG93ZXN0T3JkZXIiLCJoaWdoV2F0ZXIiLCJ1bml0IiwiZGlmZmVyIiwiaW5kZXhPZiIsImRlbHRhIiwicGx1cyIsIm9wdHMiLCJyZW1haW5pbmdNaWxsaXMiLCJsb3dlck9yZGVyVW5pdHMiLCJmaWx0ZXIiLCJ1IiwibGVuZ3RoIiwiZHVyYXRpb24iLCJmcm9tT2JqZWN0IiwiT2JqZWN0IiwiYXNzaWduIiwic2hpZnRUbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/impl/diff.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/impl/digits.js":
/*!***********************************************!*\
  !*** ./node_modules/luxon/src/impl/digits.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   digitRegex: () => (/* binding */ digitRegex),\n/* harmony export */   parseDigits: () => (/* binding */ parseDigits)\n/* harmony export */ });\nconst numberingSystems = {\n    arab: \"[٠-٩]\",\n    arabext: \"[۰-۹]\",\n    bali: \"[᭐-᭙]\",\n    beng: \"[০-৯]\",\n    deva: \"[०-९]\",\n    fullwide: \"[０-９]\",\n    gujr: \"[૦-૯]\",\n    hanidec: \"[〇|一|二|三|四|五|六|七|八|九]\",\n    khmr: \"[០-៩]\",\n    knda: \"[೦-೯]\",\n    laoo: \"[໐-໙]\",\n    limb: \"[᥆-᥏]\",\n    mlym: \"[൦-൯]\",\n    mong: \"[᠐-᠙]\",\n    mymr: \"[၀-၉]\",\n    orya: \"[୦-୯]\",\n    tamldec: \"[௦-௯]\",\n    telu: \"[౦-౯]\",\n    thai: \"[๐-๙]\",\n    tibt: \"[༠-༩]\",\n    latn: \"\\\\d\"\n};\nconst numberingSystemsUTF16 = {\n    arab: [\n        1632,\n        1641\n    ],\n    arabext: [\n        1776,\n        1785\n    ],\n    bali: [\n        6992,\n        7001\n    ],\n    beng: [\n        2534,\n        2543\n    ],\n    deva: [\n        2406,\n        2415\n    ],\n    fullwide: [\n        65296,\n        65303\n    ],\n    gujr: [\n        2790,\n        2799\n    ],\n    khmr: [\n        6112,\n        6121\n    ],\n    knda: [\n        3302,\n        3311\n    ],\n    laoo: [\n        3792,\n        3801\n    ],\n    limb: [\n        6470,\n        6479\n    ],\n    mlym: [\n        3430,\n        3439\n    ],\n    mong: [\n        6160,\n        6169\n    ],\n    mymr: [\n        4160,\n        4169\n    ],\n    orya: [\n        2918,\n        2927\n    ],\n    tamldec: [\n        3046,\n        3055\n    ],\n    telu: [\n        3174,\n        3183\n    ],\n    thai: [\n        3664,\n        3673\n    ],\n    tibt: [\n        3872,\n        3881\n    ]\n};\n// eslint-disable-next-line\nconst hanidecChars = numberingSystems.hanidec.replace(/[\\[|\\]]/g, \"\").split(\"\");\nfunction parseDigits(str) {\n    let value = parseInt(str, 10);\n    if (isNaN(value)) {\n        value = \"\";\n        for(let i = 0; i < str.length; i++){\n            const code = str.charCodeAt(i);\n            if (str[i].search(numberingSystems.hanidec) !== -1) {\n                value += hanidecChars.indexOf(str[i]);\n            } else {\n                for(const key in numberingSystemsUTF16){\n                    const [min, max] = numberingSystemsUTF16[key];\n                    if (code >= min && code <= max) {\n                        value += code - min;\n                    }\n                }\n            }\n        }\n        return parseInt(value, 10);\n    } else {\n        return value;\n    }\n}\nfunction digitRegex({ numberingSystem }, append = \"\") {\n    return new RegExp(`${numberingSystems[numberingSystem || \"latn\"]}${append}`);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlnaXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsTUFBTUEsbUJBQW1CO0lBQ3ZCQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsVUFBVTtJQUNWQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsTUFBTTtBQUNSO0FBRUEsTUFBTUMsd0JBQXdCO0lBQzVCckIsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsU0FBUztRQUFDO1FBQU07S0FBSztJQUNyQkMsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsVUFBVTtRQUFDO1FBQU87S0FBTTtJQUN4QkMsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkUsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsU0FBUztRQUFDO1FBQU07S0FBSztJQUNyQkMsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsTUFBTTtRQUFDO1FBQU07S0FBSztJQUNsQkMsTUFBTTtRQUFDO1FBQU07S0FBSztBQUNwQjtBQUVBLDJCQUEyQjtBQUMzQixNQUFNRyxlQUFldkIsaUJBQWlCUSxPQUFPLENBQUNnQixPQUFPLENBQUMsWUFBWSxJQUFJQyxLQUFLLENBQUM7QUFFckUsU0FBU0MsWUFBWUMsR0FBRztJQUM3QixJQUFJQyxRQUFRQyxTQUFTRixLQUFLO0lBQzFCLElBQUlHLE1BQU1GLFFBQVE7UUFDaEJBLFFBQVE7UUFDUixJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSUosSUFBSUssTUFBTSxFQUFFRCxJQUFLO1lBQ25DLE1BQU1FLE9BQU9OLElBQUlPLFVBQVUsQ0FBQ0g7WUFFNUIsSUFBSUosR0FBRyxDQUFDSSxFQUFFLENBQUNJLE1BQU0sQ0FBQ25DLGlCQUFpQlEsT0FBTyxNQUFNLENBQUMsR0FBRztnQkFDbERvQixTQUFTTCxhQUFhYSxPQUFPLENBQUNULEdBQUcsQ0FBQ0ksRUFBRTtZQUN0QyxPQUFPO2dCQUNMLElBQUssTUFBTU0sT0FBT2Ysc0JBQXVCO29CQUN2QyxNQUFNLENBQUNnQixLQUFLQyxJQUFJLEdBQUdqQixxQkFBcUIsQ0FBQ2UsSUFBSTtvQkFDN0MsSUFBSUosUUFBUUssT0FBT0wsUUFBUU0sS0FBSzt3QkFDOUJYLFNBQVNLLE9BQU9LO29CQUNsQjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxPQUFPVCxTQUFTRCxPQUFPO0lBQ3pCLE9BQU87UUFDTCxPQUFPQTtJQUNUO0FBQ0Y7QUFFTyxTQUFTWSxXQUFXLEVBQUVDLGVBQWUsRUFBRSxFQUFFQyxTQUFTLEVBQUU7SUFDekQsT0FBTyxJQUFJQyxPQUFPLENBQUMsRUFBRTNDLGdCQUFnQixDQUFDeUMsbUJBQW1CLE9BQU8sQ0FBQyxFQUFFQyxPQUFPLENBQUM7QUFDN0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pYXRvb2xzLW5leHQvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlnaXRzLmpzPzg5NTMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbnVtYmVyaW5nU3lzdGVtcyA9IHtcbiAgYXJhYjogXCJbXFx1MDY2MC1cXHUwNjY5XVwiLFxuICBhcmFiZXh0OiBcIltcXHUwNkYwLVxcdTA2RjldXCIsXG4gIGJhbGk6IFwiW1xcdTFCNTAtXFx1MUI1OV1cIixcbiAgYmVuZzogXCJbXFx1MDlFNi1cXHUwOUVGXVwiLFxuICBkZXZhOiBcIltcXHUwOTY2LVxcdTA5NkZdXCIsXG4gIGZ1bGx3aWRlOiBcIltcXHVGRjEwLVxcdUZGMTldXCIsXG4gIGd1anI6IFwiW1xcdTBBRTYtXFx1MEFFRl1cIixcbiAgaGFuaWRlYzogXCJb44CHfOS4gHzkuox85LiJfOWbm3zkupR85YWtfOS4g3zlhat85LmdXVwiLFxuICBraG1yOiBcIltcXHUxN0UwLVxcdTE3RTldXCIsXG4gIGtuZGE6IFwiW1xcdTBDRTYtXFx1MENFRl1cIixcbiAgbGFvbzogXCJbXFx1MEVEMC1cXHUwRUQ5XVwiLFxuICBsaW1iOiBcIltcXHUxOTQ2LVxcdTE5NEZdXCIsXG4gIG1seW06IFwiW1xcdTBENjYtXFx1MEQ2Rl1cIixcbiAgbW9uZzogXCJbXFx1MTgxMC1cXHUxODE5XVwiLFxuICBteW1yOiBcIltcXHUxMDQwLVxcdTEwNDldXCIsXG4gIG9yeWE6IFwiW1xcdTBCNjYtXFx1MEI2Rl1cIixcbiAgdGFtbGRlYzogXCJbXFx1MEJFNi1cXHUwQkVGXVwiLFxuICB0ZWx1OiBcIltcXHUwQzY2LVxcdTBDNkZdXCIsXG4gIHRoYWk6IFwiW1xcdTBFNTAtXFx1MEU1OV1cIixcbiAgdGlidDogXCJbXFx1MEYyMC1cXHUwRjI5XVwiLFxuICBsYXRuOiBcIlxcXFxkXCJcbn07XG5cbmNvbnN0IG51bWJlcmluZ1N5c3RlbXNVVEYxNiA9IHtcbiAgYXJhYjogWzE2MzIsIDE2NDFdLFxuICBhcmFiZXh0OiBbMTc3NiwgMTc4NV0sXG4gIGJhbGk6IFs2OTkyLCA3MDAxXSxcbiAgYmVuZzogWzI1MzQsIDI1NDNdLFxuICBkZXZhOiBbMjQwNiwgMjQxNV0sXG4gIGZ1bGx3aWRlOiBbNjUyOTYsIDY1MzAzXSxcbiAgZ3VqcjogWzI3OTAsIDI3OTldLFxuICBraG1yOiBbNjExMiwgNjEyMV0sXG4gIGtuZGE6IFszMzAyLCAzMzExXSxcbiAgbGFvbzogWzM3OTIsIDM4MDFdLFxuICBsaW1iOiBbNjQ3MCwgNjQ3OV0sXG4gIG1seW06IFszNDMwLCAzNDM5XSxcbiAgbW9uZzogWzYxNjAsIDYxNjldLFxuICBteW1yOiBbNDE2MCwgNDE2OV0sXG4gIG9yeWE6IFsyOTE4LCAyOTI3XSxcbiAgdGFtbGRlYzogWzMwNDYsIDMwNTVdLFxuICB0ZWx1OiBbMzE3NCwgMzE4M10sXG4gIHRoYWk6IFszNjY0LCAzNjczXSxcbiAgdGlidDogWzM4NzIsIDM4ODFdXG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmNvbnN0IGhhbmlkZWNDaGFycyA9IG51bWJlcmluZ1N5c3RlbXMuaGFuaWRlYy5yZXBsYWNlKC9bXFxbfFxcXV0vZywgXCJcIikuc3BsaXQoXCJcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURpZ2l0cyhzdHIpIHtcbiAgbGV0IHZhbHVlID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKHN0cltpXS5zZWFyY2gobnVtYmVyaW5nU3lzdGVtcy5oYW5pZGVjKSAhPT0gLTEpIHtcbiAgICAgICAgdmFsdWUgKz0gaGFuaWRlY0NoYXJzLmluZGV4T2Yoc3RyW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG51bWJlcmluZ1N5c3RlbXNVVEYxNikge1xuICAgICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSBudW1iZXJpbmdTeXN0ZW1zVVRGMTZba2V5XTtcbiAgICAgICAgICBpZiAoY29kZSA+PSBtaW4gJiYgY29kZSA8PSBtYXgpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IGNvZGUgLSBtaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlnaXRSZWdleCh7IG51bWJlcmluZ1N5c3RlbSB9LCBhcHBlbmQgPSBcIlwiKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKGAke251bWJlcmluZ1N5c3RlbXNbbnVtYmVyaW5nU3lzdGVtIHx8IFwibGF0blwiXX0ke2FwcGVuZH1gKTtcbn1cbiJdLCJuYW1lcyI6WyJudW1iZXJpbmdTeXN0ZW1zIiwiYXJhYiIsImFyYWJleHQiLCJiYWxpIiwiYmVuZyIsImRldmEiLCJmdWxsd2lkZSIsImd1anIiLCJoYW5pZGVjIiwia2htciIsImtuZGEiLCJsYW9vIiwibGltYiIsIm1seW0iLCJtb25nIiwibXltciIsIm9yeWEiLCJ0YW1sZGVjIiwidGVsdSIsInRoYWkiLCJ0aWJ0IiwibGF0biIsIm51bWJlcmluZ1N5c3RlbXNVVEYxNiIsImhhbmlkZWNDaGFycyIsInJlcGxhY2UiLCJzcGxpdCIsInBhcnNlRGlnaXRzIiwic3RyIiwidmFsdWUiLCJwYXJzZUludCIsImlzTmFOIiwiaSIsImxlbmd0aCIsImNvZGUiLCJjaGFyQ29kZUF0Iiwic2VhcmNoIiwiaW5kZXhPZiIsImtleSIsIm1pbiIsIm1heCIsImRpZ2l0UmVnZXgiLCJudW1iZXJpbmdTeXN0ZW0iLCJhcHBlbmQiLCJSZWdFeHAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/impl/digits.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/impl/english.js":
/*!************************************************!*\
  !*** ./node_modules/luxon/src/impl/english.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eraForDateTime: () => (/* binding */ eraForDateTime),\n/* harmony export */   eras: () => (/* binding */ eras),\n/* harmony export */   erasLong: () => (/* binding */ erasLong),\n/* harmony export */   erasNarrow: () => (/* binding */ erasNarrow),\n/* harmony export */   erasShort: () => (/* binding */ erasShort),\n/* harmony export */   formatRelativeTime: () => (/* binding */ formatRelativeTime),\n/* harmony export */   formatString: () => (/* binding */ formatString),\n/* harmony export */   meridiemForDateTime: () => (/* binding */ meridiemForDateTime),\n/* harmony export */   meridiems: () => (/* binding */ meridiems),\n/* harmony export */   monthForDateTime: () => (/* binding */ monthForDateTime),\n/* harmony export */   months: () => (/* binding */ months),\n/* harmony export */   monthsLong: () => (/* binding */ monthsLong),\n/* harmony export */   monthsNarrow: () => (/* binding */ monthsNarrow),\n/* harmony export */   monthsShort: () => (/* binding */ monthsShort),\n/* harmony export */   weekdayForDateTime: () => (/* binding */ weekdayForDateTime),\n/* harmony export */   weekdays: () => (/* binding */ weekdays),\n/* harmony export */   weekdaysLong: () => (/* binding */ weekdaysLong),\n/* harmony export */   weekdaysNarrow: () => (/* binding */ weekdaysNarrow),\n/* harmony export */   weekdaysShort: () => (/* binding */ weekdaysShort)\n/* harmony export */ });\n/* harmony import */ var _formats_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formats.js */ \"(rsc)/./node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(rsc)/./node_modules/luxon/src/impl/util.js\");\n\n\nfunction stringify(obj) {\n    return JSON.stringify(obj, Object.keys(obj).sort());\n}\n/**\n * @private\n */ const monthsLong = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n];\nconst monthsShort = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\"\n];\nconst monthsNarrow = [\n    \"J\",\n    \"F\",\n    \"M\",\n    \"A\",\n    \"M\",\n    \"J\",\n    \"J\",\n    \"A\",\n    \"S\",\n    \"O\",\n    \"N\",\n    \"D\"\n];\nfunction months(length) {\n    switch(length){\n        case \"narrow\":\n            return [\n                ...monthsNarrow\n            ];\n        case \"short\":\n            return [\n                ...monthsShort\n            ];\n        case \"long\":\n            return [\n                ...monthsLong\n            ];\n        case \"numeric\":\n            return [\n                \"1\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"7\",\n                \"8\",\n                \"9\",\n                \"10\",\n                \"11\",\n                \"12\"\n            ];\n        case \"2-digit\":\n            return [\n                \"01\",\n                \"02\",\n                \"03\",\n                \"04\",\n                \"05\",\n                \"06\",\n                \"07\",\n                \"08\",\n                \"09\",\n                \"10\",\n                \"11\",\n                \"12\"\n            ];\n        default:\n            return null;\n    }\n}\nconst weekdaysLong = [\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\"\n];\nconst weekdaysShort = [\n    \"Mon\",\n    \"Tue\",\n    \"Wed\",\n    \"Thu\",\n    \"Fri\",\n    \"Sat\",\n    \"Sun\"\n];\nconst weekdaysNarrow = [\n    \"M\",\n    \"T\",\n    \"W\",\n    \"T\",\n    \"F\",\n    \"S\",\n    \"S\"\n];\nfunction weekdays(length) {\n    switch(length){\n        case \"narrow\":\n            return [\n                ...weekdaysNarrow\n            ];\n        case \"short\":\n            return [\n                ...weekdaysShort\n            ];\n        case \"long\":\n            return [\n                ...weekdaysLong\n            ];\n        case \"numeric\":\n            return [\n                \"1\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"7\"\n            ];\n        default:\n            return null;\n    }\n}\nconst meridiems = [\n    \"AM\",\n    \"PM\"\n];\nconst erasLong = [\n    \"Before Christ\",\n    \"Anno Domini\"\n];\nconst erasShort = [\n    \"BC\",\n    \"AD\"\n];\nconst erasNarrow = [\n    \"B\",\n    \"A\"\n];\nfunction eras(length) {\n    switch(length){\n        case \"narrow\":\n            return [\n                ...erasNarrow\n            ];\n        case \"short\":\n            return [\n                ...erasShort\n            ];\n        case \"long\":\n            return [\n                ...erasLong\n            ];\n        default:\n            return null;\n    }\n}\nfunction meridiemForDateTime(dt) {\n    return meridiems[dt.hour < 12 ? 0 : 1];\n}\nfunction weekdayForDateTime(dt, length) {\n    return weekdays(length)[dt.weekday - 1];\n}\nfunction monthForDateTime(dt, length) {\n    return months(length)[dt.month - 1];\n}\nfunction eraForDateTime(dt, length) {\n    return eras(length)[dt.year < 0 ? 0 : 1];\n}\nfunction formatRelativeTime(unit, count, numeric = \"always\", narrow = false) {\n    const units = {\n        years: [\n            \"year\",\n            \"yr.\"\n        ],\n        quarters: [\n            \"quarter\",\n            \"qtr.\"\n        ],\n        months: [\n            \"month\",\n            \"mo.\"\n        ],\n        weeks: [\n            \"week\",\n            \"wk.\"\n        ],\n        days: [\n            \"day\",\n            \"day\",\n            \"days\"\n        ],\n        hours: [\n            \"hour\",\n            \"hr.\"\n        ],\n        minutes: [\n            \"minute\",\n            \"min.\"\n        ],\n        seconds: [\n            \"second\",\n            \"sec.\"\n        ]\n    };\n    const lastable = [\n        \"hours\",\n        \"minutes\",\n        \"seconds\"\n    ].indexOf(unit) === -1;\n    if (numeric === \"auto\" && lastable) {\n        const isDay = unit === \"days\";\n        switch(count){\n            case 1:\n                return isDay ? \"tomorrow\" : `next ${units[unit][0]}`;\n            case -1:\n                return isDay ? \"yesterday\" : `last ${units[unit][0]}`;\n            case 0:\n                return isDay ? \"today\" : `this ${units[unit][0]}`;\n            default:\n        }\n    }\n    const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;\n    return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;\n}\nfunction formatString(knownFormat) {\n    // these all have the offsets removed because we don't have access to them\n    // without all the intl stuff this is backfilling\n    const filtered = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pick)(knownFormat, [\n        \"weekday\",\n        \"era\",\n        \"year\",\n        \"month\",\n        \"day\",\n        \"hour\",\n        \"minute\",\n        \"second\",\n        \"timeZoneName\",\n        \"hour12\"\n    ]), key = stringify(filtered), dateTimeHuge = \"EEEE, LLLL d, yyyy, h:mm a\";\n    switch(key){\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_SHORT):\n            return \"M/d/yyyy\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_MED):\n            return \"LLL d, yyyy\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_MED_WITH_WEEKDAY):\n            return \"EEE, LLL d, yyyy\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_FULL):\n            return \"LLLL d, yyyy\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_HUGE):\n            return \"EEEE, LLLL d, yyyy\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_SIMPLE):\n            return \"h:mm a\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_SECONDS):\n            return \"h:mm:ss a\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_SHORT_OFFSET):\n            return \"h:mm a\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_LONG_OFFSET):\n            return \"h:mm a\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_SIMPLE):\n            return \"HH:mm\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_SECONDS):\n            return \"HH:mm:ss\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_SHORT_OFFSET):\n            return \"HH:mm\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_LONG_OFFSET):\n            return \"HH:mm\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_SHORT):\n            return \"M/d/yyyy, h:mm a\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_MED):\n            return \"LLL d, yyyy, h:mm a\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_FULL):\n            return \"LLLL d, yyyy, h:mm a\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_HUGE):\n            return dateTimeHuge;\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_SHORT_WITH_SECONDS):\n            return \"M/d/yyyy, h:mm:ss a\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_MED_WITH_SECONDS):\n            return \"LLL d, yyyy, h:mm:ss a\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_MED_WITH_WEEKDAY):\n            return \"EEE, d LLL yyyy, h:mm a\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_FULL_WITH_SECONDS):\n            return \"LLLL d, yyyy, h:mm:ss a\";\n        case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_HUGE_WITH_SECONDS):\n            return \"EEEE, LLLL d, yyyy, h:mm:ss a\";\n        default:\n            return dateTimeHuge;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZW5nbGlzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDUDtBQUVqQyxTQUFTRSxVQUFVQyxHQUFHO0lBQ3BCLE9BQU9DLEtBQUtGLFNBQVMsQ0FBQ0MsS0FBS0UsT0FBT0MsSUFBSSxDQUFDSCxLQUFLSSxJQUFJO0FBQ2xEO0FBRUE7O0NBRUMsR0FFTSxNQUFNQyxhQUFhO0lBQ3hCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNELENBQUM7QUFFSyxNQUFNQyxjQUFjO0lBQ3pCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNELENBQUM7QUFFSyxNQUFNQyxlQUFlO0lBQUM7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUksQ0FBQztBQUVsRixTQUFTQyxPQUFPQyxNQUFNO0lBQzNCLE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU87bUJBQUlGO2FBQWE7UUFDMUIsS0FBSztZQUNILE9BQU87bUJBQUlEO2FBQVk7UUFDekIsS0FBSztZQUNILE9BQU87bUJBQUlEO2FBQVc7UUFDeEIsS0FBSztZQUNILE9BQU87Z0JBQUM7Z0JBQUs7Z0JBQUs7Z0JBQUs7Z0JBQUs7Z0JBQUs7Z0JBQUs7Z0JBQUs7Z0JBQUs7Z0JBQUs7Z0JBQU07Z0JBQU07YUFBSztRQUN4RSxLQUFLO1lBQ0gsT0FBTztnQkFBQztnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTthQUFLO1FBQ2pGO1lBQ0UsT0FBTztJQUNYO0FBQ0Y7QUFFTyxNQUFNSyxlQUFlO0lBQzFCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0QsQ0FBQztBQUVL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QVVGLGtFQUFpQztZQUM5QyxPQUFPO1FBQ1QsS0FBS0UsVUFBVUYsaUVBQWdDO1lBQzdDLE9BQU87UUFDVCxLQUFLRSxVQUFVRix1REFBc0I7WUFDbkMsT0FBTztRQUNULEtBQUtFLFVBQVVGLHFEQUFvQjtZQUNqQyxPQUFPO1FBQ1QsS0FBS0UsVUFBVUYsc0RBQXFCO1lBQ2xDLE9BQU87UUFDVCxLQUFLRSxVQUFVRixzREFBcUI7WUFDbEMsT0FBTzJEO1FBQ1QsS0FBS3pELFVBQVVGLG9FQUFtQztZQUNoRCxPQUFPO1FBQ1QsS0FBS0UsVUFBVUYsa0VBQWlDO1lBQzlDLE9BQU87UUFDVCxLQUFLRSxVQUFVRixrRUFBaUM7WUFDOUMsT0FBTztRQUNULEtBQUtFLFVBQVVGLG1FQUFrQztZQUMvQyxPQUFPO1FBQ1QsS0FBS0UsVUFBVUYsbUVBQWtDO1lBQy9DLE9BQU87UUFDVDtZQUNFLE9BQU8yRDtJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pYXRvb2xzLW5leHQvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZW5nbGlzaC5qcz84MDY3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgcGljayB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBPYmplY3Qua2V5cyhvYmopLnNvcnQoKSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgY29uc3QgbW9udGhzTG9uZyA9IFtcbiAgXCJKYW51YXJ5XCIsXG4gIFwiRmVicnVhcnlcIixcbiAgXCJNYXJjaFwiLFxuICBcIkFwcmlsXCIsXG4gIFwiTWF5XCIsXG4gIFwiSnVuZVwiLFxuICBcIkp1bHlcIixcbiAgXCJBdWd1c3RcIixcbiAgXCJTZXB0ZW1iZXJcIixcbiAgXCJPY3RvYmVyXCIsXG4gIFwiTm92ZW1iZXJcIixcbiAgXCJEZWNlbWJlclwiXG5dO1xuXG5leHBvcnQgY29uc3QgbW9udGhzU2hvcnQgPSBbXG4gIFwiSmFuXCIsXG4gIFwiRmViXCIsXG4gIFwiTWFyXCIsXG4gIFwiQXByXCIsXG4gIFwiTWF5XCIsXG4gIFwiSnVuXCIsXG4gIFwiSnVsXCIsXG4gIFwiQXVnXCIsXG4gIFwiU2VwXCIsXG4gIFwiT2N0XCIsXG4gIFwiTm92XCIsXG4gIFwiRGVjXCJcbl07XG5cbmV4cG9ydCBjb25zdCBtb250aHNOYXJyb3cgPSBbXCJKXCIsIFwiRlwiLCBcIk1cIiwgXCJBXCIsIFwiTVwiLCBcIkpcIiwgXCJKXCIsIFwiQVwiLCBcIlNcIiwgXCJPXCIsIFwiTlwiLCBcIkRcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb250aHMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzTG9uZ107XG4gICAgY2FzZSBcIm51bWVyaWNcIjpcbiAgICAgIHJldHVybiBbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIl07XG4gICAgY2FzZSBcIjItZGlnaXRcIjpcbiAgICAgIHJldHVybiBbXCIwMVwiLCBcIjAyXCIsIFwiMDNcIiwgXCIwNFwiLCBcIjA1XCIsIFwiMDZcIiwgXCIwN1wiLCBcIjA4XCIsIFwiMDlcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c0xvbmcgPSBbXG4gIFwiTW9uZGF5XCIsXG4gIFwiVHVlc2RheVwiLFxuICBcIldlZG5lc2RheVwiLFxuICBcIlRodXJzZGF5XCIsXG4gIFwiRnJpZGF5XCIsXG4gIFwiU2F0dXJkYXlcIixcbiAgXCJTdW5kYXlcIlxuXTtcblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzU2hvcnQgPSBbXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIl07XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c05hcnJvdyA9IFtcIk1cIiwgXCJUXCIsIFwiV1wiLCBcIlRcIiwgXCJGXCIsIFwiU1wiLCBcIlNcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5cyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNMb25nXTtcbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZXJpZGllbXMgPSBbXCJBTVwiLCBcIlBNXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc0xvbmcgPSBbXCJCZWZvcmUgQ2hyaXN0XCIsIFwiQW5ubyBEb21pbmlcIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzU2hvcnQgPSBbXCJCQ1wiLCBcIkFEXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc05hcnJvdyA9IFtcIkJcIiwgXCJBXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gZXJhcyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNMb25nXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpIHtcbiAgcmV0dXJuIG1lcmlkaWVtc1tkdC5ob3VyIDwgMTIgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gd2Vla2RheXMobGVuZ3RoKVtkdC53ZWVrZGF5IC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG1vbnRocyhsZW5ndGgpW2R0Lm1vbnRoIC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBlcmFzKGxlbmd0aClbZHQueWVhciA8IDAgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRSZWxhdGl2ZVRpbWUodW5pdCwgY291bnQsIG51bWVyaWMgPSBcImFsd2F5c1wiLCBuYXJyb3cgPSBmYWxzZSkge1xuICBjb25zdCB1bml0cyA9IHtcbiAgICB5ZWFyczogW1wieWVhclwiLCBcInlyLlwiXSxcbiAgICBxdWFydGVyczogW1wicXVhcnRlclwiLCBcInF0ci5cIl0sXG4gICAgbW9udGhzOiBbXCJtb250aFwiLCBcIm1vLlwiXSxcbiAgICB3ZWVrczogW1wid2Vla1wiLCBcIndrLlwiXSxcbiAgICBkYXlzOiBbXCJkYXlcIiwgXCJkYXlcIiwgXCJkYXlzXCJdLFxuICAgIGhvdXJzOiBbXCJob3VyXCIsIFwiaHIuXCJdLFxuICAgIG1pbnV0ZXM6IFtcIm1pbnV0ZVwiLCBcIm1pbi5cIl0sXG4gICAgc2Vjb25kczogW1wic2Vjb25kXCIsIFwic2VjLlwiXVxuICB9O1xuXG4gIGNvbnN0IGxhc3RhYmxlID0gW1wiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiXS5pbmRleE9mKHVuaXQpID09PSAtMTtcblxuICBpZiAobnVtZXJpYyA9PT0gXCJhdXRvXCIgJiYgbGFzdGFibGUpIHtcbiAgICBjb25zdCBpc0RheSA9IHVuaXQgPT09IFwiZGF5c1wiO1xuICAgIHN3aXRjaCAoY291bnQpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ0b21vcnJvd1wiIDogYG5leHQgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgY2FzZSAtMTpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ5ZXN0ZXJkYXlcIiA6IGBsYXN0ICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ0b2RheVwiIDogYHRoaXMgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgZGVmYXVsdDogLy8gZmFsbCB0aHJvdWdoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaXNJblBhc3QgPSBPYmplY3QuaXMoY291bnQsIC0wKSB8fCBjb3VudCA8IDAsXG4gICAgZm10VmFsdWUgPSBNYXRoLmFicyhjb3VudCksXG4gICAgc2luZ3VsYXIgPSBmbXRWYWx1ZSA9PT0gMSxcbiAgICBsaWxVbml0cyA9IHVuaXRzW3VuaXRdLFxuICAgIGZtdFVuaXQgPSBuYXJyb3dcbiAgICAgID8gc2luZ3VsYXJcbiAgICAgICAgPyBsaWxVbml0c1sxXVxuICAgICAgICA6IGxpbFVuaXRzWzJdIHx8IGxpbFVuaXRzWzFdXG4gICAgICA6IHNpbmd1bGFyXG4gICAgICAgID8gdW5pdHNbdW5pdF1bMF1cbiAgICAgICAgOiB1bml0O1xuICByZXR1cm4gaXNJblBhc3QgPyBgJHtmbXRWYWx1ZX0gJHtmbXRVbml0fSBhZ29gIDogYGluICR7Zm10VmFsdWV9ICR7Zm10VW5pdH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0U3RyaW5nKGtub3duRm9ybWF0KSB7XG4gIC8vIHRoZXNlIGFsbCBoYXZlIHRoZSBvZmZzZXRzIHJlbW92ZWQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGVtXG4gIC8vIHdpdGhvdXQgYWxsIHRoZSBpbnRsIHN0dWZmIHRoaXMgaXMgYmFja2ZpbGxpbmdcbiAgY29uc3QgZmlsdGVyZWQgPSBwaWNrKGtub3duRm9ybWF0LCBbXG4gICAgICBcIndlZWtkYXlcIixcbiAgICAgIFwiZXJhXCIsXG4gICAgICBcInllYXJcIixcbiAgICAgIFwibW9udGhcIixcbiAgICAgIFwiZGF5XCIsXG4gICAgICBcImhvdXJcIixcbiAgICAgIFwibWludXRlXCIsXG4gICAgICBcInNlY29uZFwiLFxuICAgICAgXCJ0aW1lWm9uZU5hbWVcIixcbiAgICAgIFwiaG91cjEyXCJcbiAgICBdKSxcbiAgICBrZXkgPSBzdHJpbmdpZnkoZmlsdGVyZWQpLFxuICAgIGRhdGVUaW1lSHVnZSA9IFwiRUVFRSwgTExMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfU0hPUlQpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfTUVEKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX01FRF9XSVRIX1dFRUtEQVkpOlxuICAgICAgcmV0dXJuIFwiRUVFLCBMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9GVUxMKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9IVUdFKTpcbiAgICAgIHJldHVybiBcIkVFRUUsIExMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9TSU1QTEUpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1NJTVBMRSk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiSEg6bW06c3NcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfU0hPUlQpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0ZVTEwpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0hVR0UpOlxuICAgICAgcmV0dXJuIGRhdGVUaW1lSHVnZTtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkpOlxuICAgICAgcmV0dXJuIFwiRUVFLCBkIExMTCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJFRUVFLCBMTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZGF0ZVRpbWVIdWdlO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRm9ybWF0cyIsInBpY2siLCJzdHJpbmdpZnkiLCJvYmoiLCJKU09OIiwiT2JqZWN0Iiwia2V5cyIsInNvcnQiLCJtb250aHNMb25nIiwibW9udGhzU2hvcnQiLCJtb250aHNOYXJyb3ciLCJtb250aHMiLCJsZW5ndGgiLCJ3ZWVrZGF5c0xvbmciLCJ3ZWVrZGF5c1Nob3J0Iiwid2Vla2RheXNOYXJyb3ciLCJ3ZWVrZGF5cyIsIm1lcmlkaWVtcyIsImVyYXNMb25nIiwiZXJhc1Nob3J0IiwiZXJhc05hcnJvdyIsImVyYXMiLCJtZXJpZGllbUZvckRhdGVUaW1lIiwiZHQiLCJob3VyIiwid2Vla2RheUZvckRhdGVUaW1lIiwid2Vla2RheSIsIm1vbnRoRm9yRGF0ZVRpbWUiLCJtb250aCIsImVyYUZvckRhdGVUaW1lIiwieWVhciIsImZvcm1hdFJlbGF0aXZlVGltZSIsInVuaXQiLCJjb3VudCIsIm51bWVyaWMiLCJuYXJyb3ciLCJ1bml0cyIsInllYXJzIiwicXVhcnRlcnMiLCJ3ZWVrcyIsImRheXMiLCJob3VycyIsIm1pbnV0ZXMiLCJzZWNvbmRzIiwibGFzdGFibGUiLCJpbmRleE9mIiwiaXNEYXkiLCJpc0luUGFzdCIsImlzIiwiZm10VmFsdWUiLCJNYXRoIiwiYWJzIiwic2luZ3VsYXIiLCJsaWxVbml0cyIsImZtdFVuaXQiLCJmb3JtYXRTdHJpbmciLCJrbm93bkZvcm1hdCIsImZpbHRlcmVkIiwia2V5IiwiZGF0ZVRpbWVIdWdlIiwiREFURV9TSE9SVCIsIkRBVEVfTUVEIiwiREFURV9NRURfV0lUSF9XRUVLREFZIiwiREFURV9GVUxMIiwiREFURV9IVUdFIiwiVElNRV9TSU1QTEUiLCJUSU1FX1dJVEhfU0VDT05EUyIsIlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQiLCJUSU1FX1dJVEhfTE9OR19PRkZTRVQiLCJUSU1FXzI0X1NJTVBMRSIsIlRJTUVfMjRfV0lUSF9TRUNPTkRTIiwiVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCIsIlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCIsIkRBVEVUSU1FX1NIT1JUIiwiREFURVRJTUVfTUVEIiwiREFURVRJTUVfRlVMTCIsIkRBVEVUSU1FX0hVR0UiLCJEQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMiLCJEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTIiwiREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSIsIkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTIiwiREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/impl/english.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/impl/formats.js":
/*!************************************************!*\
  !*** ./node_modules/luxon/src/impl/formats.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DATETIME_FULL: () => (/* binding */ DATETIME_FULL),\n/* harmony export */   DATETIME_FULL_WITH_SECONDS: () => (/* binding */ DATETIME_FULL_WITH_SECONDS),\n/* harmony export */   DATETIME_HUGE: () => (/* binding */ DATETIME_HUGE),\n/* harmony export */   DATETIME_HUGE_WITH_SECONDS: () => (/* binding */ DATETIME_HUGE_WITH_SECONDS),\n/* harmony export */   DATETIME_MED: () => (/* binding */ DATETIME_MED),\n/* harmony export */   DATETIME_MED_WITH_SECONDS: () => (/* binding */ DATETIME_MED_WITH_SECONDS),\n/* harmony export */   DATETIME_MED_WITH_WEEKDAY: () => (/* binding */ DATETIME_MED_WITH_WEEKDAY),\n/* harmony export */   DATETIME_SHORT: () => (/* binding */ DATETIME_SHORT),\n/* harmony export */   DATETIME_SHORT_WITH_SECONDS: () => (/* binding */ DATETIME_SHORT_WITH_SECONDS),\n/* harmony export */   DATE_FULL: () => (/* binding */ DATE_FULL),\n/* harmony export */   DATE_HUGE: () => (/* binding */ DATE_HUGE),\n/* harmony export */   DATE_MED: () => (/* binding */ DATE_MED),\n/* harmony export */   DATE_MED_WITH_WEEKDAY: () => (/* binding */ DATE_MED_WITH_WEEKDAY),\n/* harmony export */   DATE_SHORT: () => (/* binding */ DATE_SHORT),\n/* harmony export */   TIME_24_SIMPLE: () => (/* binding */ TIME_24_SIMPLE),\n/* harmony export */   TIME_24_WITH_LONG_OFFSET: () => (/* binding */ TIME_24_WITH_LONG_OFFSET),\n/* harmony export */   TIME_24_WITH_SECONDS: () => (/* binding */ TIME_24_WITH_SECONDS),\n/* harmony export */   TIME_24_WITH_SHORT_OFFSET: () => (/* binding */ TIME_24_WITH_SHORT_OFFSET),\n/* harmony export */   TIME_SIMPLE: () => (/* binding */ TIME_SIMPLE),\n/* harmony export */   TIME_WITH_LONG_OFFSET: () => (/* binding */ TIME_WITH_LONG_OFFSET),\n/* harmony export */   TIME_WITH_SECONDS: () => (/* binding */ TIME_WITH_SECONDS),\n/* harmony export */   TIME_WITH_SHORT_OFFSET: () => (/* binding */ TIME_WITH_SHORT_OFFSET)\n/* harmony export */ });\n/**\n * @private\n */ const n = \"numeric\", s = \"short\", l = \"long\";\nconst DATE_SHORT = {\n    year: n,\n    month: n,\n    day: n\n};\nconst DATE_MED = {\n    year: n,\n    month: s,\n    day: n\n};\nconst DATE_MED_WITH_WEEKDAY = {\n    year: n,\n    month: s,\n    day: n,\n    weekday: s\n};\nconst DATE_FULL = {\n    year: n,\n    month: l,\n    day: n\n};\nconst DATE_HUGE = {\n    year: n,\n    month: l,\n    day: n,\n    weekday: l\n};\nconst TIME_SIMPLE = {\n    hour: n,\n    minute: n\n};\nconst TIME_WITH_SECONDS = {\n    hour: n,\n    minute: n,\n    second: n\n};\nconst TIME_WITH_SHORT_OFFSET = {\n    hour: n,\n    minute: n,\n    second: n,\n    timeZoneName: s\n};\nconst TIME_WITH_LONG_OFFSET = {\n    hour: n,\n    minute: n,\n    second: n,\n    timeZoneName: l\n};\nconst TIME_24_SIMPLE = {\n    hour: n,\n    minute: n,\n    hour12: false\n};\n/**\n * {@link toLocaleString}; format like '09:30:23', always 24-hour.\n */ const TIME_24_WITH_SECONDS = {\n    hour: n,\n    minute: n,\n    second: n,\n    hour12: false\n};\n/**\n * {@link toLocaleString}; format like '09:30:23 EDT', always 24-hour.\n */ const TIME_24_WITH_SHORT_OFFSET = {\n    hour: n,\n    minute: n,\n    second: n,\n    hour12: false,\n    timeZoneName: s\n};\n/**\n * {@link toLocaleString}; format like '09:30:23 Eastern Daylight Time', always 24-hour.\n */ const TIME_24_WITH_LONG_OFFSET = {\n    hour: n,\n    minute: n,\n    second: n,\n    hour12: false,\n    timeZoneName: l\n};\n/**\n * {@link toLocaleString}; format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.\n */ const DATETIME_SHORT = {\n    year: n,\n    month: n,\n    day: n,\n    hour: n,\n    minute: n\n};\n/**\n * {@link toLocaleString}; format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.\n */ const DATETIME_SHORT_WITH_SECONDS = {\n    year: n,\n    month: n,\n    day: n,\n    hour: n,\n    minute: n,\n    second: n\n};\nconst DATETIME_MED = {\n    year: n,\n    month: s,\n    day: n,\n    hour: n,\n    minute: n\n};\nconst DATETIME_MED_WITH_SECONDS = {\n    year: n,\n    month: s,\n    day: n,\n    hour: n,\n    minute: n,\n    second: n\n};\nconst DATETIME_MED_WITH_WEEKDAY = {\n    year: n,\n    month: s,\n    day: n,\n    weekday: s,\n    hour: n,\n    minute: n\n};\nconst DATETIME_FULL = {\n    year: n,\n    month: l,\n    day: n,\n    hour: n,\n    minute: n,\n    timeZoneName: s\n};\nconst DATETIME_FULL_WITH_SECONDS = {\n    year: n,\n    month: l,\n    day: n,\n    hour: n,\n    minute: n,\n    second: n,\n    timeZoneName: s\n};\nconst DATETIME_HUGE = {\n    year: n,\n    month: l,\n    day: n,\n    weekday: l,\n    hour: n,\n    minute: n,\n    timeZoneName: l\n};\nconst DATETIME_HUGE_WITH_SECONDS = {\n    year: n,\n    month: l,\n    day: n,\n    weekday: l,\n    hour: n,\n    minute: n,\n    second: n,\n    timeZoneName: l\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZm9ybWF0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FFRCxNQUFNQSxJQUFJLFdBQ1JDLElBQUksU0FDSkMsSUFBSTtBQUVDLE1BQU1DLGFBQWE7SUFDeEJDLE1BQU1KO0lBQ05LLE9BQU9MO0lBQ1BNLEtBQUtOO0FBQ1AsRUFBRTtBQUVLLE1BQU1PLFdBQVc7SUFDdEJILE1BQU1KO0lBQ05LLE9BQU9KO0lBQ1BLLEtBQUtOO0FBQ1AsRUFBRTtBQUVLLE1BQU1RLHdCQUF3QjtJQUNuQ0osTUFBTUo7SUFDTkssT0FBT0o7SUFDUEssS0FBS047SUFDTFMsU0FBU1I7QUFDWCxFQUFFO0FBRUssTUFBTVMsWUFBWTtJQUN2Qk4sTUFBTUo7SUFDTkssT0FBT0g7SUFDUEksS0FBS047QUFDUCxFQUFFO0FBRUssTUFBTVcsWUFBWTtJQUN2QlAsTUFBTUo7SUFDTkssT0FBT0g7SUFDUEksS0FBS047SUFDTFMsU0FBU1A7QUFDWCxFQUFFO0FBRUssTUFBTVUsY0FBYztJQUN6QkMsTUFBTWI7SUFDTmMsUUFBUWQ7QUFDVixFQUFFO0FBRUssTUFBTWUsb0JBQW9CO0lBQy9CRixNQUFNYjtJQUNOYyxRQUFRZDtJQUNSZ0IsUUFBUWhCO0FBQ1YsRUFBRTtBQUVLLE1BQU1pQix5QkFBeUI7SUFDcENKLE1BQU1iO0lBQ05jLFFBQVFkO0lBQ1JnQixRQUFRaEI7SUFDUmtCLGNBQWNqQjtBQUNoQixFQUFFO0FBRUssTUFBTWtCLHdCQUF3QjtJQUNuQ04sTUFBTWI7SUFDTmMsUUFBUWQ7SUFDUmdCLFFBQVFoQjtJQUNSa0IsY0FBY2hCO0FBQ2hCLEVBQUU7QUFFSyxNQUFNa0IsaUJBQWlCO0lBQzVCUCxNQUFNYjtJQUNOYyxRQUFRZDtJQUNScUIsUUFBUTtBQUNWLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLE1BQU1DLHVCQUF1QjtJQUNsQ1QsTUFBTWI7SUFDTmMsUUFBUWQ7SUFDUmdCLFFBQVFoQjtJQUNScUIsUUFBUTtBQUNWLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLE1BQU1FLDRCQUE0QjtJQUN2Q1YsTUFBTWI7SUFDTmMsUUFBUWQ7SUFDUmdCLFFBQVFoQjtJQUNScUIsUUFBUTtJQUNSSCxjQUFjakI7QUFDaEIsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTXVCLDJCQUEyQjtJQUN0Q1gsTUFBTWI7SUFDTmMsUUFBUWQ7SUFDUmdCLFFBQVFoQjtJQUNScUIsUUFBUTtJQUNSSCxjQUFjaEI7QUFDaEIsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTXVCLGlCQUFpQjtJQUM1QnJCLE1BQU1KO0lBQ05LLE9BQU9MO0lBQ1BNLEtBQUtOO0lBQ0xhLE1BQU1iO0lBQ05jLFFBQVFkO0FBQ1YsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTTBCLDhCQUE4QjtJQUN6Q3RCLE1BQU1KO0lBQ05LLE9BQU9MO0lBQ1BNLEtBQUtOO0lBQ0xhLE1BQU1iO0lBQ05jLFFBQVFkO0lBQ1JnQixRQUFRaEI7QUFDVixFQUFFO0FBRUssTUFBTTJCLGVBQWU7SUFDMUJ2QixNQUFNSjtJQUNOSyxPQUFPSjtJQUNQSyxLQUFLTjtJQUNMYSxNQUFNYjtJQUNOYyxRQUFRZDtBQUNWLEVBQUU7QUFFSyxNQUFNNEIsNEJBQTRCO0lBQ3ZDeEIsTUFBTUo7SUFDTkssT0FBT0o7SUFDUEssS0FBS047SUFDTGEsTUFBTWI7SUFDTmMsUUFBUWQ7SUFDUmdCLFFBQVFoQjtBQUNWLEVBQUU7QUFFSyxNQUFNNkIsNEJBQTRCO0lBQ3ZDekIsTUFBTUo7SUFDTkssT0FBT0o7SUFDUEssS0FBS047SUFDTFMsU0FBU1I7SUFDVFksTUFBTWI7SUFDTmMsUUFBUWQ7QUFDVixFQUFFO0FBRUssTUFBTThCLGdCQUFnQjtJQUMzQjFCLE1BQU1KO0lBQ05LLE9BQU9IO0lBQ1BJLEtBQUtOO0lBQ0xhLE1BQU1iO0lBQ05jLFFBQVFkO0lBQ1JrQixjQUFjakI7QUFDaEIsRUFBRTtBQUVLLE1BQU04Qiw2QkFBNkI7SUFDeEMzQixNQUFNSjtJQUNOSyxPQUFPSDtJQUNQSSxLQUFLTjtJQUNMYSxNQUFNYjtJQUNOYyxRQUFRZDtJQUNSZ0IsUUFBUWhCO0lBQ1JrQixjQUFjakI7QUFDaEIsRUFBRTtBQUVLLE1BQU0rQixnQkFBZ0I7SUFDM0I1QixNQUFNSjtJQUNOSyxPQUFPSDtJQUNQSSxLQUFLTjtJQUNMUyxTQUFTUDtJQUNUVyxNQUFNYjtJQUNOYyxRQUFRZDtJQUNSa0IsY0FBY2hCO0FBQ2hCLEVBQUU7QUFFSyxNQUFNK0IsNkJBQTZCO0lBQ3hDN0IsTUFBTUo7SUFDTkssT0FBT0g7SUFDUEksS0FBS047SUFDTFMsU0FBU1A7SUFDVFcsTUFBTWI7SUFDTmMsUUFBUWQ7SUFDUmdCLFFBQVFoQjtJQUNSa0IsY0FBY2hCO0FBQ2hCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pYXRvb2xzLW5leHQvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZm9ybWF0cy5qcz83MzE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jb25zdCBuID0gXCJudW1lcmljXCIsXG4gIHMgPSBcInNob3J0XCIsXG4gIGwgPSBcImxvbmdcIjtcblxuZXhwb3J0IGNvbnN0IERBVEVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG5cbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX01FRCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogblxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfTUVEX1dJVEhfV0VFS0RBWSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgd2Vla2RheTogc1xufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogblxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfU0lNUExFID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG5cbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfU0VDT05EUyA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG5cbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBzXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX0xPTkdfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgaG91cjEyOiBmYWxzZVxufTtcblxuLyoqXG4gKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9OyBmb3JtYXQgbGlrZSAnMDk6MzA6MjMnLCBhbHdheXMgMjQtaG91ci5cbiAqL1xuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91cjEyOiBmYWxzZVxufTtcblxuLyoqXG4gKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9OyBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRURUJywgYWx3YXlzIDI0LWhvdXIuXG4gKi9cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91cjEyOiBmYWxzZSxcbiAgdGltZVpvbmVOYW1lOiBzXG59O1xuXG4vKipcbiAqIHtAbGluayB0b0xvY2FsZVN0cmluZ307IGZvcm1hdCBsaWtlICcwOTozMDoyMyBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLCBhbHdheXMgMjQtaG91ci5cbiAqL1xuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXIxMjogZmFsc2UsXG4gIHRpbWVab25lTmFtZTogbFxufTtcblxuLyoqXG4gKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9OyBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICovXG5leHBvcnQgY29uc3QgREFURVRJTUVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogblxufTtcblxuLyoqXG4gKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9OyBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMDozMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICovXG5leHBvcnQgY29uc3QgREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogblxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX01FRCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG5cbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG5cbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9GVUxMID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHRpbWVab25lTmFtZTogc1xufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBzXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IGxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogbFxufTtcbiJdLCJuYW1lcyI6WyJuIiwicyIsImwiLCJEQVRFX1NIT1JUIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiREFURV9NRUQiLCJEQVRFX01FRF9XSVRIX1dFRUtEQVkiLCJ3ZWVrZGF5IiwiREFURV9GVUxMIiwiREFURV9IVUdFIiwiVElNRV9TSU1QTEUiLCJob3VyIiwibWludXRlIiwiVElNRV9XSVRIX1NFQ09ORFMiLCJzZWNvbmQiLCJUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUIiwidGltZVpvbmVOYW1lIiwiVElNRV9XSVRIX0xPTkdfT0ZGU0VUIiwiVElNRV8yNF9TSU1QTEUiLCJob3VyMTIiLCJUSU1FXzI0X1dJVEhfU0VDT05EUyIsIlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQiLCJUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQiLCJEQVRFVElNRV9TSE9SVCIsIkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyIsIkRBVEVUSU1FX01FRCIsIkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMiLCJEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZIiwiREFURVRJTUVfRlVMTCIsIkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTIiwiREFURVRJTUVfSFVHRSIsIkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/impl/formats.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/impl/formatter.js":
/*!**************************************************!*\
  !*** ./node_modules/luxon/src/impl/formatter.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Formatter)\n/* harmony export */ });\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./english.js */ \"(rsc)/./node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _formats_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formats.js */ \"(rsc)/./node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"(rsc)/./node_modules/luxon/src/impl/util.js\");\n\n\n\nfunction stringifyTokens(splits, tokenToString) {\n    let s = \"\";\n    for (const token of splits){\n        if (token.literal) {\n            s += token.val;\n        } else {\n            s += tokenToString(token.val);\n        }\n    }\n    return s;\n}\nconst macroTokenToFormatOpts = {\n    D: _formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_SHORT,\n    DD: _formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_MED,\n    DDD: _formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_FULL,\n    DDDD: _formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_HUGE,\n    t: _formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_SIMPLE,\n    tt: _formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_SECONDS,\n    ttt: _formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_SHORT_OFFSET,\n    tttt: _formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_LONG_OFFSET,\n    T: _formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_SIMPLE,\n    TT: _formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_SECONDS,\n    TTT: _formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_SHORT_OFFSET,\n    TTTT: _formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_LONG_OFFSET,\n    f: _formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_SHORT,\n    ff: _formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED,\n    fff: _formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_FULL,\n    ffff: _formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_HUGE,\n    F: _formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_SHORT_WITH_SECONDS,\n    FF: _formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED_WITH_SECONDS,\n    FFF: _formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_FULL_WITH_SECONDS,\n    FFFF: _formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_HUGE_WITH_SECONDS\n};\n/**\n * @private\n */ class Formatter {\n    static create(locale, opts = {}) {\n        return new Formatter(locale, opts);\n    }\n    static parseFormat(fmt) {\n        let current = null, currentFull = \"\", bracketed = false;\n        const splits = [];\n        for(let i = 0; i < fmt.length; i++){\n            const c = fmt.charAt(i);\n            if (c === \"'\") {\n                if (currentFull.length > 0) {\n                    splits.push({\n                        literal: bracketed,\n                        val: currentFull\n                    });\n                }\n                current = null;\n                currentFull = \"\";\n                bracketed = !bracketed;\n            } else if (bracketed) {\n                currentFull += c;\n            } else if (c === current) {\n                currentFull += c;\n            } else {\n                if (currentFull.length > 0) {\n                    splits.push({\n                        literal: false,\n                        val: currentFull\n                    });\n                }\n                currentFull = c;\n                current = c;\n            }\n        }\n        if (currentFull.length > 0) {\n            splits.push({\n                literal: bracketed,\n                val: currentFull\n            });\n        }\n        return splits;\n    }\n    static macroTokenToFormatOpts(token) {\n        return macroTokenToFormatOpts[token];\n    }\n    constructor(locale, formatOpts){\n        this.opts = formatOpts;\n        this.loc = locale;\n        this.systemLoc = null;\n    }\n    formatWithSystemDefault(dt, opts) {\n        if (this.systemLoc === null) {\n            this.systemLoc = this.loc.redefaultToSystem();\n        }\n        const df = this.systemLoc.dtFormatter(dt, Object.assign({}, this.opts, opts));\n        return df.format();\n    }\n    formatDateTime(dt, opts = {}) {\n        const df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));\n        return df.format();\n    }\n    formatDateTimeParts(dt, opts = {}) {\n        const df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));\n        return df.formatToParts();\n    }\n    resolvedOptions(dt, opts = {}) {\n        const df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));\n        return df.resolvedOptions();\n    }\n    num(n, p = 0) {\n        // we get some perf out of doing this here, annoyingly\n        if (this.opts.forceSimple) {\n            return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.padStart)(n, p);\n        }\n        const opts = Object.assign({}, this.opts);\n        if (p > 0) {\n            opts.padTo = p;\n        }\n        return this.loc.numberFormatter(opts).format(n);\n    }\n    formatDateTimeFromString(dt, fmt) {\n        const knownEnglish = this.loc.listingMode() === \"en\", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== \"gregory\" && (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.hasFormatToParts)(), string = (opts, extract)=>this.loc.extract(dt, opts, extract), formatOffset = (opts)=>{\n            if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {\n                return \"Z\";\n            }\n            return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : \"\";\n        }, meridiem = ()=>knownEnglish ? _english_js__WEBPACK_IMPORTED_MODULE_2__.meridiemForDateTime(dt) : string({\n                hour: \"numeric\",\n                hour12: true\n            }, \"dayperiod\"), month = (length, standalone)=>knownEnglish ? _english_js__WEBPACK_IMPORTED_MODULE_2__.monthForDateTime(dt, length) : string(standalone ? {\n                month: length\n            } : {\n                month: length,\n                day: \"numeric\"\n            }, \"month\"), weekday = (length, standalone)=>knownEnglish ? _english_js__WEBPACK_IMPORTED_MODULE_2__.weekdayForDateTime(dt, length) : string(standalone ? {\n                weekday: length\n            } : {\n                weekday: length,\n                month: \"long\",\n                day: \"numeric\"\n            }, \"weekday\"), maybeMacro = (token)=>{\n            const formatOpts = Formatter.macroTokenToFormatOpts(token);\n            if (formatOpts) {\n                return this.formatWithSystemDefault(dt, formatOpts);\n            } else {\n                return token;\n            }\n        }, era = (length)=>knownEnglish ? _english_js__WEBPACK_IMPORTED_MODULE_2__.eraForDateTime(dt, length) : string({\n                era: length\n            }, \"era\"), tokenToString = (token)=>{\n            // Where possible: http://cldr.unicode.org/translation/date-time-1/date-time#TOC-Standalone-vs.-Format-Styles\n            switch(token){\n                // ms\n                case \"S\":\n                    return this.num(dt.millisecond);\n                case \"u\":\n                // falls through\n                case \"SSS\":\n                    return this.num(dt.millisecond, 3);\n                // seconds\n                case \"s\":\n                    return this.num(dt.second);\n                case \"ss\":\n                    return this.num(dt.second, 2);\n                // minutes\n                case \"m\":\n                    return this.num(dt.minute);\n                case \"mm\":\n                    return this.num(dt.minute, 2);\n                // hours\n                case \"h\":\n                    return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);\n                case \"hh\":\n                    return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);\n                case \"H\":\n                    return this.num(dt.hour);\n                case \"HH\":\n                    return this.num(dt.hour, 2);\n                // offset\n                case \"Z\":\n                    // like +6\n                    return formatOffset({\n                        format: \"narrow\",\n                        allowZ: this.opts.allowZ\n                    });\n                case \"ZZ\":\n                    // like +06:00\n                    return formatOffset({\n                        format: \"short\",\n                        allowZ: this.opts.allowZ\n                    });\n                case \"ZZZ\":\n                    // like +0600\n                    return formatOffset({\n                        format: \"techie\",\n                        allowZ: this.opts.allowZ\n                    });\n                case \"ZZZZ\":\n                    // like EST\n                    return dt.zone.offsetName(dt.ts, {\n                        format: \"short\",\n                        locale: this.loc.locale\n                    });\n                case \"ZZZZZ\":\n                    // like Eastern Standard Time\n                    return dt.zone.offsetName(dt.ts, {\n                        format: \"long\",\n                        locale: this.loc.locale\n                    });\n                // zone\n                case \"z\":\n                    // like America/New_York\n                    return dt.zoneName;\n                // meridiems\n                case \"a\":\n                    return meridiem();\n                // dates\n                case \"d\":\n                    return useDateTimeFormatter ? string({\n                        day: \"numeric\"\n                    }, \"day\") : this.num(dt.day);\n                case \"dd\":\n                    return useDateTimeFormatter ? string({\n                        day: \"2-digit\"\n                    }, \"day\") : this.num(dt.day, 2);\n                // weekdays - standalone\n                case \"c\":\n                    // like 1\n                    return this.num(dt.weekday);\n                case \"ccc\":\n                    // like 'Tues'\n                    return weekday(\"short\", true);\n                case \"cccc\":\n                    // like 'Tuesday'\n                    return weekday(\"long\", true);\n                case \"ccccc\":\n                    // like 'T'\n                    return weekday(\"narrow\", true);\n                // weekdays - format\n                case \"E\":\n                    // like 1\n                    return this.num(dt.weekday);\n                case \"EEE\":\n                    // like 'Tues'\n                    return weekday(\"short\", false);\n                case \"EEEE\":\n                    // like 'Tuesday'\n                    return weekday(\"long\", false);\n                case \"EEEEE\":\n                    // like 'T'\n                    return weekday(\"narrow\", false);\n                // months - standalone\n                case \"L\":\n                    // like 1\n                    return useDateTimeFormatter ? string({\n                        month: \"numeric\",\n                        day: \"numeric\"\n                    }, \"month\") : this.num(dt.month);\n                case \"LL\":\n                    // like 01, doesn't seem to work\n                    return useDateTimeFormatter ? string({\n                        month: \"2-digit\",\n                        day: \"numeric\"\n                    }, \"month\") : this.num(dt.month, 2);\n                case \"LLL\":\n                    // like Jan\n                    return month(\"short\", true);\n                case \"LLLL\":\n                    // like January\n                    return month(\"long\", true);\n                case \"LLLLL\":\n                    // like J\n                    return month(\"narrow\", true);\n                // months - format\n                case \"M\":\n                    // like 1\n                    return useDateTimeFormatter ? string({\n                        month: \"numeric\"\n                    }, \"month\") : this.num(dt.month);\n                case \"MM\":\n                    // like 01\n                    return useDateTimeFormatter ? string({\n                        month: \"2-digit\"\n                    }, \"month\") : this.num(dt.month, 2);\n                case \"MMM\":\n                    // like Jan\n                    return month(\"short\", false);\n                case \"MMMM\":\n                    // like January\n                    return month(\"long\", false);\n                case \"MMMMM\":\n                    // like J\n                    return month(\"narrow\", false);\n                // years\n                case \"y\":\n                    // like 2014\n                    return useDateTimeFormatter ? string({\n                        year: \"numeric\"\n                    }, \"year\") : this.num(dt.year);\n                case \"yy\":\n                    // like 14\n                    return useDateTimeFormatter ? string({\n                        year: \"2-digit\"\n                    }, \"year\") : this.num(dt.year.toString().slice(-2), 2);\n                case \"yyyy\":\n                    // like 0012\n                    return useDateTimeFormatter ? string({\n                        year: \"numeric\"\n                    }, \"year\") : this.num(dt.year, 4);\n                case \"yyyyyy\":\n                    // like 000012\n                    return useDateTimeFormatter ? string({\n                        year: \"numeric\"\n                    }, \"year\") : this.num(dt.year, 6);\n                // eras\n                case \"G\":\n                    // like AD\n                    return era(\"short\");\n                case \"GG\":\n                    // like Anno Domini\n                    return era(\"long\");\n                case \"GGGGG\":\n                    return era(\"narrow\");\n                case \"kk\":\n                    return this.num(dt.weekYear.toString().slice(-2), 2);\n                case \"kkkk\":\n                    return this.num(dt.weekYear, 4);\n                case \"W\":\n                    return this.num(dt.weekNumber);\n                case \"WW\":\n                    return this.num(dt.weekNumber, 2);\n                case \"o\":\n                    return this.num(dt.ordinal);\n                case \"ooo\":\n                    return this.num(dt.ordinal, 3);\n                case \"q\":\n                    // like 1\n                    return this.num(dt.quarter);\n                case \"qq\":\n                    // like 01\n                    return this.num(dt.quarter, 2);\n                case \"X\":\n                    return this.num(Math.floor(dt.ts / 1000));\n                case \"x\":\n                    return this.num(dt.ts);\n                default:\n                    return maybeMacro(token);\n            }\n        };\n        return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);\n    }\n    formatDurationFromString(dur, fmt) {\n        const tokenToField = (token)=>{\n            switch(token[0]){\n                case \"S\":\n                    return \"millisecond\";\n                case \"s\":\n                    return \"second\";\n                case \"m\":\n                    return \"minute\";\n                case \"h\":\n                    return \"hour\";\n                case \"d\":\n                    return \"day\";\n                case \"M\":\n                    return \"month\";\n                case \"y\":\n                    return \"year\";\n                default:\n                    return null;\n            }\n        }, tokenToString = (lildur)=>(token)=>{\n                const mapped = tokenToField(token);\n                if (mapped) {\n                    return this.num(lildur.get(mapped), token.length);\n                } else {\n                    return token;\n                }\n            }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce((found, { literal, val })=>literal ? found : found.concat(val), []), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t)=>t));\n        return stringifyTokens(tokens, tokenToString(collapsed));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZm9ybWF0dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0M7QUFDQTtBQUNlO0FBRXZELFNBQVNJLGdCQUFnQkMsTUFBTSxFQUFFQyxhQUFhO0lBQzVDLElBQUlDLElBQUk7SUFDUixLQUFLLE1BQU1DLFNBQVNILE9BQVE7UUFDMUIsSUFBSUcsTUFBTUMsT0FBTyxFQUFFO1lBQ2pCRixLQUFLQyxNQUFNRSxHQUFHO1FBQ2hCLE9BQU87WUFDTEgsS0FBS0QsY0FBY0UsTUFBTUUsR0FBRztRQUM5QjtJQUNGO0lBQ0EsT0FBT0g7QUFDVDtBQUVBLE1BQU1JLHlCQUF5QjtJQUM3QkMsR0FBR1gsbURBQWtCO0lBQ3JCYSxJQUFJYixpREFBZ0I7SUFDcEJlLEtBQUtmLGtEQUFpQjtJQUN0QmlCLE1BQU1qQixrREFBaUI7SUFDdkJtQixHQUFHbkIsb0RBQW1CO0lBQ3RCcUIsSUFBSXJCLDBEQUF5QjtJQUM3QnVCLEtBQUt2QiwrREFBOEI7SUFDbkN5QixNQUFNekIsOERBQTZCO0lBQ25DMkIsR0FBRzNCLHVEQUFzQjtJQUN6QjZCLElBQUk3Qiw2REFBNEI7SUFDaEMrQixLQUFLL0Isa0VBQWlDO0lBQ3RDaUMsTUFBTWpDLGlFQUFnQztJQUN0Q21DLEdBQUduQyx1REFBc0I7SUFDekJxQyxJQUFJckMscURBQW9CO0lBQ3hCdUMsS0FBS3ZDLHNEQUFxQjtJQUMxQnlDLE1BQU16QyxzREFBcUI7SUFDM0IyQyxHQUFHM0Msb0VBQW1DO0lBQ3RDNkMsSUFBSTdDLGtFQUFpQztJQUNyQytDLEtBQUsvQyxtRUFBa0M7SUFDdkNpRCxNQUFNakQsbUVBQWtDO0FBQzFDO0FBRUE7O0NBRUMsR0FFYyxNQUFNbUQ7SUFDbkIsT0FBT0MsT0FBT0MsTUFBTSxFQUFFQyxPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQy9CLE9BQU8sSUFBSUgsVUFBVUUsUUFBUUM7SUFDL0I7SUFFQSxPQUFPQyxZQUFZQyxHQUFHLEVBQUU7UUFDdEIsSUFBSUMsVUFBVSxNQUNaQyxjQUFjLElBQ2RDLFlBQVk7UUFDZCxNQUFNdkQsU0FBUyxFQUFFO1FBQ2pCLElBQUssSUFBSXdELElBQUksR0FBR0EsSUFBSUosSUFBSUssTUFBTSxFQUFFRCxJQUFLO1lBQ25DLE1BQU1FLElBQUlOLElBQUlPLE1BQU0sQ0FBQ0g7WUFDckIsSUFBSUUsTUFBTSxLQUFLO2dCQUNiLElBQUlKLFlBQVlHLE1BQU0sR0FBRyxHQUFHO29CQUMxQnpELE9BQU80RCxJQUFJLENBQUM7d0JBQUV4RCxTQUFTbUQ7d0JBQVdsRCxLQUFLaUQ7b0JBQVk7Z0JBQ3JEO2dCQUNBRCxVQUFVO2dCQUNWQyxjQUFjO2dCQUNkQyxZQUFZLENBQUNBO1lBQ2YsT0FBTyxJQUFJQSxXQUFXO2dCQUNwQkQsZUFBZUk7WUFDakIsT0FBTyxJQUFJQSxNQUFNTCxTQUFTO2dCQUN4QkMsZUFBZUk7WUFDakIsT0FBTztnQkFDTCxJQUFJSixZQUFZRyxNQUFNLEdBQUcsR0FBRztvQkFDMUJ6RCxPQUFPNEQsSUFBSSxDQUFDO3dCQUFFeEQsU0FBUzt3QkFBT0MsS0FBS2lEO29CQUFZO2dCQUNqRDtnQkFDQUEsY0FBY0k7Z0JBQ2RMLFVBQVVLO1lBQ1o7UUFDRjtRQUVBLElBQUlKLFlBQVlHLE1BQU0sR0FBRyxHQUFHO1lBQzFCekQsT0FBTzRELElBQUksQ0FBQztnQkFBRXhELFNBQVNtRDtnQkFBV2xELEtBQUtpRDtZQUFZO1FBQ3JEO1FBRUEsT0FBT3REO0lBQ1Q7SUFFQSxPQUFPTSx1QkFBdUJILEtBQUssRUFBRTtRQUNuQyxPQUFPRyxzQkFBc0IsQ0FBQ0gsTUFBTTtJQUN0QztJQUVBMEQsWUFBWVosTUFBTSxFQUFFYSxVQUFVLENBQUU7UUFDOUIsSUFBSSxDQUFDWixJQUFJLEdBQUdZO1FBQ1osSUFBSSxDQUFDQyxHQUFHLEdBQUdkO1FBQ1gsSUFBSSxDQUFDZSxTQUFTLEdBQUc7SUFDbkI7SUFFQUMsd0JBQXdCQyxFQUFFLEVBQUVoQixJQUFJLEVBQUU7UUFDaEMsSUFBSSxJQUFJLENBQUNjLFNBQVMsS0FBSyxNQUFNO1lBQzNCLElBQUksQ0FBQ0EsU0FBUyxHQUFHLElBQUksQ0FBQ0QsR0FBRyxDQUFDSSxpQkFBaUI7UUFDN0M7UUFDQSxNQUFNQyxLQUFLLElBQUksQ0FBQ0osU0FBUyxDQUFDSyxXQUFXLENBQUNILElBQUlJLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDckIsSUFBSSxFQUFFQTtRQUN2RSxPQUFPa0IsR0FBR0ksTUFBTTtJQUNsQjtJQUVBQyxlQUFlUCxFQUFFLEVBQUVoQixPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQzVCLE1BQU1rQixLQUFLLElBQUksQ0FBQ0wsR0FBRyxDQUFDTSxXQUFXLENBQUNILElBQUlJLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDckIsSUFBSSxFQUFFQTtRQUNqRSxPQUFPa0IsR0FBR0ksTUFBTTtJQUNsQjtJQUVBRSxvQkFBb0JSLEVBQUUsRUFBRWhCLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFDakMsTUFBTWtCLEtBQUssSUFBSSxDQUFDTCxHQUFHLENBQUNNLFdBQVcsQ0FBQ0gsSUFBSUksT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUNyQixJQUFJLEVBQUVBO1FBQ2pFLE9BQU9rQixHQUFHTyxhQUFhO0lBQ3pCO0lBRUFDLGdCQUFnQlYsRUFBRSxFQUFFaEIsT0FBTyxDQUFDLENBQUMsRUFBRTtRQUM3QixNQUFNa0IsS0FBSyxJQUFJLENBQUNMLEdBQUcsQ0FBQ00sV0FBVyxDQUFDSCxJQUFJSSxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ3JCLElBQUksRUFBRUE7UUFDakUsT0FBT2tCLEdBQUdRLGVBQWU7SUFDM0I7SUFFQUMsSUFBSUMsQ0FBQyxFQUFFQyxJQUFJLENBQUMsRUFBRTtRQUNaLHNEQUFzRDtRQUN0RCxJQUFJLElBQUksQ0FBQzdCLElBQUksQ0FBQzhCLFdBQVcsRUFBRTtZQUN6QixPQUFPbEYsa0RBQVFBLENBQUNnRixHQUFHQztRQUNyQjtRQUVBLE1BQU03QixPQUFPb0IsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUNyQixJQUFJO1FBRXhDLElBQUk2QixJQUFJLEdBQUc7WUFDVDdCLEtBQUsrQixLQUFLLEdBQUdGO1FBQ2Y7UUFFQSxPQUFPLElBQUksQ0FBQ2hCLEdBQUcsQ0FBQ21CLGVBQWUsQ0FBQ2hDLE1BQU1zQixNQUFNLENBQUNNO0lBQy9DO0lBRUFLLHlCQUF5QmpCLEVBQUUsRUFBRWQsR0FBRyxFQUFFO1FBQ2hDLE1BQU1nQyxlQUFlLElBQUksQ0FBQ3JCLEdBQUcsQ0FBQ3NCLFdBQVcsT0FBTyxNQUM5Q0MsdUJBQ0UsSUFBSSxDQUFDdkIsR0FBRyxDQUFDd0IsY0FBYyxJQUFJLElBQUksQ0FBQ3hCLEdBQUcsQ0FBQ3dCLGNBQWMsS0FBSyxhQUFhMUYsMERBQWdCQSxJQUN0RjJGLFNBQVMsQ0FBQ3RDLE1BQU11QyxVQUFZLElBQUksQ0FBQzFCLEdBQUcsQ0FBQzBCLE9BQU8sQ0FBQ3ZCLElBQUloQixNQUFNdUMsVUFDdkRDLGVBQWV4QyxDQUFBQTtZQUNiLElBQUlnQixHQUFHeUIsYUFBYSxJQUFJekIsR0FBRzBCLE1BQU0sS0FBSyxLQUFLMUMsS0FBSzJDLE1BQU0sRUFBRTtnQkFDdEQsT0FBTztZQUNUO1lBRUEsT0FBTzNCLEdBQUc0QixPQUFPLEdBQUc1QixHQUFHNkIsSUFBSSxDQUFDTCxZQUFZLENBQUN4QixHQUFHOEIsRUFBRSxFQUFFOUMsS0FBS3NCLE1BQU0sSUFBSTtRQUNqRSxHQUNBeUIsV0FBVyxJQUNUYixlQUNJekYsNERBQTJCLENBQUN1RSxNQUM1QnNCLE9BQU87Z0JBQUVXLE1BQU07Z0JBQVdDLFFBQVE7WUFBSyxHQUFHLGNBQ2hEQyxRQUFRLENBQUM1QyxRQUFRNkMsYUFDZmxCLGVBQ0l6Rix5REFBd0IsQ0FBQ3VFLElBQUlULFVBQzdCK0IsT0FBT2MsYUFBYTtnQkFBRUQsT0FBTzVDO1lBQU8sSUFBSTtnQkFBRTRDLE9BQU81QztnQkFBUStDLEtBQUs7WUFBVSxHQUFHLFVBQ2pGQyxVQUFVLENBQUNoRCxRQUFRNkMsYUFDakJsQixlQUNJekYsMkRBQTBCLENBQUN1RSxJQUFJVCxVQUMvQitCLE9BQ0VjLGFBQWE7Z0JBQUVHLFNBQVNoRDtZQUFPLElBQUk7Z0JBQUVnRCxTQUFTaEQ7Z0JBQVE0QyxPQUFPO2dCQUFRRyxLQUFLO1lBQVUsR0FDcEYsWUFFUkcsYUFBYXhHLENBQUFBO1lBQ1gsTUFBTTJELGFBQWFmLFVBQVV6QyxzQkFBc0IsQ0FBQ0g7WUFDcEQsSUFBSTJELFlBQVk7Z0JBQ2QsT0FBTyxJQUFJLENBQUNHLHVCQUF1QixDQUFDQyxJQUFJSjtZQUMxQyxPQUFPO2dCQUNMLE9BQU8zRDtZQUNUO1FBQ0YsR0FDQXlHLE1BQU1uRCxDQUFBQSxTQUNKMkIsZUFBZXpGLHVEQUFzQixDQUFDdUUsSUFBSVQsVUFBVStCLE9BQU87Z0JBQUVvQixLQUFLbkQ7WUFBTyxHQUFHLFFBQzlFeEQsZ0JBQWdCRSxDQUFBQTtZQUNkLDZHQUE2RztZQUM3RyxPQUFRQTtnQkFDTixLQUFLO2dCQUNMLEtBQUs7b0JBQ0gsT0FBTyxJQUFJLENBQUMwRSxHQUFHLENBQUNYLEdBQUc0QyxXQUFXO2dCQUNoQyxLQUFLO2dCQUNMLGdCQUFnQjtnQkFDaEIsS0FBSztvQkFDSCxPQUFPLElBQUksQ0FBQ2pDLEdBQUcsQ0FBQ1gsR0FBRzRDLFdBQVcsRUFBRTtnQkFDbEMsVUFBVTtnQkFDVixLQUFLO29CQUNILE9BQU8sSUFBSSxDQUFDakMsR0FBRyxDQUFDWCxHQUFHNkMsTUFBTTtnQkFDM0IsS0FBSztvQkFDSCxPQUFPLElBQUksQ0FBQ2xDLEdBQUcsQ0FBQ1gsR0FBRzZDLE1BQU0sRUFBRTtnQkFDN0IsVUFBVTtnQkFDVixLQUFLO29CQUNILE9BQU8sSUFBSSxDQUFDbEMsR0FBRyxDQUFDWCxHQUFHOEMsTUFBTTtnQkFDM0IsS0FBSztvQkFDSCxPQUFPLElBQUksQ0FBQ25DLEdBQUcsQ0FBQ1gsR0FBRzhDLE1BQU0sRUFBRTtnQkFDN0IsUUFBUTtnQkFDUixLQUFLO29CQUNILE9BQU8sSUFBSSxDQUFDbkMsR0FBRyxDQUFDWCxHQUFHaUMsSUFBSSxHQUFHLE9BQU8sSUFBSSxLQUFLakMsR0FBR2lDLElBQUksR0FBRztnQkFDdEQsS0FBSztvQkFDSCxPQUFPLElBQUksQ0FBQ3RCLEdBQUcsQ0FBQ1gsR0FBR2lDLElBQUksR0FBRyxPQUFPLElBQUksS0FBS2pDLEdBQUdpQyxJQUFJLEdBQUcsSUFBSTtnQkFDMUQsS0FBSztvQkFDSCxPQUFPLElBQUksQ0FBQ3RCLEdBQUcsQ0FBQ1gsR0FBR2lDLElBQUk7Z0JBQ3pCLEtBQUs7b0JBQ0gsT0FBTyxJQUFJLENBQUN0QixHQUFHLENBQUNYLEdBQUdpQyxJQUFJLEVBQUU7Z0JBQzNCLFNBQVM7Z0JBQ1QsS0FBSztvQkFDSCxVQUFVO29CQUNWLE9BQU9ULGFBQWE7d0JBQUVsQixRQUFRO3dCQUFVcUIsUUFBUSxJQUFJLENBQUMzQyxJQUFJLENBQUMyQyxNQUFNO29CQUFDO2dCQUNuRSxLQUFLO29CQUNILGNBQWM7b0JBQ2QsT0FBT0gsYUFBYTt3QkFBRWxCLFFBQVE7d0JBQVNxQixRQUFRLElBQUksQ0FBQzNDLElBQUksQ0FBQzJDLE1BQU07b0JBQUM7Z0JBQ2xFLEtBQUs7b0JBQ0gsYUFBYTtvQkFDYixPQUFPSCxhQUFhO3dCQUFFbEIsUUFBUTt3QkFBVXFCLFFBQVEsSUFBSSxDQUFDM0MsSUFBSSxDQUFDMkMsTUFBTTtvQkFBQztnQkFDbkUsS0FBSztvQkFDSCxXQUFXO29CQUNYLE9BQU8zQixHQUFHNkIsSUFBSSxDQUFDa0IsVUFBVSxDQUFDL0MsR0FBRzhCLEVBQUUsRUFBRTt3QkFBRXhCLFFBQVE7d0JBQVN2QixRQUFRLElBQUksQ0FBQ2MsR0FBRyxDQUFDZCxNQUFNO29CQUFDO2dCQUM5RSxLQUFLO29CQUNILDZCQUE2QjtvQkFDN0IsT0FBT2lCLEdBQUc2QixJQUFJLENBQUNrQixVQUFVLENBQUMvQyxHQUFHOEIsRUFBRSxFQUFFO3dCQUFFeEIsUUFBUTt3QkFBUXZCLFFBQVEsSUFBSSxDQUFDYyxHQUFHLENBQUNkLE1BQU07b0JBQUM7Z0JBQzdFLE9BQU87Z0JBQ1AsS0FBSztvQkFDSCx3QkFBd0I7b0JBQ3hCLE9BQU9pQixHQUFHZ0QsUUFBUTtnQkFDcEIsWUFBWTtnQkFDWixLQUFLO29CQUNILE9BQU9qQjtnQkFDVCxRQUFRO2dCQUNSLEtBQUs7b0JBQ0gsT0FBT1gsdUJBQXVCRSxPQUFPO3dCQUFFZ0IsS0FBSztvQkFBVSxHQUFHLFNBQVMsSUFBSSxDQUFDM0IsR0FBRyxDQUFDWCxHQUFHc0MsR0FBRztnQkFDbkYsS0FBSztvQkFDSCxPQUFPbEIsdUJBQXVCRSxPQUFPO3dCQUFFZ0IsS0FBSztvQkFBVSxHQUFHLFNBQVMsSUFBSSxDQUFDM0IsR0FBRyxDQUFDWCxHQUFHc0MsR0FBRyxFQUFFO2dCQUNyRix3QkFBd0I7Z0JBQ3hCLEtBQUs7b0JBQ0gsU0FBUztvQkFDVCxPQUFPLElBQUksQ0FBQzNCLEdBQUcsQ0FBQ1gsR0FBR3VDLE9BQU87Z0JBQzVCLEtBQUs7b0JBQ0gsY0FBYztvQkFDZCxPQUFPQSxRQUFRLFNBQVM7Z0JBQzFCLEtBQUs7b0JBQ0gsaUJBQWlCO29CQUNqQixPQUFPQSxRQUFRLFFBQVE7Z0JBQ3pCLEtBQUs7b0JBQ0gsV0FBVztvQkFDWCxPQUFPQSxRQUFRLFVBQVU7Z0JBQzNCLG9CQUFvQjtnQkFDcEIsS0FBSztvQkFDSCxTQUFTO29CQUNULE9BQU8sSUFBSSxDQUFDNUIsR0FBRyxDQUFDWCxHQUFHdUMsT0FBTztnQkFDNUIsS0FBSztvQkFDSCxjQUFjO29CQUNkLE9BQU9BLFFBQVEsU0FBUztnQkFDMUIsS0FBSztvQkFDSCxpQkFBaUI7b0JBQ2pCLE9BQU9BLFFBQVEsUUFBUTtnQkFDekIsS0FBSztvQkFDSCxXQUFXO29CQUNYLE9BQU9BLFFBQVEsVUFBVTtnQkFDM0Isc0JBQXNCO2dCQUN0QixLQUFLO29CQUNILFNBQVM7b0JBQ1QsT0FBT25CLHVCQUNIRSxPQUFPO3dCQUFFYSxPQUFPO3dCQUFXRyxLQUFLO29CQUFVLEdBQUcsV0FDN0MsSUFBSSxDQUFDM0IsR0FBRyxDQUFDWCxHQUFHbUMsS0FBSztnQkFDdkIsS0FBSztvQkFDSCxnQ0FBZ0M7b0JBQ2hDLE9BQU9mLHVCQUNIRSxPQUFPO3dCQUFFYSxPQUFPO3dCQUFXRyxLQUFLO29CQUFVLEdBQUcsV0FDN0MsSUFBSSxDQUFDM0IsR0FBRyxDQUFDWCxHQUFHbUMsS0FBSyxFQUFFO2dCQUN6QixLQUFLO29CQUNILFdBQVc7b0JBQ1gsT0FBT0EsTUFBTSxTQUFTO2dCQUN4QixLQUFLO29CQUNILGVBQWU7b0JBQ2YsT0FBT0EsTUFBTSxRQUFRO2dCQUN2QixLQUFLO29CQUNILFNBQVM7b0JBQ1QsT0FBT0EsTUFBTSxVQUFVO2dCQUN6QixrQkFBa0I7Z0JBQ2xCLEtBQUs7b0JBQ0gsU0FBUztvQkFDVCxPQUFPZix1QkFDSEUsT0FBTzt3QkFBRWEsT0FBTztvQkFBVSxHQUFHLFdBQzdCLElBQUksQ0FBQ3hCLEdBQUcsQ0FBQ1gsR0FBR21DLEtBQUs7Z0JBQ3ZCLEtBQUs7b0JBQ0gsVUFBVTtvQkFDVixPQUFPZix1QkFDSEUsT0FBTzt3QkFBRWEsT0FBTztvQkFBVSxHQUFHLFdBQzdCLElBQUksQ0FBQ3hCLEdBQUcsQ0FBQ1gsR0FBR21DLEtBQUssRUFBRTtnQkFDekIsS0FBSztvQkFDSCxXQUFXO29CQUNYLE9BQU9BLE1BQU0sU0FBUztnQkFDeEIsS0FBSztvQkFDSCxlQUFlO29CQUNmLE9BQU9BLE1BQU0sUUFBUTtnQkFDdkIsS0FBSztvQkFDSCxTQUFTO29CQUNULE9BQU9BLE1BQU0sVUFBVTtnQkFDekIsUUFBUTtnQkFDUixLQUFLO29CQUNILFlBQVk7b0JBQ1osT0FBT2YsdUJBQXVCRSxPQUFPO3dCQUFFMkIsTUFBTTtvQkFBVSxHQUFHLFVBQVUsSUFBSSxDQUFDdEMsR0FBRyxDQUFDWCxHQUFHaUQsSUFBSTtnQkFDdEYsS0FBSztvQkFDSCxVQUFVO29CQUNWLE9BQU83Qix1QkFDSEUsT0FBTzt3QkFBRTJCLE1BQU07b0JBQVUsR0FBRyxVQUM1QixJQUFJLENBQUN0QyxHQUFHLENBQUNYLEdBQUdpRCxJQUFJLENBQUNDLFFBQVEsR0FBR0MsS0FBSyxDQUFDLENBQUMsSUFBSTtnQkFDN0MsS0FBSztvQkFDSCxZQUFZO29CQUNaLE9BQU8vQix1QkFDSEUsT0FBTzt3QkFBRTJCLE1BQU07b0JBQVUsR0FBRyxVQUM1QixJQUFJLENBQUN0QyxHQUFHLENBQUNYLEdBQUdpRCxJQUFJLEVBQUU7Z0JBQ3hCLEtBQUs7b0JBQ0gsY0FBYztvQkFDZCxPQUFPN0IsdUJBQ0hFLE9BQU87d0JBQUUyQixNQUFNO29CQUFVLEdBQUcsVUFDNUIsSUFBSSxDQUFDdEMsR0FBRyxDQUFDWCxHQUFHaUQsSUFBSSxFQUFFO2dCQUN4QixPQUFPO2dCQUNQLEtBQUs7b0JBQ0gsVUFBVTtvQkFDVixPQUFPUCxJQUFJO2dCQUNiLEtBQUs7b0JBQ0gsbUJBQW1CO29CQUNuQixPQUFPQSxJQUFJO2dCQUNiLEtBQUs7b0JBQ0gsT0FBT0EsSUFBSTtnQkFDYixLQUFLO29CQUNILE9BQU8sSUFBSSxDQUFDL0IsR0FBRyxDQUFDWCxHQUFHb0QsUUFBUSxDQUFDRixRQUFRLEdBQUdDLEtBQUssQ0FBQyxDQUFDLElBQUk7Z0JBQ3BELEtBQUs7b0JBQ0gsT0FBTyxJQUFJLENBQUN4QyxHQUFHLENBQUNYLEdBQUdvRCxRQUFRLEVBQUU7Z0JBQy9CLEtBQUs7b0JBQ0gsT0FBTyxJQUFJLENBQUN6QyxHQUFHLENBQUNYLEdBQUdxRCxVQUFVO2dCQUMvQixLQUFLO29CQUNILE9BQU8sSUFBSSxDQUFDMUMsR0FBRyxDQUFDWCxHQUFHcUQsVUFBVSxFQUFFO2dCQUNqQyxLQUFLO29CQUNILE9BQU8sSUFBSSxDQUFDMUMsR0FBRyxDQUFDWCxHQUFHc0QsT0FBTztnQkFDNUIsS0FBSztvQkFDSCxPQUFPLElBQUksQ0FBQzNDLEdBQUcsQ0FBQ1gsR0FBR3NELE9BQU8sRUFBRTtnQkFDOUIsS0FBSztvQkFDSCxTQUFTO29CQUNULE9BQU8sSUFBSSxDQUFDM0MsR0FBRyxDQUFDWCxHQUFHdUQsT0FBTztnQkFDNUIsS0FBSztvQkFDSCxVQUFVO29CQUNWLE9BQU8sSUFBSSxDQUFDNUMsR0FBRyxDQUFDWCxHQUFHdUQsT0FBTyxFQUFFO2dCQUM5QixLQUFLO29CQUNILE9BQU8sSUFBSSxDQUFDNUMsR0FBRyxDQUFDNkMsS0FBS0MsS0FBSyxDQUFDekQsR0FBRzhCLEVBQUUsR0FBRztnQkFDckMsS0FBSztvQkFDSCxPQUFPLElBQUksQ0FBQ25CLEdBQUcsQ0FBQ1gsR0FBRzhCLEVBQUU7Z0JBQ3ZCO29CQUNFLE9BQU9XLFdBQVd4RztZQUN0QjtRQUNGO1FBRUYsT0FBT0osZ0JBQWdCZ0QsVUFBVUksV0FBVyxDQUFDQyxNQUFNbkQ7SUFDckQ7SUFFQTJILHlCQUF5QkMsR0FBRyxFQUFFekUsR0FBRyxFQUFFO1FBQ2pDLE1BQU0wRSxlQUFlM0gsQ0FBQUE7WUFDakIsT0FBUUEsS0FBSyxDQUFDLEVBQUU7Z0JBQ2QsS0FBSztvQkFDSCxPQUFPO2dCQUNULEtBQUs7b0JBQ0gsT0FBTztnQkFDVCxLQUFLO29CQUNILE9BQU87Z0JBQ1QsS0FBSztvQkFDSCxPQUFPO2dCQUNULEtBQUs7b0JBQ0gsT0FBTztnQkFDVCxLQUFLO29CQUNILE9BQU87Z0JBQ1QsS0FBSztvQkFDSCxPQUFPO2dCQUNUO29CQUNFLE9BQU87WUFDWDtRQUNGLEdBQ0FGLGdCQUFnQjhILENBQUFBLFNBQVU1SCxDQUFBQTtnQkFDeEIsTUFBTTZILFNBQVNGLGFBQWEzSDtnQkFDNUIsSUFBSTZILFFBQVE7b0JBQ1YsT0FBTyxJQUFJLENBQUNuRCxHQUFHLENBQUNrRCxPQUFPRSxHQUFHLENBQUNELFNBQVM3SCxNQUFNc0QsTUFBTTtnQkFDbEQsT0FBTztvQkFDTCxPQUFPdEQ7Z0JBQ1Q7WUFDRixHQUNBK0gsU0FBU25GLFVBQVVJLFdBQVcsQ0FBQ0MsTUFDL0IrRSxhQUFhRCxPQUFPRSxNQUFNLENBQ3hCLENBQUNDLE9BQU8sRUFBRWpJLE9BQU8sRUFBRUMsR0FBRyxFQUFFLEdBQU1ELFVBQVVpSSxRQUFRQSxNQUFNQyxNQUFNLENBQUNqSSxNQUM3RCxFQUFFLEdBRUprSSxZQUFZVixJQUFJVyxPQUFPLElBQUlMLFdBQVdNLEdBQUcsQ0FBQ1gsY0FBY1ksTUFBTSxDQUFDM0gsQ0FBQUEsSUFBS0E7UUFDdEUsT0FBT2hCLGdCQUFnQm1JLFFBQVFqSSxjQUFjc0k7SUFDL0M7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2lhdG9vbHMtbmV4dC8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9mb3JtYXR0ZXIuanM/OTliNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgaGFzRm9ybWF0VG9QYXJ0cywgcGFkU3RhcnQgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VucyhzcGxpdHMsIHRva2VuVG9TdHJpbmcpIHtcbiAgbGV0IHMgPSBcIlwiO1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHNwbGl0cykge1xuICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICBzICs9IHRva2VuLnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyArPSB0b2tlblRvU3RyaW5nKHRva2VuLnZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzO1xufVxuXG5jb25zdCBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzID0ge1xuICBEOiBGb3JtYXRzLkRBVEVfU0hPUlQsXG4gIEREOiBGb3JtYXRzLkRBVEVfTUVELFxuICBEREQ6IEZvcm1hdHMuREFURV9GVUxMLFxuICBEREREOiBGb3JtYXRzLkRBVEVfSFVHRSxcbiAgdDogRm9ybWF0cy5USU1FX1NJTVBMRSxcbiAgdHQ6IEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMsXG4gIHR0dDogRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VULFxuICB0dHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVCxcbiAgVDogRm9ybWF0cy5USU1FXzI0X1NJTVBMRSxcbiAgVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFMsXG4gIFRUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VULFxuICBUVFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCxcbiAgZjogRm9ybWF0cy5EQVRFVElNRV9TSE9SVCxcbiAgZmY6IEZvcm1hdHMuREFURVRJTUVfTUVELFxuICBmZmY6IEZvcm1hdHMuREFURVRJTUVfRlVMTCxcbiAgZmZmZjogRm9ybWF0cy5EQVRFVElNRV9IVUdFLFxuICBGOiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyxcbiAgRkY6IEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyxcbiAgRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTLFxuICBGRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9ybWF0dGVyIHtcbiAgc3RhdGljIGNyZWF0ZShsb2NhbGUsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgRm9ybWF0dGVyKGxvY2FsZSwgb3B0cyk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VGb3JtYXQoZm10KSB7XG4gICAgbGV0IGN1cnJlbnQgPSBudWxsLFxuICAgICAgY3VycmVudEZ1bGwgPSBcIlwiLFxuICAgICAgYnJhY2tldGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3BsaXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBmbXQuY2hhckF0KGkpO1xuICAgICAgaWYgKGMgPT09IFwiJ1wiKSB7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiBicmFja2V0ZWQsIHZhbDogY3VycmVudEZ1bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRGdWxsID0gXCJcIjtcbiAgICAgICAgYnJhY2tldGVkID0gIWJyYWNrZXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoYnJhY2tldGVkKSB7XG4gICAgICAgIGN1cnJlbnRGdWxsICs9IGM7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiBmYWxzZSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RnVsbCA9IGM7XG4gICAgICAgIGN1cnJlbnQgPSBjO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IGJyYWNrZXRlZCwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRzO1xuICB9XG5cbiAgc3RhdGljIG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4pIHtcbiAgICByZXR1cm4gbWFjcm9Ub2tlblRvRm9ybWF0T3B0c1t0b2tlbl07XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGZvcm1hdE9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBmb3JtYXRPcHRzO1xuICAgIHRoaXMubG9jID0gbG9jYWxlO1xuICAgIHRoaXMuc3lzdGVtTG9jID0gbnVsbDtcbiAgfVxuXG4gIGZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0KGR0LCBvcHRzKSB7XG4gICAgaWYgKHRoaXMuc3lzdGVtTG9jID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN5c3RlbUxvYyA9IHRoaXMubG9jLnJlZGVmYXVsdFRvU3lzdGVtKCk7XG4gICAgfVxuICAgIGNvbnN0IGRmID0gdGhpcy5zeXN0ZW1Mb2MuZHRGb3JtYXR0ZXIoZHQsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0cywgb3B0cykpO1xuICAgIHJldHVybiBkZi5mb3JtYXQoKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lKGR0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMsIG9wdHMpKTtcbiAgICByZXR1cm4gZGYuZm9ybWF0KCk7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZVBhcnRzKGR0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMsIG9wdHMpKTtcbiAgICByZXR1cm4gZGYuZm9ybWF0VG9QYXJ0cygpO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKGR0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMsIG9wdHMpKTtcbiAgICByZXR1cm4gZGYucmVzb2x2ZWRPcHRpb25zKCk7XG4gIH1cblxuICBudW0obiwgcCA9IDApIHtcbiAgICAvLyB3ZSBnZXQgc29tZSBwZXJmIG91dCBvZiBkb2luZyB0aGlzIGhlcmUsIGFubm95aW5nbHlcbiAgICBpZiAodGhpcy5vcHRzLmZvcmNlU2ltcGxlKSB7XG4gICAgICByZXR1cm4gcGFkU3RhcnQobiwgcCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0cyk7XG5cbiAgICBpZiAocCA+IDApIHtcbiAgICAgIG9wdHMucGFkVG8gPSBwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxvYy5udW1iZXJGb3JtYXR0ZXIob3B0cykuZm9ybWF0KG4pO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmbXQpIHtcbiAgICBjb25zdCBrbm93bkVuZ2xpc2ggPSB0aGlzLmxvYy5saXN0aW5nTW9kZSgpID09PSBcImVuXCIsXG4gICAgICB1c2VEYXRlVGltZUZvcm1hdHRlciA9XG4gICAgICAgIHRoaXMubG9jLm91dHB1dENhbGVuZGFyICYmIHRoaXMubG9jLm91dHB1dENhbGVuZGFyICE9PSBcImdyZWdvcnlcIiAmJiBoYXNGb3JtYXRUb1BhcnRzKCksXG4gICAgICBzdHJpbmcgPSAob3B0cywgZXh0cmFjdCkgPT4gdGhpcy5sb2MuZXh0cmFjdChkdCwgb3B0cywgZXh0cmFjdCksXG4gICAgICBmb3JtYXRPZmZzZXQgPSBvcHRzID0+IHtcbiAgICAgICAgaWYgKGR0LmlzT2Zmc2V0Rml4ZWQgJiYgZHQub2Zmc2V0ID09PSAwICYmIG9wdHMuYWxsb3daKSB7XG4gICAgICAgICAgcmV0dXJuIFwiWlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQgPyBkdC56b25lLmZvcm1hdE9mZnNldChkdC50cywgb3B0cy5mb3JtYXQpIDogXCJcIjtcbiAgICAgIH0sXG4gICAgICBtZXJpZGllbSA9ICgpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC5tZXJpZGllbUZvckRhdGVUaW1lKGR0KVxuICAgICAgICAgIDogc3RyaW5nKHsgaG91cjogXCJudW1lcmljXCIsIGhvdXIxMjogdHJ1ZSB9LCBcImRheXBlcmlvZFwiKSxcbiAgICAgIG1vbnRoID0gKGxlbmd0aCwgc3RhbmRhbG9uZSkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLm1vbnRoRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aClcbiAgICAgICAgICA6IHN0cmluZyhzdGFuZGFsb25lID8geyBtb250aDogbGVuZ3RoIH0gOiB7IG1vbnRoOiBsZW5ndGgsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKSxcbiAgICAgIHdlZWtkYXkgPSAobGVuZ3RoLCBzdGFuZGFsb25lKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gud2Vla2RheUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpXG4gICAgICAgICAgOiBzdHJpbmcoXG4gICAgICAgICAgICAgIHN0YW5kYWxvbmUgPyB7IHdlZWtkYXk6IGxlbmd0aCB9IDogeyB3ZWVrZGF5OiBsZW5ndGgsIG1vbnRoOiBcImxvbmdcIiwgZGF5OiBcIm51bWVyaWNcIiB9LFxuICAgICAgICAgICAgICBcIndlZWtkYXlcIlxuICAgICAgICAgICAgKSxcbiAgICAgIG1heWJlTWFjcm8gPSB0b2tlbiA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdE9wdHMgPSBGb3JtYXR0ZXIubWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbik7XG4gICAgICAgIGlmIChmb3JtYXRPcHRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIGZvcm1hdE9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVyYSA9IGxlbmd0aCA9PlxuICAgICAgICBrbm93bkVuZ2xpc2ggPyBFbmdsaXNoLmVyYUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIDogc3RyaW5nKHsgZXJhOiBsZW5ndGggfSwgXCJlcmFcIiksXG4gICAgICB0b2tlblRvU3RyaW5nID0gdG9rZW4gPT4ge1xuICAgICAgICAvLyBXaGVyZSBwb3NzaWJsZTogaHR0cDovL2NsZHIudW5pY29kZS5vcmcvdHJhbnNsYXRpb24vZGF0ZS10aW1lLTEvZGF0ZS10aW1lI1RPQy1TdGFuZGFsb25lLXZzLi1Gb3JtYXQtU3R5bGVzXG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAvLyBtc1xuICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWlsbGlzZWNvbmQpO1xuICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taWxsaXNlY29uZCwgMyk7XG4gICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuc2Vjb25kKTtcbiAgICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5zZWNvbmQsIDIpO1xuICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbnV0ZSk7XG4gICAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWludXRlLCAyKTtcbiAgICAgICAgICAvLyBob3Vyc1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIpO1xuICAgICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIgJSAxMiA9PT0gMCA/IDEyIDogZHQuaG91ciAlIDEyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIpO1xuICAgICAgICAgIGNhc2UgXCJISFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIsIDIpO1xuICAgICAgICAgIC8vIG9mZnNldFxuICAgICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICs2XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcIm5hcnJvd1wiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICswNjowMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJzaG9ydFwiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArMDYwMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJ0ZWNoaWVcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVTVFxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwic2hvcnRcIiwgbG9jYWxlOiB0aGlzLmxvYy5sb2NhbGUgfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVhc3Rlcm4gU3RhbmRhcmQgVGltZVxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwibG9uZ1wiLCBsb2NhbGU6IHRoaXMubG9jLmxvY2FsZSB9KTtcbiAgICAgICAgICAvLyB6b25lXG4gICAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW1lcmljYS9OZXdfWW9ya1xuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmVOYW1lO1xuICAgICAgICAgIC8vIG1lcmlkaWVtc1xuICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICByZXR1cm4gbWVyaWRpZW0oKTtcbiAgICAgICAgICAvLyBkYXRlc1xuICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyBkYXk6IFwibnVtZXJpY1wiIH0sIFwiZGF5XCIpIDogdGhpcy5udW0oZHQuZGF5KTtcbiAgICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IGRheTogXCIyLWRpZ2l0XCIgfSwgXCJkYXlcIikgOiB0aGlzLm51bShkdC5kYXksIDIpO1xuICAgICAgICAgIC8vIHdlZWtkYXlzIC0gc3RhbmRhbG9uZVxuICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlc2RheSdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1QnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyB3ZWVrZGF5cyAtIGZvcm1hdFxuICAgICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXNkYXknXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcImxvbmdcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJFRUVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBzdGFuZGFsb25lXG4gICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwibnVtZXJpY1wiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCk7XG4gICAgICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxLCBkb2Vzbid0IHNlZW0gdG8gd29ya1xuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwiMi1kaWdpdFwiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCwgMik7XG4gICAgICAgICAgY2FzZSBcIkxMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW5cbiAgICAgICAgICAgIHJldHVybiBtb250aChcInNob3J0XCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphbnVhcnlcbiAgICAgICAgICAgIHJldHVybiBtb250aChcImxvbmdcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcIkxMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBmb3JtYXRcbiAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoKTtcbiAgICAgICAgICBjYXNlIFwiTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIjItZGlnaXRcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgsIDIpO1xuICAgICAgICAgIGNhc2UgXCJNTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFuXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFudWFyeVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCBmYWxzZSk7XG4gICAgICAgICAgLy8geWVhcnNcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAyMDE0XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIikgOiB0aGlzLm51bShkdC55ZWFyKTtcbiAgICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMTRcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwiMi1kaWdpdFwiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAwMTJcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIsIDQpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDAwMDEyXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLCA2KTtcbiAgICAgICAgICAvLyBlcmFzXG4gICAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQURcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJzaG9ydFwiKTtcbiAgICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW5ubyBEb21pbmlcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJsb25nXCIpO1xuICAgICAgICAgIGNhc2UgXCJHR0dHR1wiOlxuICAgICAgICAgICAgcmV0dXJuIGVyYShcIm5hcnJvd1wiKTtcbiAgICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhciwgNCk7XG4gICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyKTtcbiAgICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwpO1xuICAgICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5vcmRpbmFsLCAzKTtcbiAgICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlcik7XG4gICAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlciwgMik7XG4gICAgICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0LnRzIC8gMTAwMCkpO1xuICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQudHMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVNYWNybyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLCB0b2tlblRvU3RyaW5nKTtcbiAgfVxuXG4gIGZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyhkdXIsIGZtdCkge1xuICAgIGNvbnN0IHRva2VuVG9GaWVsZCA9IHRva2VuID0+IHtcbiAgICAgICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtaWxsaXNlY29uZFwiO1xuICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJzZWNvbmRcIjtcbiAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibWludXRlXCI7XG4gICAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICAgIHJldHVybiBcImhvdXJcIjtcbiAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZGF5XCI7XG4gICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInllYXJcIjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlblRvU3RyaW5nID0gbGlsZHVyID0+IHRva2VuID0+IHtcbiAgICAgICAgY29uc3QgbWFwcGVkID0gdG9rZW5Ub0ZpZWxkKHRva2VuKTtcbiAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm51bShsaWxkdXIuZ2V0KG1hcHBlZCksIHRva2VuLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9rZW5zID0gRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksXG4gICAgICByZWFsVG9rZW5zID0gdG9rZW5zLnJlZHVjZShcbiAgICAgICAgKGZvdW5kLCB7IGxpdGVyYWwsIHZhbCB9KSA9PiAobGl0ZXJhbCA/IGZvdW5kIDogZm91bmQuY29uY2F0KHZhbCkpLFxuICAgICAgICBbXVxuICAgICAgKSxcbiAgICAgIGNvbGxhcHNlZCA9IGR1ci5zaGlmdFRvKC4uLnJlYWxUb2tlbnMubWFwKHRva2VuVG9GaWVsZCkuZmlsdGVyKHQgPT4gdCkpO1xuICAgIHJldHVybiBzdHJpbmdpZnlUb2tlbnModG9rZW5zLCB0b2tlblRvU3RyaW5nKGNvbGxhcHNlZCkpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRW5nbGlzaCIsIkZvcm1hdHMiLCJoYXNGb3JtYXRUb1BhcnRzIiwicGFkU3RhcnQiLCJzdHJpbmdpZnlUb2tlbnMiLCJzcGxpdHMiLCJ0b2tlblRvU3RyaW5nIiwicyIsInRva2VuIiwibGl0ZXJhbCIsInZhbCIsIm1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHMiLCJEIiwiREFURV9TSE9SVCIsIkREIiwiREFURV9NRUQiLCJEREQiLCJEQVRFX0ZVTEwiLCJEREREIiwiREFURV9IVUdFIiwidCIsIlRJTUVfU0lNUExFIiwidHQiLCJUSU1FX1dJVEhfU0VDT05EUyIsInR0dCIsIlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQiLCJ0dHR0IiwiVElNRV9XSVRIX0xPTkdfT0ZGU0VUIiwiVCIsIlRJTUVfMjRfU0lNUExFIiwiVFQiLCJUSU1FXzI0X1dJVEhfU0VDT05EUyIsIlRUVCIsIlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQiLCJUVFRUIiwiVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUIiwiZiIsIkRBVEVUSU1FX1NIT1JUIiwiZmYiLCJEQVRFVElNRV9NRUQiLCJmZmYiLCJEQVRFVElNRV9GVUxMIiwiZmZmZiIsIkRBVEVUSU1FX0hVR0UiLCJGIiwiREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTIiwiRkYiLCJEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTIiwiRkZGIiwiREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMiLCJGRkZGIiwiREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMiLCJGb3JtYXR0ZXIiLCJjcmVhdGUiLCJsb2NhbGUiLCJvcHRzIiwicGFyc2VGb3JtYXQiLCJmbXQiLCJjdXJyZW50IiwiY3VycmVudEZ1bGwiLCJicmFja2V0ZWQiLCJpIiwibGVuZ3RoIiwiYyIsImNoYXJBdCIsInB1c2giLCJjb25zdHJ1Y3RvciIsImZvcm1hdE9wdHMiLCJsb2MiLCJzeXN0ZW1Mb2MiLCJmb3JtYXRXaXRoU3lzdGVtRGVmYXVsdCIsImR0IiwicmVkZWZhdWx0VG9TeXN0ZW0iLCJkZiIsImR0Rm9ybWF0dGVyIiwiT2JqZWN0IiwiYXNzaWduIiwiZm9ybWF0IiwiZm9ybWF0RGF0ZVRpbWUiLCJmb3JtYXREYXRlVGltZVBhcnRzIiwiZm9ybWF0VG9QYXJ0cyIsInJlc29sdmVkT3B0aW9ucyIsIm51bSIsIm4iLCJwIiwiZm9yY2VTaW1wbGUiLCJwYWRUbyIsIm51bWJlckZvcm1hdHRlciIsImZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyIsImtub3duRW5nbGlzaCIsImxpc3RpbmdNb2RlIiwidXNlRGF0ZVRpbWVGb3JtYXR0ZXIiLCJvdXRwdXRDYWxlbmRhciIsInN0cmluZyIsImV4dHJhY3QiLCJmb3JtYXRPZmZzZXQiLCJpc09mZnNldEZpeGVkIiwib2Zmc2V0IiwiYWxsb3daIiwiaXNWYWxpZCIsInpvbmUiLCJ0cyIsIm1lcmlkaWVtIiwibWVyaWRpZW1Gb3JEYXRlVGltZSIsImhvdXIiLCJob3VyMTIiLCJtb250aCIsInN0YW5kYWxvbmUiLCJtb250aEZvckRhdGVUaW1lIiwiZGF5Iiwid2Vla2RheSIsIndlZWtkYXlGb3JEYXRlVGltZSIsIm1heWJlTWFjcm8iLCJlcmEiLCJlcmFGb3JEYXRlVGltZSIsIm1pbGxpc2Vjb25kIiwic2Vjb25kIiwibWludXRlIiwib2Zmc2V0TmFtZSIsInpvbmVOYW1lIiwieWVhciIsInRvU3RyaW5nIiwic2xpY2UiLCJ3ZWVrWWVhciIsIndlZWtOdW1iZXIiLCJvcmRpbmFsIiwicXVhcnRlciIsIk1hdGgiLCJmbG9vciIsImZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyIsImR1ciIsInRva2VuVG9GaWVsZCIsImxpbGR1ciIsIm1hcHBlZCIsImdldCIsInRva2VucyIsInJlYWxUb2tlbnMiLCJyZWR1Y2UiLCJmb3VuZCIsImNvbmNhdCIsImNvbGxhcHNlZCIsInNoaWZ0VG8iLCJtYXAiLCJmaWx0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/impl/formatter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/impl/invalid.js":
/*!************************************************!*\
  !*** ./node_modules/luxon/src/impl/invalid.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Invalid)\n/* harmony export */ });\nclass Invalid {\n    constructor(reason, explanation){\n        this.reason = reason;\n        this.explanation = explanation;\n    }\n    toMessage() {\n        if (this.explanation) {\n            return `${this.reason}: ${this.explanation}`;\n        } else {\n            return this.reason;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvaW52YWxpZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWUsTUFBTUE7SUFDbkJDLFlBQVlDLE1BQU0sRUFBRUMsV0FBVyxDQUFFO1FBQy9CLElBQUksQ0FBQ0QsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtJQUNyQjtJQUVBQyxZQUFZO1FBQ1YsSUFBSSxJQUFJLENBQUNELFdBQVcsRUFBRTtZQUNwQixPQUFPLENBQUMsRUFBRSxJQUFJLENBQUNELE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDQyxXQUFXLENBQUMsQ0FBQztRQUM5QyxPQUFPO1lBQ0wsT0FBTyxJQUFJLENBQUNELE1BQU07UUFDcEI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWF0b29scy1uZXh0Ly4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2ludmFsaWQuanM/YzM4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZhbGlkIHtcbiAgY29uc3RydWN0b3IocmVhc29uLCBleHBsYW5hdGlvbikge1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbjtcbiAgfVxuXG4gIHRvTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5leHBsYW5hdGlvbikge1xuICAgICAgcmV0dXJuIGAke3RoaXMucmVhc29ufTogJHt0aGlzLmV4cGxhbmF0aW9ufWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJJbnZhbGlkIiwiY29uc3RydWN0b3IiLCJyZWFzb24iLCJleHBsYW5hdGlvbiIsInRvTWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/impl/invalid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/impl/locale.js":
/*!***********************************************!*\
  !*** ./node_modules/luxon/src/impl/locale.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Locale)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(rsc)/./node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./english.js */ \"(rsc)/./node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../settings.js */ \"(rsc)/./node_modules/luxon/src/settings.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../datetime.js */ \"(rsc)/./node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _formatter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatter.js */ \"(rsc)/./node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(rsc)/./node_modules/luxon/src/zones/IANAZone.js\");\n\n\n\n\n\n\nlet intlDTCache = {};\nfunction getCachedDTF(locString, opts = {}) {\n    const key = JSON.stringify([\n        locString,\n        opts\n    ]);\n    let dtf = intlDTCache[key];\n    if (!dtf) {\n        dtf = new Intl.DateTimeFormat(locString, opts);\n        intlDTCache[key] = dtf;\n    }\n    return dtf;\n}\nlet intlNumCache = {};\nfunction getCachedINF(locString, opts = {}) {\n    const key = JSON.stringify([\n        locString,\n        opts\n    ]);\n    let inf = intlNumCache[key];\n    if (!inf) {\n        inf = new Intl.NumberFormat(locString, opts);\n        intlNumCache[key] = inf;\n    }\n    return inf;\n}\nlet intlRelCache = {};\nfunction getCachedRTF(locString, opts = {}) {\n    const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options\n    const key = JSON.stringify([\n        locString,\n        cacheKeyOpts\n    ]);\n    let inf = intlRelCache[key];\n    if (!inf) {\n        inf = new Intl.RelativeTimeFormat(locString, opts);\n        intlRelCache[key] = inf;\n    }\n    return inf;\n}\nlet sysLocaleCache = null;\nfunction systemLocale() {\n    if (sysLocaleCache) {\n        return sysLocaleCache;\n    } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasIntl)()) {\n        const computedSys = new Intl.DateTimeFormat().resolvedOptions().locale;\n        // node sometimes defaults to \"und\". Override that because that is dumb\n        sysLocaleCache = !computedSys || computedSys === \"und\" ? \"en-US\" : computedSys;\n        return sysLocaleCache;\n    } else {\n        sysLocaleCache = \"en-US\";\n        return sysLocaleCache;\n    }\n}\nfunction parseLocaleString(localeStr) {\n    // I really want to avoid writing a BCP 47 parser\n    // see, e.g. https://github.com/wooorm/bcp-47\n    // Instead, we'll do this:\n    // a) if the string has no -u extensions, just leave it alone\n    // b) if it does, use Intl to resolve everything\n    // c) if Intl fails, try again without the -u\n    const uIndex = localeStr.indexOf(\"-u-\");\n    if (uIndex === -1) {\n        return [\n            localeStr\n        ];\n    } else {\n        let options;\n        const smaller = localeStr.substring(0, uIndex);\n        try {\n            options = getCachedDTF(localeStr).resolvedOptions();\n        } catch (e) {\n            options = getCachedDTF(smaller).resolvedOptions();\n        }\n        const { numberingSystem, calendar } = options;\n        // return the smaller one so that we can append the calendar and numbering overrides to it\n        return [\n            smaller,\n            numberingSystem,\n            calendar\n        ];\n    }\n}\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasIntl)()) {\n        if (outputCalendar || numberingSystem) {\n            localeStr += \"-u\";\n            if (outputCalendar) {\n                localeStr += `-ca-${outputCalendar}`;\n            }\n            if (numberingSystem) {\n                localeStr += `-nu-${numberingSystem}`;\n            }\n            return localeStr;\n        } else {\n            return localeStr;\n        }\n    } else {\n        return [];\n    }\n}\nfunction mapMonths(f) {\n    const ms = [];\n    for(let i = 1; i <= 12; i++){\n        const dt = _datetime_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].utc(2016, i, 1);\n        ms.push(f(dt));\n    }\n    return ms;\n}\nfunction mapWeekdays(f) {\n    const ms = [];\n    for(let i = 1; i <= 7; i++){\n        const dt = _datetime_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].utc(2016, 11, 13 + i);\n        ms.push(f(dt));\n    }\n    return ms;\n}\nfunction listStuff(loc, length, defaultOK, englishFn, intlFn) {\n    const mode = loc.listingMode(defaultOK);\n    if (mode === \"error\") {\n        return null;\n    } else if (mode === \"en\") {\n        return englishFn(length);\n    } else {\n        return intlFn(length);\n    }\n}\nfunction supportsFastNumbers(loc) {\n    if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n        return false;\n    } else {\n        return loc.numberingSystem === \"latn\" || !loc.locale || loc.locale.startsWith(\"en\") || (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasIntl)() && new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === \"latn\";\n    }\n}\n/**\n * @private\n */ class PolyNumberFormatter {\n    constructor(intl, forceSimple, opts){\n        this.padTo = opts.padTo || 0;\n        this.floor = opts.floor || false;\n        if (!forceSimple && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasIntl)()) {\n            const intlOpts = {\n                useGrouping: false\n            };\n            if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n            this.inf = getCachedINF(intl, intlOpts);\n        }\n    }\n    format(i) {\n        if (this.inf) {\n            const fixed = this.floor ? Math.floor(i) : i;\n            return this.inf.format(fixed);\n        } else {\n            // to match the browser's numberformatter defaults\n            const fixed = this.floor ? Math.floor(i) : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.roundTo)(i, 3);\n            return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(fixed, this.padTo);\n        }\n    }\n}\n/**\n * @private\n */ class PolyDateFormatter {\n    constructor(dt, intl, opts){\n        this.opts = opts;\n        this.hasIntl = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasIntl)();\n        let z;\n        if (dt.zone.universal && this.hasIntl) {\n            // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\n            // That is why fixed-offset TZ is set to that unless it is:\n            // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\n            // 2. Unsupported by the browser:\n            //    - some do not support Etc/\n            //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\n            const gmtOffset = -1 * (dt.offset / 60);\n            const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;\n            const isOffsetZoneSupported = _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isValidZone(offsetZ);\n            if (dt.offset !== 0 && isOffsetZoneSupported) {\n                z = offsetZ;\n                this.dt = dt;\n            } else {\n                // Not all fixed-offset zones like Etc/+4:30 are present in tzdata.\n                // So we have to make do. Two cases:\n                // 1. The format options tell us to show the zone. We can't do that, so the best\n                // we can do is format the date in UTC.\n                // 2. The format options don't tell us to show the zone. Then we can adjust them\n                // the time and tell the formatter to show it to us in UTC, so that the time is right\n                // and the bad zone doesn't show up.\n                z = \"UTC\";\n                if (opts.timeZoneName) {\n                    this.dt = dt;\n                } else {\n                    this.dt = dt.offset === 0 ? dt : _datetime_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromMillis(dt.ts + dt.offset * 60 * 1000);\n                }\n            }\n        } else if (dt.zone.type === \"local\") {\n            this.dt = dt;\n        } else {\n            this.dt = dt;\n            z = dt.zone.name;\n        }\n        if (this.hasIntl) {\n            const intlOpts = Object.assign({}, this.opts);\n            if (z) {\n                intlOpts.timeZone = z;\n            }\n            this.dtf = getCachedDTF(intl, intlOpts);\n        }\n    }\n    format() {\n        if (this.hasIntl) {\n            return this.dtf.format(this.dt.toJSDate());\n        } else {\n            const tokenFormat = _english_js__WEBPACK_IMPORTED_MODULE_3__.formatString(this.opts), loc = Locale.create(\"en-US\");\n            return _formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(loc).formatDateTimeFromString(this.dt, tokenFormat);\n        }\n    }\n    formatToParts() {\n        if (this.hasIntl && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasFormatToParts)()) {\n            return this.dtf.formatToParts(this.dt.toJSDate());\n        } else {\n            // This is kind of a cop out. We actually could do this for English. However, we couldn't do it for intl strings\n            // and IMO it's too weird to have an uncanny valley like that\n            return [];\n        }\n    }\n    resolvedOptions() {\n        if (this.hasIntl) {\n            return this.dtf.resolvedOptions();\n        } else {\n            return {\n                locale: \"en-US\",\n                numberingSystem: \"latn\",\n                outputCalendar: \"gregory\"\n            };\n        }\n    }\n}\n/**\n * @private\n */ class PolyRelFormatter {\n    constructor(intl, isEnglish, opts){\n        this.opts = Object.assign({\n            style: \"long\"\n        }, opts);\n        if (!isEnglish && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasRelative)()) {\n            this.rtf = getCachedRTF(intl, opts);\n        }\n    }\n    format(count, unit) {\n        if (this.rtf) {\n            return this.rtf.format(count, unit);\n        } else {\n            return _english_js__WEBPACK_IMPORTED_MODULE_3__.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n        }\n    }\n    formatToParts(count, unit) {\n        if (this.rtf) {\n            return this.rtf.formatToParts(count, unit);\n        } else {\n            return [];\n        }\n    }\n}\n/**\n * @private\n */ class Locale {\n    static fromOpts(opts) {\n        return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);\n    }\n    static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {\n        const specifiedLocale = locale || _settings_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].defaultLocale, // the system locale is useful for human readable strings but annoying for parsing/formatting known formats\n        localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale()), numberingSystemR = numberingSystem || _settings_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].defaultNumberingSystem, outputCalendarR = outputCalendar || _settings_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].defaultOutputCalendar;\n        return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);\n    }\n    static resetCache() {\n        sysLocaleCache = null;\n        intlDTCache = {};\n        intlNumCache = {};\n        intlRelCache = {};\n    }\n    static fromObject({ locale, numberingSystem, outputCalendar } = {}) {\n        return Locale.create(locale, numberingSystem, outputCalendar);\n    }\n    constructor(locale, numbering, outputCalendar, specifiedLocale){\n        const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n        this.locale = parsedLocale;\n        this.numberingSystem = numbering || parsedNumberingSystem || null;\n        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n        this.weekdaysCache = {\n            format: {},\n            standalone: {}\n        };\n        this.monthsCache = {\n            format: {},\n            standalone: {}\n        };\n        this.meridiemCache = null;\n        this.eraCache = {};\n        this.specifiedLocale = specifiedLocale;\n        this.fastNumbersCached = null;\n    }\n    get fastNumbers() {\n        if (this.fastNumbersCached == null) {\n            this.fastNumbersCached = supportsFastNumbers(this);\n        }\n        return this.fastNumbersCached;\n    }\n    listingMode(defaultOK = true) {\n        const intl = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasIntl)(), hasFTP = intl && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasFormatToParts)(), isActuallyEn = this.isEnglish(), hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === \"latn\") && (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n        if (!hasFTP && !(isActuallyEn && hasNoWeirdness) && !defaultOK) {\n            return \"error\";\n        } else if (!hasFTP || isActuallyEn && hasNoWeirdness) {\n            return \"en\";\n        } else {\n            return \"intl\";\n        }\n    }\n    clone(alts) {\n        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n            return this;\n        } else {\n            return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);\n        }\n    }\n    redefaultToEN(alts = {}) {\n        return this.clone(Object.assign({}, alts, {\n            defaultToEN: true\n        }));\n    }\n    redefaultToSystem(alts = {}) {\n        return this.clone(Object.assign({}, alts, {\n            defaultToEN: false\n        }));\n    }\n    months(length, format = false, defaultOK = true) {\n        return listStuff(this, length, defaultOK, _english_js__WEBPACK_IMPORTED_MODULE_3__.months, ()=>{\n            const intl = format ? {\n                month: length,\n                day: \"numeric\"\n            } : {\n                month: length\n            }, formatStr = format ? \"format\" : \"standalone\";\n            if (!this.monthsCache[formatStr][length]) {\n                this.monthsCache[formatStr][length] = mapMonths((dt)=>this.extract(dt, intl, \"month\"));\n            }\n            return this.monthsCache[formatStr][length];\n        });\n    }\n    weekdays(length, format = false, defaultOK = true) {\n        return listStuff(this, length, defaultOK, _english_js__WEBPACK_IMPORTED_MODULE_3__.weekdays, ()=>{\n            const intl = format ? {\n                weekday: length,\n                year: \"numeric\",\n                month: \"long\",\n                day: \"numeric\"\n            } : {\n                weekday: length\n            }, formatStr = format ? \"format\" : \"standalone\";\n            if (!this.weekdaysCache[formatStr][length]) {\n                this.weekdaysCache[formatStr][length] = mapWeekdays((dt)=>this.extract(dt, intl, \"weekday\"));\n            }\n            return this.weekdaysCache[formatStr][length];\n        });\n    }\n    meridiems(defaultOK = true) {\n        return listStuff(this, undefined, defaultOK, ()=>_english_js__WEBPACK_IMPORTED_MODULE_3__.meridiems, ()=>{\n            // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n            // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n            if (!this.meridiemCache) {\n                const intl = {\n                    hour: \"numeric\",\n                    hour12: true\n                };\n                this.meridiemCache = [\n                    _datetime_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].utc(2016, 11, 13, 9),\n                    _datetime_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].utc(2016, 11, 13, 19)\n                ].map((dt)=>this.extract(dt, intl, \"dayperiod\"));\n            }\n            return this.meridiemCache;\n        });\n    }\n    eras(length, defaultOK = true) {\n        return listStuff(this, length, defaultOK, _english_js__WEBPACK_IMPORTED_MODULE_3__.eras, ()=>{\n            const intl = {\n                era: length\n            };\n            // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n            // to definitely enumerate them.\n            if (!this.eraCache[length]) {\n                this.eraCache[length] = [\n                    _datetime_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].utc(-40, 1, 1),\n                    _datetime_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].utc(2017, 1, 1)\n                ].map((dt)=>this.extract(dt, intl, \"era\"));\n            }\n            return this.eraCache[length];\n        });\n    }\n    extract(dt, intlOpts, field) {\n        const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m)=>m.type.toLowerCase() === field);\n        return matching ? matching.value : null;\n    }\n    numberFormatter(opts = {}) {\n        // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n        // (in contrast, the rest of the condition is used heavily)\n        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n    }\n    dtFormatter(dt, intlOpts = {}) {\n        return new PolyDateFormatter(dt, this.intl, intlOpts);\n    }\n    relFormatter(opts = {}) {\n        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n    }\n    isEnglish() {\n        return this.locale === \"en\" || this.locale.toLowerCase() === \"en-us\" || (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasIntl)() && new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith(\"en-us\");\n    }\n    equals(other) {\n        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvbG9jYWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBc0Y7QUFDOUM7QUFDRjtBQUNBO0FBQ0M7QUFDSztBQUU1QyxJQUFJVSxjQUFjLENBQUM7QUFDbkIsU0FBU0MsYUFBYUMsU0FBUyxFQUFFQyxPQUFPLENBQUMsQ0FBQztJQUN4QyxNQUFNQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7UUFBQ0o7UUFBV0M7S0FBSztJQUM1QyxJQUFJSSxNQUFNUCxXQUFXLENBQUNJLElBQUk7SUFDMUIsSUFBSSxDQUFDRyxLQUFLO1FBQ1JBLE1BQU0sSUFBSUMsS0FBS0MsY0FBYyxDQUFDUCxXQUFXQztRQUN6Q0gsV0FBVyxDQUFDSSxJQUFJLEdBQUdHO0lBQ3JCO0lBQ0EsT0FBT0E7QUFDVDtBQUVBLElBQUlHLGVBQWUsQ0FBQztBQUNwQixTQUFTQyxhQUFhVCxTQUFTLEVBQUVDLE9BQU8sQ0FBQyxDQUFDO0lBQ3hDLE1BQU1DLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztRQUFDSjtRQUFXQztLQUFLO0lBQzVDLElBQUlTLE1BQU1GLFlBQVksQ0FBQ04sSUFBSTtJQUMzQixJQUFJLENBQUNRLEtBQUs7UUFDUkEsTUFBTSxJQUFJSixLQUFLSyxZQUFZLENBQUNYLFdBQVdDO1FBQ3ZDTyxZQUFZLENBQUNOLElBQUksR0FBR1E7SUFDdEI7SUFDQSxPQUFPQTtBQUNUO0FBRUEsSUFBSUUsZUFBZSxDQUFDO0FBQ3BCLFNBQVNDLGFBQWFiLFNBQVMsRUFBRUMsT0FBTyxDQUFDLENBQUM7SUFDeEMsTUFBTSxFQUFFYSxJQUFJLEVBQUUsR0FBR0MsY0FBYyxHQUFHZCxNQUFNLGtDQUFrQztJQUMxRSxNQUFNQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7UUFBQ0o7UUFBV2U7S0FBYTtJQUNwRCxJQUFJTCxNQUFNRSxZQUFZLENBQUNWLElBQUk7SUFDM0IsSUFBSSxDQUFDUSxLQUFLO1FBQ1JBLE1BQU0sSUFBSUosS0FBS1Us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QU8sQ0FBQyxDQUFDLEVBQUU7UUFDdEIsT0FBTyxJQUFJdUYsaUJBQWlCLElBQUksQ0FBQ3BDLElBQUksRUFBRSxJQUFJLENBQUNxQyxTQUFTLElBQUl4RjtJQUMzRDtJQUVBd0YsWUFBWTtRQUNWLE9BQ0UsSUFBSSxDQUFDcEUsTUFBTSxLQUFLLFFBQ2hCLElBQUksQ0FBQ0EsTUFBTSxDQUFDK0gsV0FBVyxPQUFPLFdBQzdCL0osaURBQU9BLE1BQU0sSUFBSWlCLEtBQUtDLGNBQWMsQ0FBQyxJQUFJLENBQUM2QyxJQUFJLEVBQUVoQyxlQUFlLEdBQUdDLE1BQU0sQ0FBQzhCLFVBQVUsQ0FBQztJQUV6RjtJQUVBcUcsT0FBT0MsS0FBSyxFQUFFO1FBQ1osT0FDRSxJQUFJLENBQUNwSSxNQUFNLEtBQUtvSSxNQUFNcEksTUFBTSxJQUM1QixJQUFJLENBQUNTLGVBQWUsS0FBSzJILE1BQU0zSCxlQUFlLElBQzlDLElBQUksQ0FBQ0csY0FBYyxLQUFLd0gsTUFBTXhILGNBQWM7SUFFaEQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2lhdG9vbHMtbmV4dC8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9sb2NhbGUuanM/YTc2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNGb3JtYXRUb1BhcnRzLCBoYXNJbnRsLCBwYWRTdGFydCwgcm91bmRUbywgaGFzUmVsYXRpdmUgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbmxldCBpbnRsRFRDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkRFRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGR0ZiA9IGludGxEVENhY2hlW2tleV07XG4gIGlmICghZHRmKSB7XG4gICAgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsRFRDYWNoZVtrZXldID0gZHRmO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmxldCBpbnRsTnVtQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZElORihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsTnVtQ2FjaGVba2V5XTtcbiAgaWYgKCFpbmYpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTnVtQ2FjaGVba2V5XSA9IGluZjtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgaW50bFJlbENhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRSVEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBiYXNlLCAuLi5jYWNoZUtleU9wdHMgfSA9IG9wdHM7IC8vIGV4Y2x1ZGUgYGJhc2VgIGZyb20gdGhlIG9wdGlvbnNcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgY2FjaGVLZXlPcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsUmVsQ2FjaGVba2V5XTtcbiAgaWYgKCFpbmYpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsUmVsQ2FjaGVba2V5XSA9IGluZjtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuZnVuY3Rpb24gc3lzdGVtTG9jYWxlKCkge1xuICBpZiAoc3lzTG9jYWxlQ2FjaGUpIHtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH0gZWxzZSBpZiAoaGFzSW50bCgpKSB7XG4gICAgY29uc3QgY29tcHV0ZWRTeXMgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTtcbiAgICAvLyBub2RlIHNvbWV0aW1lcyBkZWZhdWx0cyB0byBcInVuZFwiLiBPdmVycmlkZSB0aGF0IGJlY2F1c2UgdGhhdCBpcyBkdW1iXG4gICAgc3lzTG9jYWxlQ2FjaGUgPSAhY29tcHV0ZWRTeXMgfHwgY29tcHV0ZWRTeXMgPT09IFwidW5kXCIgPyBcImVuLVVTXCIgOiBjb21wdXRlZFN5cztcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH0gZWxzZSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBcImVuLVVTXCI7XG4gICAgcmV0dXJuIHN5c0xvY2FsZUNhY2hlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZVN0cikge1xuICAvLyBJIHJlYWxseSB3YW50IHRvIGF2b2lkIHdyaXRpbmcgYSBCQ1AgNDcgcGFyc2VyXG4gIC8vIHNlZSwgZS5nLiBodHRwczovL2dpdGh1Yi5jb20vd29vb3JtL2JjcC00N1xuICAvLyBJbnN0ZWFkLCB3ZSdsbCBkbyB0aGlzOlxuXG4gIC8vIGEpIGlmIHRoZSBzdHJpbmcgaGFzIG5vIC11IGV4dGVuc2lvbnMsIGp1c3QgbGVhdmUgaXQgYWxvbmVcbiAgLy8gYikgaWYgaXQgZG9lcywgdXNlIEludGwgdG8gcmVzb2x2ZSBldmVyeXRoaW5nXG4gIC8vIGMpIGlmIEludGwgZmFpbHMsIHRyeSBhZ2FpbiB3aXRob3V0IHRoZSAtdVxuXG4gIGNvbnN0IHVJbmRleCA9IGxvY2FsZVN0ci5pbmRleE9mKFwiLXUtXCIpO1xuICBpZiAodUluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBbbG9jYWxlU3RyXTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBjb25zdCBzbWFsbGVyID0gbG9jYWxlU3RyLnN1YnN0cmluZygwLCB1SW5kZXgpO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKGxvY2FsZVN0cikucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb3B0aW9ucyA9IGdldENhY2hlZERURihzbWFsbGVyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXIgfSA9IG9wdGlvbnM7XG4gICAgLy8gcmV0dXJuIHRoZSBzbWFsbGVyIG9uZSBzbyB0aGF0IHdlIGNhbiBhcHBlbmQgdGhlIGNhbGVuZGFyIGFuZCBudW1iZXJpbmcgb3ZlcnJpZGVzIHRvIGl0XG4gICAgcmV0dXJuIFtzbWFsbGVyLCBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRsQ29uZmlnU3RyaW5nKGxvY2FsZVN0ciwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikge1xuICBpZiAoaGFzSW50bCgpKSB7XG4gICAgaWYgKG91dHB1dENhbGVuZGFyIHx8IG51bWJlcmluZ1N5c3RlbSkge1xuICAgICAgbG9jYWxlU3RyICs9IFwiLXVcIjtcblxuICAgICAgaWYgKG91dHB1dENhbGVuZGFyKSB7XG4gICAgICAgIGxvY2FsZVN0ciArPSBgLWNhLSR7b3V0cHV0Q2FsZW5kYXJ9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKG51bWJlcmluZ1N5c3RlbSkge1xuICAgICAgICBsb2NhbGVTdHIgKz0gYC1udS0ke251bWJlcmluZ1N5c3RlbX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcE1vbnRocyhmKSB7XG4gIGNvbnN0IG1zID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IDEyOyBpKyspIHtcbiAgICBjb25zdCBkdCA9IERhdGVUaW1lLnV0YygyMDE2LCBpLCAxKTtcbiAgICBtcy5wdXNoKGYoZHQpKTtcbiAgfVxuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIG1hcFdlZWtkYXlzKGYpIHtcbiAgY29uc3QgbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNzsgaSsrKSB7XG4gICAgY29uc3QgZHQgPSBEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzICsgaSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cbiAgcmV0dXJuIG1zO1xufVxuXG5mdW5jdGlvbiBsaXN0U3R1ZmYobG9jLCBsZW5ndGgsIGRlZmF1bHRPSywgZW5nbGlzaEZuLCBpbnRsRm4pIHtcbiAgY29uc3QgbW9kZSA9IGxvYy5saXN0aW5nTW9kZShkZWZhdWx0T0spO1xuXG4gIGlmIChtb2RlID09PSBcImVycm9yXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBcImVuXCIpIHtcbiAgICByZXR1cm4gZW5nbGlzaEZuKGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGludGxGbihsZW5ndGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzRmFzdE51bWJlcnMobG9jKSB7XG4gIGlmIChsb2MubnVtYmVyaW5nU3lzdGVtICYmIGxvYy5udW1iZXJpbmdTeXN0ZW0gIT09IFwibGF0blwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICBsb2MubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIiB8fFxuICAgICAgIWxvYy5sb2NhbGUgfHxcbiAgICAgIGxvYy5sb2NhbGUuc3RhcnRzV2l0aChcImVuXCIpIHx8XG4gICAgICAoaGFzSW50bCgpICYmIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvYy5pbnRsKS5yZXNvbHZlZE9wdGlvbnMoKS5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiKVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNsYXNzIFBvbHlOdW1iZXJGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBmb3JjZVNpbXBsZSwgb3B0cykge1xuICAgIHRoaXMucGFkVG8gPSBvcHRzLnBhZFRvIHx8IDA7XG4gICAgdGhpcy5mbG9vciA9IG9wdHMuZmxvb3IgfHwgZmFsc2U7XG5cbiAgICBpZiAoIWZvcmNlU2ltcGxlICYmIGhhc0ludGwoKSkge1xuICAgICAgY29uc3QgaW50bE9wdHMgPSB7IHVzZUdyb3VwaW5nOiBmYWxzZSB9O1xuICAgICAgaWYgKG9wdHMucGFkVG8gPiAwKSBpbnRsT3B0cy5taW5pbXVtSW50ZWdlckRpZ2l0cyA9IG9wdHMucGFkVG87XG4gICAgICB0aGlzLmluZiA9IGdldENhY2hlZElORihpbnRsLCBpbnRsT3B0cyk7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0KGkpIHtcbiAgICBpZiAodGhpcy5pbmYpIHtcbiAgICAgIGNvbnN0IGZpeGVkID0gdGhpcy5mbG9vciA/IE1hdGguZmxvb3IoaSkgOiBpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5mLmZvcm1hdChmaXhlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRvIG1hdGNoIHRoZSBicm93c2VyJ3MgbnVtYmVyZm9ybWF0dGVyIGRlZmF1bHRzXG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogcm91bmRUbyhpLCAzKTtcbiAgICAgIHJldHVybiBwYWRTdGFydChmaXhlZCwgdGhpcy5wYWRUbyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jbGFzcyBQb2x5RGF0ZUZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGR0LCBpbnRsLCBvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLmhhc0ludGwgPSBoYXNJbnRsKCk7XG5cbiAgICBsZXQgejtcbiAgICBpZiAoZHQuem9uZS51bml2ZXJzYWwgJiYgdGhpcy5oYXNJbnRsKSB7XG4gICAgICAvLyBVVEMtOCBvciBFdGMvVVRDLTggYXJlIG5vdCBwYXJ0IG9mIHR6ZGF0YSwgb25seSBFdGMvR01UKzggYW5kIHRoZSBsaWtlLlxuICAgICAgLy8gVGhhdCBpcyB3aHkgZml4ZWQtb2Zmc2V0IFRaIGlzIHNldCB0byB0aGF0IHVubGVzcyBpdCBpczpcbiAgICAgIC8vIDEuIFJlcHJlc2VudGluZyBvZmZzZXQgMCB3aGVuIFVUQyBpcyB1c2VkIHRvIG1haW50YWluIHByZXZpb3VzIGJlaGF2aW9yIGFuZCBkb2VzIG5vdCBiZWNvbWUgR01ULlxuICAgICAgLy8gMi4gVW5zdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXI6XG4gICAgICAvLyAgICAtIHNvbWUgZG8gbm90IHN1cHBvcnQgRXRjL1xuICAgICAgLy8gICAgLSA8IEV0Yy9HTVQtMTQsID4gRXRjL0dNVCsxMiwgYW5kIDMwLW1pbnV0ZSBvciA0NS1taW51dGUgb2Zmc2V0cyBhcmUgbm90IHBhcnQgb2YgdHpkYXRhXG4gICAgICBjb25zdCBnbXRPZmZzZXQgPSAtMSAqIChkdC5vZmZzZXQgLyA2MCk7XG4gICAgICBjb25zdCBvZmZzZXRaID0gZ210T2Zmc2V0ID49IDAgPyBgRXRjL0dNVCske2dtdE9mZnNldH1gIDogYEV0Yy9HTVQke2dtdE9mZnNldH1gO1xuICAgICAgY29uc3QgaXNPZmZzZXRab25lU3VwcG9ydGVkID0gSUFOQVpvbmUuaXNWYWxpZFpvbmUob2Zmc2V0Wik7XG4gICAgICBpZiAoZHQub2Zmc2V0ICE9PSAwICYmIGlzT2Zmc2V0Wm9uZVN1cHBvcnRlZCkge1xuICAgICAgICB6ID0gb2Zmc2V0WjtcbiAgICAgICAgdGhpcy5kdCA9IGR0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGFsbCBmaXhlZC1vZmZzZXQgem9uZXMgbGlrZSBFdGMvKzQ6MzAgYXJlIHByZXNlbnQgaW4gdHpkYXRhLlxuICAgICAgICAvLyBTbyB3ZSBoYXZlIHRvIG1ha2UgZG8uIFR3byBjYXNlczpcbiAgICAgICAgLy8gMS4gVGhlIGZvcm1hdCBvcHRpb25zIHRlbGwgdXMgdG8gc2hvdyB0aGUgem9uZS4gV2UgY2FuJ3QgZG8gdGhhdCwgc28gdGhlIGJlc3RcbiAgICAgICAgLy8gd2UgY2FuIGRvIGlzIGZvcm1hdCB0aGUgZGF0ZSBpbiBVVEMuXG4gICAgICAgIC8vIDIuIFRoZSBmb3JtYXQgb3B0aW9ucyBkb24ndCB0ZWxsIHVzIHRvIHNob3cgdGhlIHpvbmUuIFRoZW4gd2UgY2FuIGFkanVzdCB0aGVtXG4gICAgICAgIC8vIHRoZSB0aW1lIGFuZCB0ZWxsIHRoZSBmb3JtYXR0ZXIgdG8gc2hvdyBpdCB0byB1cyBpbiBVVEMsIHNvIHRoYXQgdGhlIHRpbWUgaXMgcmlnaHRcbiAgICAgICAgLy8gYW5kIHRoZSBiYWQgem9uZSBkb2Vzbid0IHNob3cgdXAuXG4gICAgICAgIHogPSBcIlVUQ1wiO1xuICAgICAgICBpZiAob3B0cy50aW1lWm9uZU5hbWUpIHtcbiAgICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kdCA9IGR0Lm9mZnNldCA9PT0gMCA/IGR0IDogRGF0ZVRpbWUuZnJvbU1pbGxpcyhkdC50cyArIGR0Lm9mZnNldCAqIDYwICogMTAwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGR0LnpvbmUudHlwZSA9PT0gXCJsb2NhbFwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIHogPSBkdC56b25lLm5hbWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzSW50bCkge1xuICAgICAgY29uc3QgaW50bE9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMpO1xuICAgICAgaWYgKHopIHtcbiAgICAgICAgaW50bE9wdHMudGltZVpvbmUgPSB6O1xuICAgICAgfVxuICAgICAgdGhpcy5kdGYgPSBnZXRDYWNoZWREVEYoaW50bCwgaW50bE9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdCgpIHtcbiAgICBpZiAodGhpcy5oYXNJbnRsKSB7XG4gICAgICByZXR1cm4gdGhpcy5kdGYuZm9ybWF0KHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRva2VuRm9ybWF0ID0gRW5nbGlzaC5mb3JtYXRTdHJpbmcodGhpcy5vcHRzKSxcbiAgICAgICAgbG9jID0gTG9jYWxlLmNyZWF0ZShcImVuLVVTXCIpO1xuICAgICAgcmV0dXJuIEZvcm1hdHRlci5jcmVhdGUobG9jKS5mb3JtYXREYXRlVGltZUZyb21TdHJpbmcodGhpcy5kdCwgdG9rZW5Gb3JtYXQpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdFRvUGFydHMoKSB7XG4gICAgaWYgKHRoaXMuaGFzSW50bCAmJiBoYXNGb3JtYXRUb1BhcnRzKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmR0Zi5mb3JtYXRUb1BhcnRzKHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMga2luZCBvZiBhIGNvcCBvdXQuIFdlIGFjdHVhbGx5IGNvdWxkIGRvIHRoaXMgZm9yIEVuZ2xpc2guIEhvd2V2ZXIsIHdlIGNvdWxkbid0IGRvIGl0IGZvciBpbnRsIHN0cmluZ3NcbiAgICAgIC8vIGFuZCBJTU8gaXQncyB0b28gd2VpcmQgdG8gaGF2ZSBhbiB1bmNhbm55IHZhbGxleSBsaWtlIHRoYXRcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICByZXNvbHZlZE9wdGlvbnMoKSB7XG4gICAgaWYgKHRoaXMuaGFzSW50bCkge1xuICAgICAgcmV0dXJuIHRoaXMuZHRmLnJlc29sdmVkT3B0aW9ucygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbGU6IFwiZW4tVVNcIixcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtOiBcImxhdG5cIixcbiAgICAgICAgb3V0cHV0Q2FsZW5kYXI6IFwiZ3JlZ29yeVwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFBvbHlSZWxGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBpc0VuZ2xpc2gsIG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHsgc3R5bGU6IFwibG9uZ1wiIH0sIG9wdHMpO1xuICAgIGlmICghaXNFbmdsaXNoICYmIGhhc1JlbGF0aXZlKCkpIHtcbiAgICAgIHRoaXMucnRmID0gZ2V0Q2FjaGVkUlRGKGludGwsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBFbmdsaXNoLmZvcm1hdFJlbGF0aXZlVGltZSh1bml0LCBjb3VudCwgdGhpcy5vcHRzLm51bWVyaWMsIHRoaXMub3B0cy5zdHlsZSAhPT0gXCJsb25nXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpIHtcbiAgICBpZiAodGhpcy5ydGYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ0Zi5mb3JtYXRUb1BhcnRzKGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYWxlIHtcbiAgc3RhdGljIGZyb21PcHRzKG9wdHMpIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShvcHRzLmxvY2FsZSwgb3B0cy5udW1iZXJpbmdTeXN0ZW0sIG9wdHMub3V0cHV0Q2FsZW5kYXIsIG9wdHMuZGVmYXVsdFRvRU4pO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIsIGRlZmF1bHRUb0VOID0gZmFsc2UpIHtcbiAgICBjb25zdCBzcGVjaWZpZWRMb2NhbGUgPSBsb2NhbGUgfHwgU2V0dGluZ3MuZGVmYXVsdExvY2FsZSxcbiAgICAgIC8vIHRoZSBzeXN0ZW0gbG9jYWxlIGlzIHVzZWZ1bCBmb3IgaHVtYW4gcmVhZGFibGUgc3RyaW5ncyBidXQgYW5ub3lpbmcgZm9yIHBhcnNpbmcvZm9ybWF0dGluZyBrbm93biBmb3JtYXRzXG4gICAgICBsb2NhbGVSID0gc3BlY2lmaWVkTG9jYWxlIHx8IChkZWZhdWx0VG9FTiA/IFwiZW4tVVNcIiA6IHN5c3RlbUxvY2FsZSgpKSxcbiAgICAgIG51bWJlcmluZ1N5c3RlbVIgPSBudW1iZXJpbmdTeXN0ZW0gfHwgU2V0dGluZ3MuZGVmYXVsdE51bWJlcmluZ1N5c3RlbSxcbiAgICAgIG91dHB1dENhbGVuZGFyUiA9IG91dHB1dENhbGVuZGFyIHx8IFNldHRpbmdzLmRlZmF1bHRPdXRwdXRDYWxlbmRhcjtcbiAgICByZXR1cm4gbmV3IExvY2FsZShsb2NhbGVSLCBudW1iZXJpbmdTeXN0ZW1SLCBvdXRwdXRDYWxlbmRhclIsIHNwZWNpZmllZExvY2FsZSk7XG4gIH1cblxuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICBzeXNMb2NhbGVDYWNoZSA9IG51bGw7XG4gICAgaW50bERUQ2FjaGUgPSB7fTtcbiAgICBpbnRsTnVtQ2FjaGUgPSB7fTtcbiAgICBpbnRsUmVsQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tT2JqZWN0KHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcik7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIG51bWJlcmluZywgb3V0cHV0Q2FsZW5kYXIsIHNwZWNpZmllZExvY2FsZSkge1xuICAgIGNvbnN0IFtwYXJzZWRMb2NhbGUsIHBhcnNlZE51bWJlcmluZ1N5c3RlbSwgcGFyc2VkT3V0cHV0Q2FsZW5kYXJdID0gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlKTtcblxuICAgIHRoaXMubG9jYWxlID0gcGFyc2VkTG9jYWxlO1xuICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nIHx8IHBhcnNlZE51bWJlcmluZ1N5c3RlbSB8fCBudWxsO1xuICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhciB8fCBwYXJzZWRPdXRwdXRDYWxlbmRhciB8fCBudWxsO1xuICAgIHRoaXMuaW50bCA9IGludGxDb25maWdTdHJpbmcodGhpcy5sb2NhbGUsIHRoaXMubnVtYmVyaW5nU3lzdGVtLCB0aGlzLm91dHB1dENhbGVuZGFyKTtcblxuICAgIHRoaXMud2Vla2RheXNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1vbnRoc0NhY2hlID0geyBmb3JtYXQ6IHt9LCBzdGFuZGFsb25lOiB7fSB9O1xuICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IG51bGw7XG4gICAgdGhpcy5lcmFDYWNoZSA9IHt9O1xuXG4gICAgdGhpcy5zcGVjaWZpZWRMb2NhbGUgPSBzcGVjaWZpZWRMb2NhbGU7XG4gICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IG51bGw7XG4gIH1cblxuICBnZXQgZmFzdE51bWJlcnMoKSB7XG4gICAgaWYgKHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IHN1cHBvcnRzRmFzdE51bWJlcnModGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQ7XG4gIH1cblxuICBsaXN0aW5nTW9kZShkZWZhdWx0T0sgPSB0cnVlKSB7XG4gICAgY29uc3QgaW50bCA9IGhhc0ludGwoKSxcbiAgICAgIGhhc0ZUUCA9IGludGwgJiYgaGFzRm9ybWF0VG9QYXJ0cygpLFxuICAgICAgaXNBY3R1YWxseUVuID0gdGhpcy5pc0VuZ2xpc2goKSxcbiAgICAgIGhhc05vV2VpcmRuZXNzID1cbiAgICAgICAgKHRoaXMubnVtYmVyaW5nU3lzdGVtID09PSBudWxsIHx8IHRoaXMubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIikgJiZcbiAgICAgICAgKHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG51bGwgfHwgdGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gXCJncmVnb3J5XCIpO1xuXG4gICAgaWYgKCFoYXNGVFAgJiYgIShpc0FjdHVhbGx5RW4gJiYgaGFzTm9XZWlyZG5lc3MpICYmICFkZWZhdWx0T0spIHtcbiAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgfSBlbHNlIGlmICghaGFzRlRQIHx8IChpc0FjdHVhbGx5RW4gJiYgaGFzTm9XZWlyZG5lc3MpKSB7XG4gICAgICByZXR1cm4gXCJlblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJpbnRsXCI7XG4gICAgfVxuICB9XG5cbiAgY2xvbmUoYWx0cykge1xuICAgIGlmICghYWx0cyB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhbHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShcbiAgICAgICAgYWx0cy5sb2NhbGUgfHwgdGhpcy5zcGVjaWZpZWRMb2NhbGUsXG4gICAgICAgIGFsdHMubnVtYmVyaW5nU3lzdGVtIHx8IHRoaXMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBhbHRzLm91dHB1dENhbGVuZGFyIHx8IHRoaXMub3V0cHV0Q2FsZW5kYXIsXG4gICAgICAgIGFsdHMuZGVmYXVsdFRvRU4gfHwgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmVkZWZhdWx0VG9FTihhbHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZShPYmplY3QuYXNzaWduKHt9LCBhbHRzLCB7IGRlZmF1bHRUb0VOOiB0cnVlIH0pKTtcbiAgfVxuXG4gIHJlZGVmYXVsdFRvU3lzdGVtKGFsdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKE9iamVjdC5hc3NpZ24oe30sIGFsdHMsIHsgZGVmYXVsdFRvRU46IGZhbHNlIH0pKTtcbiAgfVxuXG4gIG1vbnRocyhsZW5ndGgsIGZvcm1hdCA9IGZhbHNlLCBkZWZhdWx0T0sgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIGRlZmF1bHRPSywgRW5nbGlzaC5tb250aHMsICgpID0+IHtcbiAgICAgIGNvbnN0IGludGwgPSBmb3JtYXQgPyB7IG1vbnRoOiBsZW5ndGgsIGRheTogXCJudW1lcmljXCIgfSA6IHsgbW9udGg6IGxlbmd0aCB9LFxuICAgICAgICBmb3JtYXRTdHIgPSBmb3JtYXQgPyBcImZvcm1hdFwiIDogXCJzdGFuZGFsb25lXCI7XG4gICAgICBpZiAoIXRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdID0gbWFwTW9udGhzKGR0ID0+IHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJtb250aFwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICB3ZWVrZGF5cyhsZW5ndGgsIGZvcm1hdCA9IGZhbHNlLCBkZWZhdWx0T0sgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIGRlZmF1bHRPSywgRW5nbGlzaC53ZWVrZGF5cywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IGZvcm1hdFxuICAgICAgICAgID8geyB3ZWVrZGF5OiBsZW5ndGgsIHllYXI6IFwibnVtZXJpY1wiLCBtb250aDogXCJsb25nXCIsIGRheTogXCJudW1lcmljXCIgfVxuICAgICAgICAgIDogeyB3ZWVrZGF5OiBsZW5ndGggfSxcbiAgICAgICAgZm9ybWF0U3RyID0gZm9ybWF0ID8gXCJmb3JtYXRcIiA6IFwic3RhbmRhbG9uZVwiO1xuICAgICAgaWYgKCF0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0gPSBtYXBXZWVrZGF5cyhkdCA9PlxuICAgICAgICAgIHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJ3ZWVrZGF5XCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIG1lcmlkaWVtcyhkZWZhdWx0T0sgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZihcbiAgICAgIHRoaXMsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0T0ssXG4gICAgICAoKSA9PiBFbmdsaXNoLm1lcmlkaWVtcyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgLy8gSW4gdGhlb3J5IHRoZXJlIGNvdWxkIGJlIGFyaWJpdHJhcnkgZGF5IHBlcmlvZHMuIFdlJ3JlIGdvbm5hIGFzc3VtZSB0aGVyZSBhcmUgZXhhY3RseSB0d29cbiAgICAgICAgLy8gZm9yIEFNIGFuZCBQTS4gVGhpcyBpcyBwcm9iYWJseSB3cm9uZywgYnV0IGl0J3MgbWFrZXMgcGFyc2luZyB3YXkgZWFzaWVyLlxuICAgICAgICBpZiAoIXRoaXMubWVyaWRpZW1DYWNoZSkge1xuICAgICAgICAgIGNvbnN0IGludGwgPSB7IGhvdXI6IFwibnVtZXJpY1wiLCBob3VyMTI6IHRydWUgfTtcbiAgICAgICAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBbRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgOSksIERhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMsIDE5KV0ubWFwKFxuICAgICAgICAgICAgZHQgPT4gdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcImRheXBlcmlvZFwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tZXJpZGllbUNhY2hlO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBlcmFzKGxlbmd0aCwgZGVmYXVsdE9LID0gdHJ1ZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBkZWZhdWx0T0ssIEVuZ2xpc2guZXJhcywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IHsgZXJhOiBsZW5ndGggfTtcblxuICAgICAgLy8gVGhpcyBpcyBwcm9ibGVtYXRpYy4gRGlmZmVyZW50IGNhbGVuZGFycyBhcmUgZ29pbmcgdG8gZGVmaW5lIGVyYXMgdG90YWxseSBkaWZmZXJlbnRseS4gV2hhdCBJIG5lZWQgaXMgdGhlIG1pbmltdW0gc2V0IG9mIGRhdGVzXG4gICAgICAvLyB0byBkZWZpbml0ZWx5IGVudW1lcmF0ZSB0aGVtLlxuICAgICAgaWYgKCF0aGlzLmVyYUNhY2hlW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy5lcmFDYWNoZVtsZW5ndGhdID0gW0RhdGVUaW1lLnV0YygtNDAsIDEsIDEpLCBEYXRlVGltZS51dGMoMjAxNywgMSwgMSldLm1hcChkdCA9PlxuICAgICAgICAgIHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJlcmFcIilcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZXJhQ2FjaGVbbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4dHJhY3QoZHQsIGludGxPcHRzLCBmaWVsZCkge1xuICAgIGNvbnN0IGRmID0gdGhpcy5kdEZvcm1hdHRlcihkdCwgaW50bE9wdHMpLFxuICAgICAgcmVzdWx0cyA9IGRmLmZvcm1hdFRvUGFydHMoKSxcbiAgICAgIG1hdGNoaW5nID0gcmVzdWx0cy5maW5kKG0gPT4gbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IGZpZWxkKTtcbiAgICByZXR1cm4gbWF0Y2hpbmcgPyBtYXRjaGluZy52YWx1ZSA6IG51bGw7XG4gIH1cblxuICBudW1iZXJGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgLy8gdGhpcyBmb3JjZXNpbXBsZSBvcHRpb24gaXMgbmV2ZXIgdXNlZCAodGhlIG9ubHkgY2FsbGVyIHNob3J0LWNpcmN1aXRzIG9uIGl0LCBidXQgaXQgc2VlbXMgc2FmZXIgdG8gbGVhdmUpXG4gICAgLy8gKGluIGNvbnRyYXN0LCB0aGUgcmVzdCBvZiB0aGUgY29uZGl0aW9uIGlzIHVzZWQgaGVhdmlseSlcbiAgICByZXR1cm4gbmV3IFBvbHlOdW1iZXJGb3JtYXR0ZXIodGhpcy5pbnRsLCBvcHRzLmZvcmNlU2ltcGxlIHx8IHRoaXMuZmFzdE51bWJlcnMsIG9wdHMpO1xuICB9XG5cbiAgZHRGb3JtYXR0ZXIoZHQsIGludGxPcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBvbHlEYXRlRm9ybWF0dGVyKGR0LCB0aGlzLmludGwsIGludGxPcHRzKTtcbiAgfVxuXG4gIHJlbEZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBvbHlSZWxGb3JtYXR0ZXIodGhpcy5pbnRsLCB0aGlzLmlzRW5nbGlzaCgpLCBvcHRzKTtcbiAgfVxuXG4gIGlzRW5nbGlzaCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb2NhbGUgPT09IFwiZW5cIiB8fFxuICAgICAgdGhpcy5sb2NhbGUudG9Mb3dlckNhc2UoKSA9PT0gXCJlbi11c1wiIHx8XG4gICAgICAoaGFzSW50bCgpICYmIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMuaW50bCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlLnN0YXJ0c1dpdGgoXCJlbi11c1wiKSlcbiAgICApO1xuICB9XG5cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9jYWxlID09PSBvdGhlci5sb2NhbGUgJiZcbiAgICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID09PSBvdGhlci5udW1iZXJpbmdTeXN0ZW0gJiZcbiAgICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG90aGVyLm91dHB1dENhbGVuZGFyXG4gICAgKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImhhc0Zvcm1hdFRvUGFydHMiLCJoYXNJbnRsIiwicGFkU3RhcnQiLCJyb3VuZFRvIiwiaGFzUmVsYXRpdmUiLCJFbmdsaXNoIiwiU2V0dGluZ3MiLCJEYXRlVGltZSIsIkZvcm1hdHRlciIsIklBTkFab25lIiwiaW50bERUQ2FjaGUiLCJnZXRDYWNoZWREVEYiLCJsb2NTdHJpbmciLCJvcHRzIiwia2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImR0ZiIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsImludGxOdW1DYWNoZSIsImdldENhY2hlZElORiIsImluZiIsIk51bWJlckZvcm1hdCIsImludGxSZWxDYWNoZSIsImdldENhY2hlZFJURiIsImJhc2UiLCJjYWNoZUtleU9wdHMiLCJSZWxhdGl2ZVRpbWVGb3JtYXQiLCJzeXNMb2NhbGVDYWNoZSIsInN5c3RlbUxvY2FsZSIsImNvbXB1dGVkU3lzIiwicmVzb2x2ZWRPcHRpb25zIiwibG9jYWxlIiwicGFyc2VMb2NhbGVTdHJpbmciLCJsb2NhbGVTdHIiLCJ1SW5kZXgiLCJpbmRleE9mIiwib3B0aW9ucyIsInNtYWxsZXIiLCJzdWJzdHJpbmciLCJlIiwibnVtYmVyaW5nU3lzdGVtIiwiY2FsZW5kYXIiLCJpbnRsQ29uZmlnU3RyaW5nIiwib3V0cHV0Q2FsZW5kYXIiLCJtYXBNb250aHMiLCJmIiwibXMiLCJpIiwiZHQiLCJ1dGMiLCJwdXNoIiwibWFwV2Vla2RheXMiLCJsaXN0U3R1ZmYiLCJsb2MiLCJsZW5ndGgiLCJkZWZhdWx0T0siLCJlbmdsaXNoRm4iLCJpbnRsRm4iLCJtb2RlIiwibGlzdGluZ01vZGUiLCJzdXBwb3J0c0Zhc3ROdW1iZXJzIiwic3RhcnRzV2l0aCIsImludGwiLCJQb2x5TnVtYmVyRm9ybWF0dGVyIiwiY29uc3RydWN0b3IiLCJmb3JjZVNpbXBsZSIsInBhZFRvIiwiZmxvb3IiLCJpbnRsT3B0cyIsInVzZUdyb3VwaW5nIiwibWluaW11bUludGVnZXJEaWdpdHMiLCJmb3JtYXQiLCJmaXhlZCIsIk1hdGgiLCJQb2x5RGF0ZUZvcm1hdHRlciIsInoiLCJ6b25lIiwidW5pdmVyc2FsIiwiZ210T2Zmc2V0Iiwib2Zmc2V0Iiwib2Zmc2V0WiIsImlzT2Zmc2V0Wm9uZVN1cHBvcnRlZCIsImlzVmFsaWRab25lIiwidGltZVpvbmVOYW1lIiwiZnJvbU1pbGxpcyIsInRzIiwidHlwZSIsIm5hbWUiLCJPYmplY3QiLCJhc3NpZ24iLCJ0aW1lWm9uZSIsInRvSlNEYXRlIiwidG9rZW5Gb3JtYXQiLCJmb3JtYXRTdHJpbmciLCJMb2NhbGUiLCJjcmVhdGUiLCJmb3JtYXREYXRlVGltZUZyb21TdHJpbmciLCJmb3JtYXRUb1BhcnRzIiwiUG9seVJlbEZvcm1hdHRlciIsImlzRW5nbGlzaCIsInN0eWxlIiwicnRmIiwiY291bnQiLCJ1bml0IiwiZm9ybWF0UmVsYXRpdmVUaW1lIiwibnVtZXJpYyIsImZyb21PcHRzIiwiZGVmYXVsdFRvRU4iLCJzcGVjaWZpZWRMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwibG9jYWxlUiIsIm51bWJlcmluZ1N5c3RlbVIiLCJkZWZhdWx0TnVtYmVyaW5nU3lzdGVtIiwib3V0cHV0Q2FsZW5kYXJSIiwiZGVmYXVsdE91dHB1dENhbGVuZGFyIiwicmVzZXRDYWNoZSIsImZyb21PYmplY3QiLCJudW1iZXJpbmciLCJwYXJzZWRMb2NhbGUiLCJwYXJzZWROdW1iZXJpbmdTeXN0ZW0iLCJwYXJzZWRPdXRwdXRDYWxlbmRhciIsIndlZWtkYXlzQ2FjaGUiLCJzdGFuZGFsb25lIiwibW9udGhzQ2FjaGUiLCJtZXJpZGllbUNhY2hlIiwiZXJhQ2FjaGUiLCJmYXN0TnVtYmVyc0NhY2hlZCIsImZhc3ROdW1iZXJzIiwiaGFzRlRQIiwiaXNBY3R1YWxseUVuIiwiaGFzTm9XZWlyZG5lc3MiLCJjbG9uZSIsImFsdHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicmVkZWZhdWx0VG9FTiIsInJlZGVmYXVsdFRvU3lzdGVtIiwibW9udGhzIiwibW9udGgiLCJkYXkiLCJmb3JtYXRTdHIiLCJleHRyYWN0Iiwid2Vla2RheXMiLCJ3ZWVrZGF5IiwieWVhciIsIm1lcmlkaWVtcyIsInVuZGVmaW5lZCIsImhvdXIiLCJob3VyMTIiLCJtYXAiLCJlcmFzIiwiZXJhIiwiZmllbGQiLCJkZiIsImR0Rm9ybWF0dGVyIiwicmVzdWx0cyIsIm1hdGNoaW5nIiwiZmluZCIsIm0iLCJ0b0xvd2VyQ2FzZSIsInZhbHVlIiwibnVtYmVyRm9ybWF0dGVyIiwicmVsRm9ybWF0dGVyIiwiZXF1YWxzIiwib3RoZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/impl/locale.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/impl/regexParser.js":
/*!****************************************************!*\
  !*** ./node_modules/luxon/src/impl/regexParser.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseHTTPDate: () => (/* binding */ parseHTTPDate),\n/* harmony export */   parseISODate: () => (/* binding */ parseISODate),\n/* harmony export */   parseISODuration: () => (/* binding */ parseISODuration),\n/* harmony export */   parseISOTimeOnly: () => (/* binding */ parseISOTimeOnly),\n/* harmony export */   parseRFC2822Date: () => (/* binding */ parseRFC2822Date),\n/* harmony export */   parseSQL: () => (/* binding */ parseSQL)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(rsc)/./node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./english.js */ \"(rsc)/./node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(rsc)/./node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(rsc)/./node_modules/luxon/src/zones/IANAZone.js\");\n\n\n\n\n/*\n * This file handles parsing for well-specified formats. Here's how it works:\n * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.\n * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object\n * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.\n * Extractors can take a \"cursor\" representing the offset in the match to look at. This makes it easy to combine extractors.\n * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.\n * Some extractions are super dumb and simpleParse and fromStrings help DRY them.\n */ function combineRegexes(...regexes) {\n    const full = regexes.reduce((f, r)=>f + r.source, \"\");\n    return RegExp(`^${full}$`);\n}\nfunction combineExtractors(...extractors) {\n    return (m)=>extractors.reduce(([mergedVals, mergedZone, cursor], ex)=>{\n            const [val, zone, next] = ex(m, cursor);\n            return [\n                Object.assign(mergedVals, val),\n                mergedZone || zone,\n                next\n            ];\n        }, [\n            {},\n            null,\n            1\n        ]).slice(0, 2);\n}\nfunction parse(s, ...patterns) {\n    if (s == null) {\n        return [\n            null,\n            null\n        ];\n    }\n    for (const [regex, extractor] of patterns){\n        const m = regex.exec(s);\n        if (m) {\n            return extractor(m);\n        }\n    }\n    return [\n        null,\n        null\n    ];\n}\nfunction simpleParse(...keys) {\n    return (match, cursor)=>{\n        const ret = {};\n        let i;\n        for(i = 0; i < keys.length; i++){\n            ret[keys[i]] = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(match[cursor + i]);\n        }\n        return [\n            ret,\n            null,\n            cursor + i\n        ];\n    };\n}\n// ISO and SQL parsing\nconst offsetRegex = /(?:(Z)|([+-]\\d\\d)(?::?(\\d\\d))?)/, isoTimeBaseRegex = /(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d{1,30}))?)?)?/, isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${offsetRegex.source}?`), isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`), isoYmdRegex = /([+-]\\d{6}|\\d{4})(?:-?(\\d\\d)(?:-?(\\d\\d))?)?/, isoWeekRegex = /(\\d{4})-?W(\\d\\d)(?:-?(\\d))?/, isoOrdinalRegex = /(\\d{4})-?(\\d{3})/, extractISOWeekData = simpleParse(\"weekYear\", \"weekNumber\", \"weekDay\"), extractISOOrdinalData = simpleParse(\"year\", \"ordinal\"), sqlYmdRegex = /(\\d{4})-(\\d\\d)-(\\d\\d)/, sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${_util_js__WEBPACK_IMPORTED_MODULE_0__.ianaRegex.source}))?`), sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);\nfunction int(match, pos, fallback) {\n    const m = match[pos];\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(m) ? fallback : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(m);\n}\nfunction extractISOYmd(match, cursor) {\n    const item = {\n        year: int(match, cursor),\n        month: int(match, cursor + 1, 1),\n        day: int(match, cursor + 2, 1)\n    };\n    return [\n        item,\n        null,\n        cursor + 3\n    ];\n}\nfunction extractISOTime(match, cursor) {\n    const item = {\n        hours: int(match, cursor, 0),\n        minutes: int(match, cursor + 1, 0),\n        seconds: int(match, cursor + 2, 0),\n        milliseconds: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(match[cursor + 3])\n    };\n    return [\n        item,\n        null,\n        cursor + 4\n    ];\n}\nfunction extractISOOffset(match, cursor) {\n    const local = !match[cursor] && !match[cursor + 1], fullOffset = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(match[cursor + 1], match[cursor + 2]), zone = local ? null : _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].instance(fullOffset);\n    return [\n        {},\n        zone,\n        cursor + 3\n    ];\n}\nfunction extractIANAZone(match, cursor) {\n    const zone = match[cursor] ? _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(match[cursor]) : null;\n    return [\n        {},\n        zone,\n        cursor + 1\n    ];\n}\n// ISO time parsing\nconst isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);\n// ISO duration parsing\nconst isoDuration = /^-?P(?:(?:(-?\\d{1,9})Y)?(?:(-?\\d{1,9})M)?(?:(-?\\d{1,9})W)?(?:(-?\\d{1,9})D)?(?:T(?:(-?\\d{1,9})H)?(?:(-?\\d{1,9})M)?(?:(-?\\d{1,20})(?:[.,](-?\\d{1,9}))?S)?)?)$/;\nfunction extractISODuration(match) {\n    const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match;\n    const hasNegativePrefix = s[0] === \"-\";\n    const negativeSeconds = secondStr && secondStr[0] === \"-\";\n    const maybeNegate = (num, force = false)=>num !== undefined && (force || num && hasNegativePrefix) ? -num : num;\n    return [\n        {\n            years: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(yearStr)),\n            months: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(monthStr)),\n            weeks: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(weekStr)),\n            days: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(dayStr)),\n            hours: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(hourStr)),\n            minutes: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(minuteStr)),\n            seconds: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(secondStr), secondStr === \"-0\"),\n            milliseconds: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(millisecondsStr), negativeSeconds)\n        }\n    ];\n}\n// These are a little braindead. EDT *should* tell us that we're in, say, America/New_York\n// and not just that we're in -240 *right now*. But since I don't think these are used that often\n// I'm just going to ignore that\nconst obsOffsets = {\n    GMT: 0,\n    EDT: -4 * 60,\n    EST: -5 * 60,\n    CDT: -5 * 60,\n    CST: -6 * 60,\n    MDT: -6 * 60,\n    MST: -7 * 60,\n    PDT: -7 * 60,\n    PST: -8 * 60\n};\nfunction fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n    const result = {\n        year: yearStr.length === 2 ? (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear)((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(yearStr)) : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(yearStr),\n        month: _english_js__WEBPACK_IMPORTED_MODULE_3__.monthsShort.indexOf(monthStr) + 1,\n        day: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(dayStr),\n        hour: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(hourStr),\n        minute: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(minuteStr)\n    };\n    if (secondStr) result.second = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(secondStr);\n    if (weekdayStr) {\n        result.weekday = weekdayStr.length > 3 ? _english_js__WEBPACK_IMPORTED_MODULE_3__.weekdaysLong.indexOf(weekdayStr) + 1 : _english_js__WEBPACK_IMPORTED_MODULE_3__.weekdaysShort.indexOf(weekdayStr) + 1;\n    }\n    return result;\n}\n// RFC 2822/5322\nconst rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\\d\\d)(\\d\\d)))$/;\nfunction extractRFC2822(match) {\n    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr, obsOffset, milOffset, offHourStr, offMinuteStr] = match, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n    let offset;\n    if (obsOffset) {\n        offset = obsOffsets[obsOffset];\n    } else if (milOffset) {\n        offset = 0;\n    } else {\n        offset = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(offHourStr, offMinuteStr);\n    }\n    return [\n        result,\n        new _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](offset)\n    ];\n}\nfunction preprocessRFC2822(s) {\n    // Remove comments and folding whitespace and replace multiple-spaces with a single space\n    return s.replace(/\\([^()]*\\)|[\\n\\t]/g, \" \").replace(/(\\s\\s+)/g, \" \").trim();\n}\n// http date\nconst rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d\\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/, rfc850 = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\\d\\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/, ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \\d|\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) (\\d{4})$/;\nfunction extractRFC1123Or850(match) {\n    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n    return [\n        result,\n        _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].utcInstance\n    ];\n}\nfunction extractASCII(match) {\n    const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n    return [\n        result,\n        _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].utcInstance\n    ];\n}\nconst isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);\nconst isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);\nconst isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);\nconst isoTimeCombinedRegex = combineRegexes(isoTimeRegex);\nconst extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset);\nconst extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset);\nconst extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset);\nconst extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset);\n/**\n * @private\n */ function parseISODate(s) {\n    return parse(s, [\n        isoYmdWithTimeExtensionRegex,\n        extractISOYmdTimeAndOffset\n    ], [\n        isoWeekWithTimeExtensionRegex,\n        extractISOWeekTimeAndOffset\n    ], [\n        isoOrdinalWithTimeExtensionRegex,\n        extractISOOrdinalDateAndTime\n    ], [\n        isoTimeCombinedRegex,\n        extractISOTimeAndOffset\n    ]);\n}\nfunction parseRFC2822Date(s) {\n    return parse(preprocessRFC2822(s), [\n        rfc2822,\n        extractRFC2822\n    ]);\n}\nfunction parseHTTPDate(s) {\n    return parse(s, [\n        rfc1123,\n        extractRFC1123Or850\n    ], [\n        rfc850,\n        extractRFC1123Or850\n    ], [\n        ascii,\n        extractASCII\n    ]);\n}\nfunction parseISODuration(s) {\n    return parse(s, [\n        isoDuration,\n        extractISODuration\n    ]);\n}\nconst extractISOTimeOnly = combineExtractors(extractISOTime);\nfunction parseISOTimeOnly(s) {\n    return parse(s, [\n        isoTimeOnly,\n        extractISOTimeOnly\n    ]);\n}\nconst sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);\nconst sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);\nconst extractISOYmdTimeOffsetAndIANAZone = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);\nconst extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);\nfunction parseSQL(s) {\n    return parse(s, [\n        sqlYmdWithTimeExtensionRegex,\n        extractISOYmdTimeOffsetAndIANAZone\n    ], [\n        sqlTimeCombinedRegex,\n        extractISOTimeOffsetAndIANAZone\n    ]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvcmVnZXhQYXJzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQU9tQjtBQUNxQjtBQUNrQjtBQUNkO0FBRTVDOzs7Ozs7OztDQVFDLEdBRUQsU0FBU1MsZUFBZSxHQUFHQyxPQUFPO0lBQ2hDLE1BQU1DLE9BQU9ELFFBQVFFLE1BQU0sQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQyxFQUFFQyxNQUFNLEVBQUU7SUFDcEQsT0FBT0MsT0FBTyxDQUFDLENBQUMsRUFBRUwsS0FBSyxDQUFDLENBQUM7QUFDM0I7QUFFQSxTQUFTTSxrQkFBa0IsR0FBR0MsVUFBVTtJQUN0QyxPQUFPQyxDQUFBQSxJQUNMRCxXQUNHTixNQUFNLENBQ0wsQ0FBQyxDQUFDUSxZQUFZQyxZQUFZQyxPQUFPLEVBQUVDO1lBQ2pDLE1BQU0sQ0FBQ0MsS0FBS0MsTUFBTUMsS0FBSyxHQUFHSCxHQUFHSixHQUFHRztZQUNoQyxPQUFPO2dCQUFDSyxPQUFPQyxNQUFNLENBQUNSLFlBQVlJO2dCQUFNSCxjQUFjSTtnQkFBTUM7YUFBSztRQUNuRSxHQUNBO1lBQUMsQ0FBQztZQUFHO1lBQU07U0FBRSxFQUVkRyxLQUFLLENBQUMsR0FBRztBQUNoQjtBQUVBLFNBQVNDLE1BQU1DLENBQUMsRUFBRSxHQUFHQyxRQUFRO0lBQzNCLElBQUlELEtBQUssTUFBTTtRQUNiLE9BQU87WUFBQztZQUFNO1NBQUs7SUFDckI7SUFFQSxLQUFLLE1BQU0sQ0FBQ0UsT0FBT0MsVUFBVSxJQUFJRixTQUFVO1FBQ3pDLE1BQU1iLElBQUljLE1BQU1FLElBQUksQ0FBQ0o7UUFDckIsSUFBSVosR0FBRztZQUNMLE9BQU9lLFVBQVVmO1FBQ25CO0lBQ0Y7SUFDQSxPQUFPO1FBQUM7UUFBTTtLQUFLO0FBQ3JCO0FBRUEsU0FBU2lCLFlBQVksR0FBR0MsSUFBSTtJQUMxQixPQUFPLENBQUNDLE9BQU9oQjtRQUNiLE1BQU1pQixNQUFNLENBQUM7UUFD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ZHVsZXMvbHV4b24vc3JjL2ltcGwvcmVnZXhQYXJzZXIuanM/NTgwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICB1bnRydW5jYXRlWWVhcixcbiAgc2lnbmVkT2Zmc2V0LFxuICBwYXJzZUludGVnZXIsXG4gIHBhcnNlTWlsbGlzLFxuICBpYW5hUmVnZXgsXG4gIGlzVW5kZWZpbmVkXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaGFuZGxlcyBwYXJzaW5nIGZvciB3ZWxsLXNwZWNpZmllZCBmb3JtYXRzLiBIZXJlJ3MgaG93IGl0IHdvcmtzOlxuICogVHdvIHRoaW5ncyBnbyBpbnRvIHBhcnNpbmc6IGEgcmVnZXggdG8gbWF0Y2ggd2l0aCBhbmQgYW4gZXh0cmFjdG9yIHRvIHRha2UgYXBhcnQgdGhlIGdyb3VwcyBpbiB0aGUgbWF0Y2guXG4gKiBBbiBleHRyYWN0b3IgaXMganVzdCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSByZWdleCBtYXRjaCBhcnJheSBhbmQgcmV0dXJucyBhIHsgeWVhcjogLi4uLCBtb250aDogLi4uIH0gb2JqZWN0XG4gKiBwYXJzZSgpIGRvZXMgdGhlIHdvcmsgb2YgZXhlY3V0aW5nIHRoZSByZWdleCBhbmQgYXBwbHlpbmcgdGhlIGV4dHJhY3Rvci4gSXQgdGFrZXMgbXVsdGlwbGUgcmVnZXgvZXh0cmFjdG9yIHBhaXJzIHRvIHRyeSBpbiBzZXF1ZW5jZS5cbiAqIEV4dHJhY3RvcnMgY2FuIHRha2UgYSBcImN1cnNvclwiIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0IGluIHRoZSBtYXRjaCB0byBsb29rIGF0LiBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gY29tYmluZSBleHRyYWN0b3JzLlxuICogY29tYmluZUV4dHJhY3RvcnMoKSBkb2VzIHRoZSB3b3JrIG9mIGNvbWJpbmluZyB0aGVtLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBjdXJzb3IgdGhyb3VnaCBtdWx0aXBsZSBleHRyYWN0aW9ucy5cbiAqIFNvbWUgZXh0cmFjdGlvbnMgYXJlIHN1cGVyIGR1bWIgYW5kIHNpbXBsZVBhcnNlIGFuZCBmcm9tU3RyaW5ncyBoZWxwIERSWSB0aGVtLlxuICovXG5cbmZ1bmN0aW9uIGNvbWJpbmVSZWdleGVzKC4uLnJlZ2V4ZXMpIHtcbiAgY29uc3QgZnVsbCA9IHJlZ2V4ZXMucmVkdWNlKChmLCByKSA9PiBmICsgci5zb3VyY2UsIFwiXCIpO1xuICByZXR1cm4gUmVnRXhwKGBeJHtmdWxsfSRgKTtcbn1cblxuZnVuY3Rpb24gY29tYmluZUV4dHJhY3RvcnMoLi4uZXh0cmFjdG9ycykge1xuICByZXR1cm4gbSA9PlxuICAgIGV4dHJhY3RvcnNcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbbWVyZ2VkVmFscywgbWVyZ2VkWm9uZSwgY3Vyc29yXSwgZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBbdmFsLCB6b25lLCBuZXh0XSA9IGV4KG0sIGN1cnNvcik7XG4gICAgICAgICAgcmV0dXJuIFtPYmplY3QuYXNzaWduKG1lcmdlZFZhbHMsIHZhbCksIG1lcmdlZFpvbmUgfHwgem9uZSwgbmV4dF07XG4gICAgICAgIH0sXG4gICAgICAgIFt7fSwgbnVsbCwgMV1cbiAgICAgIClcbiAgICAgIC5zbGljZSgwLCAyKTtcbn1cblxuZnVuY3Rpb24gcGFyc2UocywgLi4ucGF0dGVybnMpIHtcbiAgaWYgKHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gIH1cblxuICBmb3IgKGNvbnN0IFtyZWdleCwgZXh0cmFjdG9yXSBvZiBwYXR0ZXJucykge1xuICAgIGNvbnN0IG0gPSByZWdleC5leGVjKHMpO1xuICAgIGlmIChtKSB7XG4gICAgICByZXR1cm4gZXh0cmFjdG9yKG0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW251bGwsIG51bGxdO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVQYXJzZSguLi5rZXlzKSB7XG4gIHJldHVybiAobWF0Y2gsIGN1cnNvcikgPT4ge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFtrZXlzW2ldXSA9IHBhcnNlSW50ZWdlcihtYXRjaFtjdXJzb3IgKyBpXSk7XG4gICAgfVxuICAgIHJldHVybiBbcmV0LCBudWxsLCBjdXJzb3IgKyBpXTtcbiAgfTtcbn1cblxuLy8gSVNPIGFuZCBTUUwgcGFyc2luZ1xuY29uc3Qgb2Zmc2V0UmVnZXggPSAvKD86KFopfChbKy1dXFxkXFxkKSg/Ojo/KFxcZFxcZCkpPykvLFxuICBpc29UaW1lQmFzZVJlZ2V4ID0gLyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzpbLixdKFxcZHsxLDMwfSkpPyk/KT8vLFxuICBpc29UaW1lUmVnZXggPSBSZWdFeHAoYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JHtvZmZzZXRSZWdleC5zb3VyY2V9P2ApLFxuICBpc29UaW1lRXh0ZW5zaW9uUmVnZXggPSBSZWdFeHAoYCg/OlQke2lzb1RpbWVSZWdleC5zb3VyY2V9KT9gKSxcbiAgaXNvWW1kUmVnZXggPSAvKFsrLV1cXGR7Nn18XFxkezR9KSg/Oi0/KFxcZFxcZCkoPzotPyhcXGRcXGQpKT8pPy8sXG4gIGlzb1dlZWtSZWdleCA9IC8oXFxkezR9KS0/VyhcXGRcXGQpKD86LT8oXFxkKSk/LyxcbiAgaXNvT3JkaW5hbFJlZ2V4ID0gLyhcXGR7NH0pLT8oXFxkezN9KS8sXG4gIGV4dHJhY3RJU09XZWVrRGF0YSA9IHNpbXBsZVBhcnNlKFwid2Vla1llYXJcIiwgXCJ3ZWVrTnVtYmVyXCIsIFwid2Vla0RheVwiKSxcbiAgZXh0cmFjdElTT09yZGluYWxEYXRhID0gc2ltcGxlUGFyc2UoXCJ5ZWFyXCIsIFwib3JkaW5hbFwiKSxcbiAgc3FsWW1kUmVnZXggPSAvKFxcZHs0fSktKFxcZFxcZCktKFxcZFxcZCkvLCAvLyBkdW1iZWQtZG93biB2ZXJzaW9uIG9mIHRoZSBJU08gb25lXG4gIHNxbFRpbWVSZWdleCA9IFJlZ0V4cChcbiAgICBgJHtpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZX0gPyg/OiR7b2Zmc2V0UmVnZXguc291cmNlfXwoJHtpYW5hUmVnZXguc291cmNlfSkpP2BcbiAgKSxcbiAgc3FsVGltZUV4dGVuc2lvblJlZ2V4ID0gUmVnRXhwKGAoPzogJHtzcWxUaW1lUmVnZXguc291cmNlfSk/YCk7XG5cbmZ1bmN0aW9uIGludChtYXRjaCwgcG9zLCBmYWxsYmFjaykge1xuICBjb25zdCBtID0gbWF0Y2hbcG9zXTtcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKG0pID8gZmFsbGJhY2sgOiBwYXJzZUludGVnZXIobSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09ZbWQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIHllYXI6IGludChtYXRjaCwgY3Vyc29yKSxcbiAgICBtb250aDogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAxKSxcbiAgICBkYXk6IGludChtYXRjaCwgY3Vyc29yICsgMiwgMSlcbiAgfTtcblxuICByZXR1cm4gW2l0ZW0sIG51bGwsIGN1cnNvciArIDNdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPVGltZShtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IGl0ZW0gPSB7XG4gICAgaG91cnM6IGludChtYXRjaCwgY3Vyc29yLCAwKSxcbiAgICBtaW51dGVzOiBpbnQobWF0Y2gsIGN1cnNvciArIDEsIDApLFxuICAgIHNlY29uZHM6IGludChtYXRjaCwgY3Vyc29yICsgMiwgMCksXG4gICAgbWlsbGlzZWNvbmRzOiBwYXJzZU1pbGxpcyhtYXRjaFtjdXJzb3IgKyAzXSlcbiAgfTtcblxuICByZXR1cm4gW2l0ZW0sIG51bGwsIGN1cnNvciArIDRdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPT2Zmc2V0KG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgbG9jYWwgPSAhbWF0Y2hbY3Vyc29yXSAmJiAhbWF0Y2hbY3Vyc29yICsgMV0sXG4gICAgZnVsbE9mZnNldCA9IHNpZ25lZE9mZnNldChtYXRjaFtjdXJzb3IgKyAxXSwgbWF0Y2hbY3Vyc29yICsgMl0pLFxuICAgIHpvbmUgPSBsb2NhbCA/IG51bGwgOiBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2UoZnVsbE9mZnNldCk7XG4gIHJldHVybiBbe30sIHpvbmUsIGN1cnNvciArIDNdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SUFOQVpvbmUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCB6b25lID0gbWF0Y2hbY3Vyc29yXSA/IElBTkFab25lLmNyZWF0ZShtYXRjaFtjdXJzb3JdKSA6IG51bGw7XG4gIHJldHVybiBbe30sIHpvbmUsIGN1cnNvciArIDFdO1xufVxuXG4vLyBJU08gdGltZSBwYXJzaW5nXG5cbmNvbnN0IGlzb1RpbWVPbmx5ID0gUmVnRXhwKGBeVD8ke2lzb1RpbWVCYXNlUmVnZXguc291cmNlfSRgKTtcblxuLy8gSVNPIGR1cmF0aW9uIHBhcnNpbmdcblxuY29uc3QgaXNvRHVyYXRpb24gPSAvXi0/UCg/Oig/OigtP1xcZHsxLDl9KVkpPyg/OigtP1xcZHsxLDl9KU0pPyg/OigtP1xcZHsxLDl9KVcpPyg/OigtP1xcZHsxLDl9KUQpPyg/OlQoPzooLT9cXGR7MSw5fSlIKT8oPzooLT9cXGR7MSw5fSlNKT8oPzooLT9cXGR7MSwyMH0pKD86Wy4sXSgtP1xcZHsxLDl9KSk/Uyk/KT8pJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09EdXJhdGlvbihtYXRjaCkge1xuICBjb25zdCBbXG4gICAgcyxcbiAgICB5ZWFyU3RyLFxuICAgIG1vbnRoU3RyLFxuICAgIHdlZWtTdHIsXG4gICAgZGF5U3RyLFxuICAgIGhvdXJTdHIsXG4gICAgbWludXRlU3RyLFxuICAgIHNlY29uZFN0cixcbiAgICBtaWxsaXNlY29uZHNTdHJcbiAgXSA9IG1hdGNoO1xuXG4gIGNvbnN0IGhhc05lZ2F0aXZlUHJlZml4ID0gc1swXSA9PT0gXCItXCI7XG4gIGNvbnN0IG5lZ2F0aXZlU2Vjb25kcyA9IHNlY29uZFN0ciAmJiBzZWNvbmRTdHJbMF0gPT09IFwiLVwiO1xuXG4gIGNvbnN0IG1heWJlTmVnYXRlID0gKG51bSwgZm9yY2UgPSBmYWxzZSkgPT5cbiAgICBudW0gIT09IHVuZGVmaW5lZCAmJiAoZm9yY2UgfHwgKG51bSAmJiBoYXNOZWdhdGl2ZVByZWZpeCkpID8gLW51bSA6IG51bTtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHllYXJzOiBtYXliZU5lZ2F0ZShwYXJzZUludGVnZXIoeWVhclN0cikpLFxuICAgICAgbW9udGhzOiBtYXliZU5lZ2F0ZShwYXJzZUludGVnZXIobW9udGhTdHIpKSxcbiAgICAgIHdlZWtzOiBtYXliZU5lZ2F0ZShwYXJzZUludGVnZXIod2Vla1N0cikpLFxuICAgICAgZGF5czogbWF5YmVOZWdhdGUocGFyc2VJbnRlZ2VyKGRheVN0cikpLFxuICAgICAgaG91cnM6IG1heWJlTmVnYXRlKHBhcnNlSW50ZWdlcihob3VyU3RyKSksXG4gICAgICBtaW51dGVzOiBtYXliZU5lZ2F0ZShwYXJzZUludGVnZXIobWludXRlU3RyKSksXG4gICAgICBzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZUludGVnZXIoc2Vjb25kU3RyKSwgc2Vjb25kU3RyID09PSBcIi0wXCIpLFxuICAgICAgbWlsbGlzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZU1pbGxpcyhtaWxsaXNlY29uZHNTdHIpLCBuZWdhdGl2ZVNlY29uZHMpXG4gICAgfVxuICBdO1xufVxuXG4vLyBUaGVzZSBhcmUgYSBsaXR0bGUgYnJhaW5kZWFkLiBFRFQgKnNob3VsZCogdGVsbCB1cyB0aGF0IHdlJ3JlIGluLCBzYXksIEFtZXJpY2EvTmV3X1lvcmtcbi8vIGFuZCBub3QganVzdCB0aGF0IHdlJ3JlIGluIC0yNDAgKnJpZ2h0IG5vdyouIEJ1dCBzaW5jZSBJIGRvbid0IHRoaW5rIHRoZXNlIGFyZSB1c2VkIHRoYXQgb2Z0ZW5cbi8vIEknbSBqdXN0IGdvaW5nIHRvIGlnbm9yZSB0aGF0XG5jb25zdCBvYnNPZmZzZXRzID0ge1xuICBHTVQ6IDAsXG4gIEVEVDogLTQgKiA2MCxcbiAgRVNUOiAtNSAqIDYwLFxuICBDRFQ6IC01ICogNjAsXG4gIENTVDogLTYgKiA2MCxcbiAgTURUOiAtNiAqIDYwLFxuICBNU1Q6IC03ICogNjAsXG4gIFBEVDogLTcgKiA2MCxcbiAgUFNUOiAtOCAqIDYwXG59O1xuXG5mdW5jdGlvbiBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgeWVhcjogeWVhclN0ci5sZW5ndGggPT09IDIgPyB1bnRydW5jYXRlWWVhcihwYXJzZUludGVnZXIoeWVhclN0cikpIDogcGFyc2VJbnRlZ2VyKHllYXJTdHIpLFxuICAgIG1vbnRoOiBFbmdsaXNoLm1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpICsgMSxcbiAgICBkYXk6IHBhcnNlSW50ZWdlcihkYXlTdHIpLFxuICAgIGhvdXI6IHBhcnNlSW50ZWdlcihob3VyU3RyKSxcbiAgICBtaW51dGU6IHBhcnNlSW50ZWdlcihtaW51dGVTdHIpXG4gIH07XG5cbiAgaWYgKHNlY29uZFN0cikgcmVzdWx0LnNlY29uZCA9IHBhcnNlSW50ZWdlcihzZWNvbmRTdHIpO1xuICBpZiAod2Vla2RheVN0cikge1xuICAgIHJlc3VsdC53ZWVrZGF5ID1cbiAgICAgIHdlZWtkYXlTdHIubGVuZ3RoID4gM1xuICAgICAgICA/IEVuZ2xpc2gud2Vla2RheXNMb25nLmluZGV4T2Yod2Vla2RheVN0cikgKyAxXG4gICAgICAgIDogRW5nbGlzaC53ZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0cikgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gUkZDIDI4MjIvNTMyMlxuY29uc3QgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksXFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfCg/OihbKy1dXFxkXFxkKShcXGRcXGQpKSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzI4MjIobWF0Y2gpIHtcbiAgY29uc3QgW1xuICAgICAgLFxuICAgICAgd2Vla2RheVN0cixcbiAgICAgIGRheVN0cixcbiAgICAgIG1vbnRoU3RyLFxuICAgICAgeWVhclN0cixcbiAgICAgIGhvdXJTdHIsXG4gICAgICBtaW51dGVTdHIsXG4gICAgICBzZWNvbmRTdHIsXG4gICAgICBvYnNPZmZzZXQsXG4gICAgICBtaWxPZmZzZXQsXG4gICAgICBvZmZIb3VyU3RyLFxuICAgICAgb2ZmTWludXRlU3RyXG4gICAgXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcblxuICBsZXQgb2Zmc2V0O1xuICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICB9IGVsc2UgaWYgKG1pbE9mZnNldCkge1xuICAgIG9mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG9mZkhvdXJTdHIsIG9mZk1pbnV0ZVN0cik7XG4gIH1cblxuICByZXR1cm4gW3Jlc3VsdCwgbmV3IEZpeGVkT2Zmc2V0Wm9uZShvZmZzZXQpXTtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKC9cXChbXigpXSpcXCl8W1xcblxcdF0vZywgXCIgXCIpXG4gICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCBcIiBcIilcbiAgICAudHJpbSgpO1xufVxuXG4vLyBodHRwIGRhdGVcblxuY29uc3QgcmZjMTEyMyA9IC9eKE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksIChcXGRcXGQpIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKFxcZHs0fSkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIHJmYzg1MCA9IC9eKE1vbmRheXxUdWVzZGF5fFdlZHNkYXl8VGh1cnNkYXl8RnJpZGF5fFNhdHVyZGF5fFN1bmRheSksIChcXGRcXGQpLShKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYyktKFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIGFzY2lpID0gL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSAoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpICggXFxkfFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgKFxcZHs0fSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzExMjNPcjg1MChtYXRjaCkge1xuICBjb25zdCBbLCB3ZWVrZGF5U3RyLCBkYXlTdHIsIG1vbnRoU3RyLCB5ZWFyU3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cl0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG4gIHJldHVybiBbcmVzdWx0LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QVNDSUkobWF0Y2gpIHtcbiAgY29uc3QgWywgd2Vla2RheVN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIsIHllYXJTdHJdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuICByZXR1cm4gW3Jlc3VsdCwgRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlXTtcbn1cblxuY29uc3QgaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1ltZFJlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvV2Vla1dpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29XZWVrUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb09yZGluYWxSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb1RpbWVDb21iaW5lZFJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvVGltZVJlZ2V4KTtcblxuY29uc3QgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1ltZCxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXRcbik7XG5jb25zdCBleHRyYWN0SVNPV2Vla1RpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1dlZWtEYXRhLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldFxuKTtcbmNvbnN0IGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT09yZGluYWxEYXRhLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldFxuKTtcbmNvbnN0IGV4dHJhY3RJU09UaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoZXh0cmFjdElTT1RpbWUsIGV4dHJhY3RJU09PZmZzZXQpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldF0sXG4gICAgW2lzb1dlZWtXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPV2Vla1RpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT09yZGluYWxEYXRlQW5kVGltZV0sXG4gICAgW2lzb1RpbWVDb21iaW5lZFJlZ2V4LCBleHRyYWN0SVNPVGltZUFuZE9mZnNldF1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUkZDMjgyMkRhdGUocykge1xuICByZXR1cm4gcGFyc2UocHJlcHJvY2Vzc1JGQzI4MjIocyksIFtyZmMyODIyLCBleHRyYWN0UkZDMjgyMl0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VIVFRQRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtyZmMxMTIzLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbcmZjODUwLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbYXNjaWksIGV4dHJhY3RBU0NJSV1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRHVyYXRpb24ocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb0R1cmF0aW9uLCBleHRyYWN0SVNPRHVyYXRpb25dKTtcbn1cblxuY29uc3QgZXh0cmFjdElTT1RpbWVPbmx5ID0gY29tYmluZUV4dHJhY3RvcnMoZXh0cmFjdElTT1RpbWUpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJU09UaW1lT25seShzKSB7XG4gIHJldHVybiBwYXJzZShzLCBbaXNvVGltZU9ubHksIGV4dHJhY3RJU09UaW1lT25seV0pO1xufVxuXG5jb25zdCBzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoc3FsWW1kUmVnZXgsIHNxbFRpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBzcWxUaW1lQ29tYmluZWRSZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFRpbWVSZWdleCk7XG5cbmNvbnN0IGV4dHJhY3RJU09ZbWRUaW1lT2Zmc2V0QW5kSUFOQVpvbmUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1ltZCxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU1FMKHMpIHtcbiAgcmV0dXJuIHBhcnNlKFxuICAgIHMsXG4gICAgW3NxbFltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09ZbWRUaW1lT2Zmc2V0QW5kSUFOQVpvbmVdLFxuICAgIFtzcWxUaW1lQ29tYmluZWRSZWdleCwgZXh0cmFjdElTT1RpbWVPZmZzZXRBbmRJQU5BWm9uZV1cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1bnRydW5jYXRlWWVhciIsInNpZ25lZE9mZnNldCIsInBhcnNlSW50ZWdlciIsInBhcnNlTWlsbGlzIiwiaWFuYVJlZ2V4IiwiaXNVbmRlZmluZWQiLCJFbmdsaXNoIiwiRml4ZWRPZmZzZXRab25lIiwiSUFOQVpvbmUiLCJjb21iaW5lUmVnZXhlcyIsInJlZ2V4ZXMiLCJmdWxsIiwicmVkdWNlIiwiZiIsInIiLCJzb3VyY2UiLCJSZWdFeHAiLCJjb21iaW5lRXh0cmFjdG9ycyIsImV4dHJhY3RvcnMiLCJtIiwibWVyZ2VkVmFscyIsIm1lcmdlZFpvbmUiLCJjdXJzb3IiLCJleCIsInZhbCIsInpvbmUiLCJuZXh0IiwiT2JqZWN0IiwiYXNzaWduIiwic2xpY2UiLCJwYXJzZSIsInMiLCJwYXR0ZXJucyIsInJlZ2V4IiwiZXh0cmFjdG9yIiwiZXhlYyIsInNpbXBsZVBhcnNlIiwia2V5cyIsIm1hdGNoIiwicmV0IiwiaSIsImxlbmd0aCIsIm9mZnNldFJlZ2V4IiwiaXNvVGltZUJhc2VSZWdleCIsImlzb1RpbWVSZWdleCIsImlzb1RpbWVFeHRlbnNpb25SZWdleCIsImlzb1ltZFJlZ2V4IiwiaXNvV2Vla1JlZ2V4IiwiaXNvT3JkaW5hbFJlZ2V4IiwiZXh0cmFjdElTT1dlZWtEYXRhIiwiZXh0cmFjdElTT09yZGluYWxEYXRhIiwic3FsWW1kUmVnZXgiLCJzcWxUaW1lUmVnZXgiLCJzcWxUaW1lRXh0ZW5zaW9uUmVnZXgiLCJpbnQiLCJwb3MiLCJmYWxsYmFjayIsImV4dHJhY3RJU09ZbWQiLCJpdGVtIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiZXh0cmFjdElTT1RpbWUiLCJob3VycyIsIm1pbnV0ZXMiLCJzZWNvbmRzIiwibWlsbGlzZWNvbmRzIiwiZXh0cmFjdElTT09mZnNldCIsImxvY2FsIiwiZnVsbE9mZnNldCIsImluc3RhbmNlIiwiZXh0cmFjdElBTkFab25lIiwiY3JlYXRlIiwiaXNvVGltZU9ubHkiLCJpc29EdXJhdGlvbiIsImV4dHJhY3RJU09EdXJhdGlvbiIsInllYXJTdHIiLCJtb250aFN0ciIsIndlZWtTdHIiLCJkYXlTdHIiLCJob3VyU3RyIiwibWludXRlU3RyIiwic2Vjb25kU3RyIiwibWlsbGlzZWNvbmRzU3RyIiwiaGFzTmVnYXRpdmVQcmVmaXgiLCJuZWdhdGl2ZVNlY29uZHMiLCJtYXliZU5lZ2F0ZSIsIm51bSIsImZvcmNlIiwidW5kZWZpbmVkIiwieWVhcnMiLCJtb250aHMiLCJ3ZWVrcyIsImRheXMiLCJvYnNPZmZzZXRzIiwiR01UIiwiRURUIiwiRVNUIiwiQ0RUIiwiQ1NUIiwiTURUIiwiTVNUIiwiUERUIiwiUFNUIiwiZnJvbVN0cmluZ3MiLCJ3ZWVrZGF5U3RyIiwicmVzdWx0IiwibW9udGhzU2hvcnQiLCJpbmRleE9mIiwiaG91ciIsIm1pbnV0ZSIsInNlY29uZCIsIndlZWtkYXkiLCJ3ZWVrZGF5c0xvbmciLCJ3ZWVrZGF5c1Nob3J0IiwicmZjMjgyMiIsImV4dHJhY3RSRkMyODIyIiwib2JzT2Zmc2V0IiwibWlsT2Zmc2V0Iiwib2ZmSG91clN0ciIsIm9mZk1pbnV0ZVN0ciIsIm9mZnNldCIsInByZXByb2Nlc3NSRkMyODIyIiwicmVwbGFjZSIsInRyaW0iLCJyZmMxMTIzIiwicmZjODUwIiwiYXNjaWkiLCJleHRyYWN0UkZDMTEyM09yODUwIiwidXRjSW5zdGFuY2UiLCJleHRyYWN0QVNDSUkiLCJpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4IiwiaXNvV2Vla1dpdGhUaW1lRXh0ZW5zaW9uUmVnZXgiLCJpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCIsImlzb1RpbWVDb21iaW5lZFJlZ2V4IiwiZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXQiLCJleHRyYWN0SVNPV2Vla1RpbWVBbmRPZmZzZXQiLCJleHRyYWN0SVNPT3JkaW5hbERhdGVBbmRUaW1lIiwiZXh0cmFjdElTT1RpbWVBbmRPZmZzZXQiLCJwYXJzZUlTT0RhdGUiLCJwYXJzZVJGQzI4MjJEYXRlIiwicGFyc2VIVFRQRGF0ZSIsInBhcnNlSVNPRHVyYXRpb24iLCJleHRyYWN0SVNPVGltZU9ubHkiLCJwYXJzZUlTT1RpbWVPbmx5Iiwic3FsWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCIsInNxbFRpbWVDb21iaW5lZFJlZ2V4IiwiZXh0cmFjdElTT1ltZFRpbWVPZmZzZXRBbmRJQU5BWm9uZSIsImV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmUiLCJwYXJzZVNRTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/impl/regexParser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/impl/tokenParser.js":
/*!****************************************************!*\
  !*** ./node_modules/luxon/src/impl/tokenParser.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   explainFromTokens: () => (/* binding */ explainFromTokens),\n/* harmony export */   parseFromTokens: () => (/* binding */ parseFromTokens)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"(rsc)/./node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _formatter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatter.js */ \"(rsc)/./node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(rsc)/./node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(rsc)/./node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../datetime.js */ \"(rsc)/./node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _digits_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./digits.js */ \"(rsc)/./node_modules/luxon/src/impl/digits.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/luxon/src/errors.js\");\n\n\n\n\n\n\n\nconst MISSING_FTP = \"missing Intl.DateTimeFormat.formatToParts support\";\nfunction intUnit(regex, post = (i)=>i) {\n    return {\n        regex,\n        deser: ([s])=>post((0,_digits_js__WEBPACK_IMPORTED_MODULE_0__.parseDigits)(s))\n    };\n}\nconst NBSP = String.fromCharCode(160);\nconst spaceOrNBSP = `( |${NBSP})`;\nconst spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, \"g\");\nfunction fixListRegex(s) {\n    // make dots optional and also make them literal\n    // make space and non breakable space characters interchangeable\n    return s.replace(/\\./g, \"\\\\.?\").replace(spaceOrNBSPRegExp, spaceOrNBSP);\n}\nfunction stripInsensitivities(s) {\n    return s.replace(/\\./g, \"\") // ignore dots that were made optional\n    .replace(spaceOrNBSPRegExp, \" \") // interchange space and nbsp\n    .toLowerCase();\n}\nfunction oneOf(strings, startIndex) {\n    if (strings === null) {\n        return null;\n    } else {\n        return {\n            regex: RegExp(strings.map(fixListRegex).join(\"|\")),\n            deser: ([s])=>strings.findIndex((i)=>stripInsensitivities(s) === stripInsensitivities(i)) + startIndex\n        };\n    }\n}\nfunction offset(regex, groups) {\n    return {\n        regex,\n        deser: ([, h, m])=>(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.signedOffset)(h, m),\n        groups\n    };\n}\nfunction simple(regex) {\n    return {\n        regex,\n        deser: ([s])=>s\n    };\n}\nfunction escapeToken(value) {\n    // eslint-disable-next-line no-useless-escape\n    return value.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n}\nfunction unitForToken(token, loc) {\n    const one = (0,_digits_js__WEBPACK_IMPORTED_MODULE_0__.digitRegex)(loc), two = (0,_digits_js__WEBPACK_IMPORTED_MODULE_0__.digitRegex)(loc, \"{2}\"), three = (0,_digits_js__WEBPACK_IMPORTED_MODULE_0__.digitRegex)(loc, \"{3}\"), four = (0,_digits_js__WEBPACK_IMPORTED_MODULE_0__.digitRegex)(loc, \"{4}\"), six = (0,_digits_js__WEBPACK_IMPORTED_MODULE_0__.digitRegex)(loc, \"{6}\"), oneOrTwo = (0,_digits_js__WEBPACK_IMPORTED_MODULE_0__.digitRegex)(loc, \"{1,2}\"), oneToThree = (0,_digits_js__WEBPACK_IMPORTED_MODULE_0__.digitRegex)(loc, \"{1,3}\"), oneToSix = (0,_digits_js__WEBPACK_IMPORTED_MODULE_0__.digitRegex)(loc, \"{1,6}\"), oneToNine = (0,_digits_js__WEBPACK_IMPORTED_MODULE_0__.digitRegex)(loc, \"{1,9}\"), twoToFour = (0,_digits_js__WEBPACK_IMPORTED_MODULE_0__.digitRegex)(loc, \"{2,4}\"), fourToSix = (0,_digits_js__WEBPACK_IMPORTED_MODULE_0__.digitRegex)(loc, \"{4,6}\"), literal = (t)=>({\n            regex: RegExp(escapeToken(t.val)),\n            deser: ([s])=>s,\n            literal: true\n        }), unitate = (t)=>{\n        if (token.literal) {\n            return literal(t);\n        }\n        switch(t.val){\n            // era\n            case \"G\":\n                return oneOf(loc.eras(\"short\", false), 0);\n            case \"GG\":\n                return oneOf(loc.eras(\"long\", false), 0);\n            // years\n            case \"y\":\n                return intUnit(oneToSix);\n            case \"yy\":\n                return intUnit(twoToFour, _util_js__WEBPACK_IMPORTED_MODULE_1__.untruncateYear);\n            case \"yyyy\":\n                return intUnit(four);\n            case \"yyyyy\":\n                return intUnit(fourToSix);\n            case \"yyyyyy\":\n                return intUnit(six);\n            // months\n            case \"M\":\n                return intUnit(oneOrTwo);\n            case \"MM\":\n                return intUnit(two);\n            case \"MMM\":\n                return oneOf(loc.months(\"short\", true, false), 1);\n            case \"MMMM\":\n                return oneOf(loc.months(\"long\", true, false), 1);\n            case \"L\":\n                return intUnit(oneOrTwo);\n            case \"LL\":\n                return intUnit(two);\n            case \"LLL\":\n                return oneOf(loc.months(\"short\", false, false), 1);\n            case \"LLLL\":\n                return oneOf(loc.months(\"long\", false, false), 1);\n            // dates\n            case \"d\":\n                return intUnit(oneOrTwo);\n            case \"dd\":\n                return intUnit(two);\n            // ordinals\n            case \"o\":\n                return intUnit(oneToThree);\n            case \"ooo\":\n                return intUnit(three);\n            // time\n            case \"HH\":\n                return intUnit(two);\n            case \"H\":\n                return intUnit(oneOrTwo);\n            case \"hh\":\n                return intUnit(two);\n            case \"h\":\n                return intUnit(oneOrTwo);\n            case \"mm\":\n                return intUnit(two);\n            case \"m\":\n                return intUnit(oneOrTwo);\n            case \"q\":\n                return intUnit(oneOrTwo);\n            case \"qq\":\n                return intUnit(two);\n            case \"s\":\n                return intUnit(oneOrTwo);\n            case \"ss\":\n                return intUnit(two);\n            case \"S\":\n                return intUnit(oneToThree);\n            case \"SSS\":\n                return intUnit(three);\n            case \"u\":\n                return simple(oneToNine);\n            // meridiem\n            case \"a\":\n                return oneOf(loc.meridiems(), 0);\n            // weekYear (k)\n            case \"kkkk\":\n                return intUnit(four);\n            case \"kk\":\n                return intUnit(twoToFour, _util_js__WEBPACK_IMPORTED_MODULE_1__.untruncateYear);\n            // weekNumber (W)\n            case \"W\":\n                return intUnit(oneOrTwo);\n            case \"WW\":\n                return intUnit(two);\n            // weekdays\n            case \"E\":\n            case \"c\":\n                return intUnit(one);\n            case \"EEE\":\n                return oneOf(loc.weekdays(\"short\", false, false), 1);\n            case \"EEEE\":\n                return oneOf(loc.weekdays(\"long\", false, false), 1);\n            case \"ccc\":\n                return oneOf(loc.weekdays(\"short\", true, false), 1);\n            case \"cccc\":\n                return oneOf(loc.weekdays(\"long\", true, false), 1);\n            // offset/zone\n            case \"Z\":\n            case \"ZZ\":\n                return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);\n            case \"ZZZ\":\n                return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);\n            // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing\n            // because we don't have any way to figure out what they are\n            case \"z\":\n                return simple(/[a-z_+-/]{1,256}?/i);\n            default:\n                return literal(t);\n        }\n    };\n    const unit = unitate(token) || {\n        invalidReason: MISSING_FTP\n    };\n    unit.token = token;\n    return unit;\n}\nconst partTypeStyleToTokenVal = {\n    year: {\n        \"2-digit\": \"yy\",\n        numeric: \"yyyyy\"\n    },\n    month: {\n        numeric: \"M\",\n        \"2-digit\": \"MM\",\n        short: \"MMM\",\n        long: \"MMMM\"\n    },\n    day: {\n        numeric: \"d\",\n        \"2-digit\": \"dd\"\n    },\n    weekday: {\n        short: \"EEE\",\n        long: \"EEEE\"\n    },\n    dayperiod: \"a\",\n    dayPeriod: \"a\",\n    hour: {\n        numeric: \"h\",\n        \"2-digit\": \"hh\"\n    },\n    minute: {\n        numeric: \"m\",\n        \"2-digit\": \"mm\"\n    },\n    second: {\n        numeric: \"s\",\n        \"2-digit\": \"ss\"\n    }\n};\nfunction tokenForPart(part, locale, formatOpts) {\n    const { type, value } = part;\n    if (type === \"literal\") {\n        return {\n            literal: true,\n            val: value\n        };\n    }\n    const style = formatOpts[type];\n    let val = partTypeStyleToTokenVal[type];\n    if (typeof val === \"object\") {\n        val = val[style];\n    }\n    if (val) {\n        return {\n            literal: false,\n            val\n        };\n    }\n    return undefined;\n}\nfunction buildRegex(units) {\n    const re = units.map((u)=>u.regex).reduce((f, r)=>`${f}(${r.source})`, \"\");\n    return [\n        `^${re}$`,\n        units\n    ];\n}\nfunction match(input, regex, handlers) {\n    const matches = input.match(regex);\n    if (matches) {\n        const all = {};\n        let matchIndex = 1;\n        for(const i in handlers){\n            if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(handlers, i)) {\n                const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;\n                if (!h.literal && h.token) {\n                    all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));\n                }\n                matchIndex += groups;\n            }\n        }\n        return [\n            matches,\n            all\n        ];\n    } else {\n        return [\n            matches,\n            {}\n        ];\n    }\n}\nfunction dateTimeFromMatches(matches) {\n    const toField = (token)=>{\n        switch(token){\n            case \"S\":\n                return \"millisecond\";\n            case \"s\":\n                return \"second\";\n            case \"m\":\n                return \"minute\";\n            case \"h\":\n            case \"H\":\n                return \"hour\";\n            case \"d\":\n                return \"day\";\n            case \"o\":\n                return \"ordinal\";\n            case \"L\":\n            case \"M\":\n                return \"month\";\n            case \"y\":\n                return \"year\";\n            case \"E\":\n            case \"c\":\n                return \"weekday\";\n            case \"W\":\n                return \"weekNumber\";\n            case \"k\":\n                return \"weekYear\";\n            case \"q\":\n                return \"quarter\";\n            default:\n                return null;\n        }\n    };\n    let zone;\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(matches.Z)) {\n        zone = new _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](matches.Z);\n    } else if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(matches.z)) {\n        zone = _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(matches.z);\n    } else {\n        zone = null;\n    }\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(matches.q)) {\n        matches.M = (matches.q - 1) * 3 + 1;\n    }\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(matches.h)) {\n        if (matches.h < 12 && matches.a === 1) {\n            matches.h += 12;\n        } else if (matches.h === 12 && matches.a === 0) {\n            matches.h = 0;\n        }\n    }\n    if (matches.G === 0 && matches.y) {\n        matches.y = -matches.y;\n    }\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(matches.u)) {\n        matches.S = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.parseMillis)(matches.u);\n    }\n    const vals = Object.keys(matches).reduce((r, k)=>{\n        const f = toField(k);\n        if (f) {\n            r[f] = matches[k];\n        }\n        return r;\n    }, {});\n    return [\n        vals,\n        zone\n    ];\n}\nlet dummyDateTimeCache = null;\nfunction getDummyDateTime() {\n    if (!dummyDateTimeCache) {\n        dummyDateTimeCache = _datetime_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fromMillis(1555555555555);\n    }\n    return dummyDateTimeCache;\n}\nfunction maybeExpandMacroToken(token, locale) {\n    if (token.literal) {\n        return token;\n    }\n    const formatOpts = _formatter_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].macroTokenToFormatOpts(token.val);\n    if (!formatOpts) {\n        return token;\n    }\n    const formatter = _formatter_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].create(locale, formatOpts);\n    const parts = formatter.formatDateTimeParts(getDummyDateTime());\n    const tokens = parts.map((p)=>tokenForPart(p, locale, formatOpts));\n    if (tokens.includes(undefined)) {\n        return token;\n    }\n    return tokens;\n}\nfunction expandMacroTokens(tokens, locale) {\n    return Array.prototype.concat(...tokens.map((t)=>maybeExpandMacroToken(t, locale)));\n}\n/**\n * @private\n */ function explainFromTokens(locale, input, format) {\n    const tokens = expandMacroTokens(_formatter_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].parseFormat(format), locale), units = tokens.map((t)=>unitForToken(t, locale)), disqualifyingUnit = units.find((t)=>t.invalidReason);\n    if (disqualifyingUnit) {\n        return {\n            input,\n            tokens,\n            invalidReason: disqualifyingUnit.invalidReason\n        };\n    } else {\n        const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, \"i\"), [rawMatches, matches] = match(input, regex, handlers), [result, zone] = matches ? dateTimeFromMatches(matches) : [\n            null,\n            null\n        ];\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(matches, \"a\") && (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(matches, \"H\")) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.ConflictingSpecificationError(\"Can't include meridiem when specifying 24-hour format\");\n        }\n        return {\n            input,\n            tokens,\n            regex,\n            rawMatches,\n            matches,\n            result,\n            zone\n        };\n    }\n}\nfunction parseFromTokens(locale, input, format) {\n    const { result, zone, invalidReason } = explainFromTokens(locale, input, format);\n    return [\n        result,\n        zone,\n        invalidReason\n    ];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvdG9rZW5QYXJzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQW1HO0FBQzVEO0FBQ21CO0FBQ2Q7QUFDTjtBQUNnQjtBQUNPO0FBRTdELE1BQU1ZLGNBQWM7QUFFcEIsU0FBU0MsUUFBUUMsS0FBSyxFQUFFQyxPQUFPQyxDQUFBQSxJQUFLQSxDQUFDO0lBQ25DLE9BQU87UUFBRUY7UUFBT0csT0FBTyxDQUFDLENBQUNDLEVBQUUsR0FBS0gsS0FBS0wsdURBQVdBLENBQUNRO0lBQUk7QUFDdkQ7QUFFQSxNQUFNQyxPQUFPQyxPQUFPQyxZQUFZLENBQUM7QUFDakMsTUFBTUMsY0FBYyxDQUFDLEdBQUcsRUFBRUgsS0FBSyxDQUFDLENBQUM7QUFDakMsTUFBTUksb0JBQW9CLElBQUlDLE9BQU9GLGFBQWE7QUFFbEQsU0FBU0csYUFBYVAsQ0FBQztJQUNyQixnREFBZ0Q7SUFDaEQsZ0VBQWdFO0lBQ2hFLE9BQU9BLEVBQUVRLE9BQU8sQ0FBQyxPQUFPLFFBQVFBLE9BQU8sQ0FBQ0gsbUJBQW1CRDtBQUM3RDtBQUVBLFNBQVNLLHFCQUFxQlQsQ0FBQztJQUM3QixPQUFPQSxFQUNKUSxPQUFPLENBQUMsT0FBTyxJQUFJLHNDQUFzQztLQUN6REEsT0FBTyxDQUFDSCxtQkFBbUIsS0FBSyw2QkFBNkI7S0FDN0RLLFdBQVc7QUFDaEI7QUFFQSxTQUFTQyxNQUFNQyxPQUFPLEVBQUVDLFVBQVU7SUFDaEMsSUFBSUQsWUFBWSxNQUFNO1FBQ3BCLE9BQU87SUFDVCxPQUFPO1FBQ0wsT0FBTztZQUNMaEIsT0FBT1UsT0FBT00sUUFBUUUsR0FBRyxDQUFDUCxjQUFjUSxJQUFJLENBQUM7WUFDN0NoQixPQUFPLENBQUMsQ0FBQ0MsRUFBRSxHQUNUWSxRQUFRSSxTQUFTLENBQUNsQixDQUFBQSxJQUFLVyxxQkFBcUJULE9BQU9TLHFCQUFxQlgsTUFBTWU7UUFDbEY7SUFDRjtBQUNGO0FBRUEsU0FBU0ksT0FB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UUFDQSxPQUFPO1lBQUVvRjtZQUFPOEI7WUFBUS9HO1lBQU80SDtZQUFZekM7WUFBUzBDO1lBQVFwQztRQUFLO0lBQ25FO0FBQ0Y7QUFFTyxTQUFTcUMsZ0JBQWdCMUQsTUFBTSxFQUFFYSxLQUFLLEVBQUVzQyxNQUFNO0lBQ25ELE1BQU0sRUFBRU0sTUFBTSxFQUFFcEMsSUFBSSxFQUFFckMsYUFBYSxFQUFFLEdBQUdrRSxrQkFBa0JsRCxRQUFRYSxPQUFPc0M7SUFDekUsT0FBTztRQUFDTTtRQUFRcEM7UUFBTXJDO0tBQWM7QUFDdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pYXRvb2xzLW5leHQvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvdG9rZW5QYXJzZXIuanM/ZTY2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZU1pbGxpcywgaXNVbmRlZmluZWQsIHVudHJ1bmNhdGVZZWFyLCBzaWduZWRPZmZzZXQsIGhhc093blByb3BlcnR5IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IHsgZGlnaXRSZWdleCwgcGFyc2VEaWdpdHMgfSBmcm9tIFwiLi9kaWdpdHMuanNcIjtcbmltcG9ydCB7IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuXG5jb25zdCBNSVNTSU5HX0ZUUCA9IFwibWlzc2luZyBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMgc3VwcG9ydFwiO1xuXG5mdW5jdGlvbiBpbnRVbml0KHJlZ2V4LCBwb3N0ID0gaSA9PiBpKSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFtzXSkgPT4gcG9zdChwYXJzZURpZ2l0cyhzKSkgfTtcbn1cblxuY29uc3QgTkJTUCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKTtcbmNvbnN0IHNwYWNlT3JOQlNQID0gYCggfCR7TkJTUH0pYDtcbmNvbnN0IHNwYWNlT3JOQlNQUmVnRXhwID0gbmV3IFJlZ0V4cChzcGFjZU9yTkJTUCwgXCJnXCIpO1xuXG5mdW5jdGlvbiBmaXhMaXN0UmVnZXgocykge1xuICAvLyBtYWtlIGRvdHMgb3B0aW9uYWwgYW5kIGFsc28gbWFrZSB0aGVtIGxpdGVyYWxcbiAgLy8gbWFrZSBzcGFjZSBhbmQgbm9uIGJyZWFrYWJsZSBzcGFjZSBjaGFyYWN0ZXJzIGludGVyY2hhbmdlYWJsZVxuICByZXR1cm4gcy5yZXBsYWNlKC9cXC4vZywgXCJcXFxcLj9cIikucmVwbGFjZShzcGFjZU9yTkJTUFJlZ0V4cCwgc3BhY2VPck5CU1ApO1xufVxuXG5mdW5jdGlvbiBzdHJpcEluc2Vuc2l0aXZpdGllcyhzKSB7XG4gIHJldHVybiBzXG4gICAgLnJlcGxhY2UoL1xcLi9nLCBcIlwiKSAvLyBpZ25vcmUgZG90cyB0aGF0IHdlcmUgbWFkZSBvcHRpb25hbFxuICAgIC5yZXBsYWNlKHNwYWNlT3JOQlNQUmVnRXhwLCBcIiBcIikgLy8gaW50ZXJjaGFuZ2Ugc3BhY2UgYW5kIG5ic3BcbiAgICAudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gb25lT2Yoc3RyaW5ncywgc3RhcnRJbmRleCkge1xuICBpZiAoc3RyaW5ncyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICByZWdleDogUmVnRXhwKHN0cmluZ3MubWFwKGZpeExpc3RSZWdleCkuam9pbihcInxcIikpLFxuICAgICAgZGVzZXI6IChbc10pID0+XG4gICAgICAgIHN0cmluZ3MuZmluZEluZGV4KGkgPT4gc3RyaXBJbnNlbnNpdGl2aXRpZXMocykgPT09IHN0cmlwSW5zZW5zaXRpdml0aWVzKGkpKSArIHN0YXJ0SW5kZXhcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG9mZnNldChyZWdleCwgZ3JvdXBzKSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFssIGgsIG1dKSA9PiBzaWduZWRPZmZzZXQoaCwgbSksIGdyb3VwcyB9O1xufVxuXG5mdW5jdGlvbiBzaW1wbGUocmVnZXgpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoW3NdKSA9PiBzIH07XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVRva2VuKHZhbHVlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICByZXR1cm4gdmFsdWUucmVwbGFjZSgvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpO1xufVxuXG5mdW5jdGlvbiB1bml0Rm9yVG9rZW4odG9rZW4sIGxvYykge1xuICBjb25zdCBvbmUgPSBkaWdpdFJlZ2V4KGxvYyksXG4gICAgdHdvID0gZGlnaXRSZWdleChsb2MsIFwiezJ9XCIpLFxuICAgIHRocmVlID0gZGlnaXRSZWdleChsb2MsIFwiezN9XCIpLFxuICAgIGZvdXIgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7NH1cIiksXG4gICAgc2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezZ9XCIpLFxuICAgIG9uZU9yVHdvID0gZGlnaXRSZWdleChsb2MsIFwiezEsMn1cIiksXG4gICAgb25lVG9UaHJlZSA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDN9XCIpLFxuICAgIG9uZVRvU2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezEsNn1cIiksXG4gICAgb25lVG9OaW5lID0gZGlnaXRSZWdleChsb2MsIFwiezEsOX1cIiksXG4gICAgdHdvVG9Gb3VyID0gZGlnaXRSZWdleChsb2MsIFwiezIsNH1cIiksXG4gICAgZm91clRvU2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezQsNn1cIiksXG4gICAgbGl0ZXJhbCA9IHQgPT4gKHsgcmVnZXg6IFJlZ0V4cChlc2NhcGVUb2tlbih0LnZhbCkpLCBkZXNlcjogKFtzXSkgPT4gcywgbGl0ZXJhbDogdHJ1ZSB9KSxcbiAgICB1bml0YXRlID0gdCA9PiB7XG4gICAgICBpZiAodG9rZW4ubGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbCh0KTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodC52YWwpIHtcbiAgICAgICAgLy8gZXJhXG4gICAgICAgIGNhc2UgXCJHXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5lcmFzKFwic2hvcnRcIiwgZmFsc2UpLCAwKTtcbiAgICAgICAgY2FzZSBcIkdHXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5lcmFzKFwibG9uZ1wiLCBmYWxzZSksIDApO1xuICAgICAgICAvLyB5ZWFyc1xuICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvU2l4KTtcbiAgICAgICAgY2FzZSBcInl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvVG9Gb3VyLCB1bnRydW5jYXRlWWVhcik7XG4gICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91cik7XG4gICAgICAgIGNhc2UgXCJ5eXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KGZvdXJUb1NpeCk7XG4gICAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChzaXgpO1xuICAgICAgICAvLyBtb250aHNcbiAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJNTU1cIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcInNob3J0XCIsIHRydWUsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJNTU1NXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJsb25nXCIsIHRydWUsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiTExcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiTExMXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJzaG9ydFwiLCBmYWxzZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcImxvbmdcIiwgZmFsc2UsIGZhbHNlKSwgMSk7XG4gICAgICAgIC8vIGRhdGVzXG4gICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICAvLyBvcmRpbmFsc1xuICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvVGhyZWUpO1xuICAgICAgICBjYXNlIFwib29vXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodGhyZWUpO1xuICAgICAgICAvLyB0aW1lXG4gICAgICAgIGNhc2UgXCJISFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiaGhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInNzXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVUb1RocmVlKTtcbiAgICAgICAgY2FzZSBcIlNTU1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHRocmVlKTtcbiAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKG9uZVRvTmluZSk7XG4gICAgICAgIC8vIG1lcmlkaWVtXG4gICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tZXJpZGllbXMoKSwgMCk7XG4gICAgICAgIC8vIHdlZWtZZWFyIChrKVxuICAgICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KGZvdXIpO1xuICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgLy8gd2Vla051bWJlciAoVylcbiAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJXV1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIC8vIHdlZWtkYXlzXG4gICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lKTtcbiAgICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJzaG9ydFwiLCBmYWxzZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwibG9uZ1wiLCBmYWxzZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcImNjY1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJzaG9ydFwiLCB0cnVlLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJsb25nXCIsIHRydWUsIGZhbHNlKSwgMSk7XG4gICAgICAgIC8vIG9mZnNldC96b25lXG4gICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgIGNhc2UgXCJaWlwiOlxuICAgICAgICAgIHJldHVybiBvZmZzZXQobmV3IFJlZ0V4cChgKFsrLV0ke29uZU9yVHdvLnNvdXJjZX0pKD86Oigke3R3by5zb3VyY2V9KSk/YCksIDIpO1xuICAgICAgICBjYXNlIFwiWlpaXCI6XG4gICAgICAgICAgcmV0dXJuIG9mZnNldChuZXcgUmVnRXhwKGAoWystXSR7b25lT3JUd28uc291cmNlfSkoJHt0d28uc291cmNlfSk/YCksIDIpO1xuICAgICAgICAvLyB3ZSBkb24ndCBzdXBwb3J0IFpaWlogKFBTVCkgb3IgWlpaWlogKFBhY2lmaWMgU3RhbmRhcmQgVGltZSkgaW4gcGFyc2luZ1xuICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYW55IHdheSB0byBmaWd1cmUgb3V0IHdoYXQgdGhleSBhcmVcbiAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKC9bYS16XystL117MSwyNTZ9Py9pKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbCh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGNvbnN0IHVuaXQgPSB1bml0YXRlKHRva2VuKSB8fCB7XG4gICAgaW52YWxpZFJlYXNvbjogTUlTU0lOR19GVFBcbiAgfTtcblxuICB1bml0LnRva2VuID0gdG9rZW47XG5cbiAgcmV0dXJuIHVuaXQ7XG59XG5cbmNvbnN0IHBhcnRUeXBlU3R5bGVUb1Rva2VuVmFsID0ge1xuICB5ZWFyOiB7XG4gICAgXCIyLWRpZ2l0XCI6IFwieXlcIixcbiAgICBudW1lcmljOiBcInl5eXl5XCJcbiAgfSxcbiAgbW9udGg6IHtcbiAgICBudW1lcmljOiBcIk1cIixcbiAgICBcIjItZGlnaXRcIjogXCJNTVwiLFxuICAgIHNob3J0OiBcIk1NTVwiLFxuICAgIGxvbmc6IFwiTU1NTVwiXG4gIH0sXG4gIGRheToge1xuICAgIG51bWVyaWM6IFwiZFwiLFxuICAgIFwiMi1kaWdpdFwiOiBcImRkXCJcbiAgfSxcbiAgd2Vla2RheToge1xuICAgIHNob3J0OiBcIkVFRVwiLFxuICAgIGxvbmc6IFwiRUVFRVwiXG4gIH0sXG4gIGRheXBlcmlvZDogXCJhXCIsXG4gIGRheVBlcmlvZDogXCJhXCIsXG4gIGhvdXI6IHtcbiAgICBudW1lcmljOiBcImhcIixcbiAgICBcIjItZGlnaXRcIjogXCJoaFwiXG4gIH0sXG4gIG1pbnV0ZToge1xuICAgIG51bWVyaWM6IFwibVwiLFxuICAgIFwiMi1kaWdpdFwiOiBcIm1tXCJcbiAgfSxcbiAgc2Vjb25kOiB7XG4gICAgbnVtZXJpYzogXCJzXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwic3NcIlxuICB9XG59O1xuXG5mdW5jdGlvbiB0b2tlbkZvclBhcnQocGFydCwgbG9jYWxlLCBmb3JtYXRPcHRzKSB7XG4gIGNvbnN0IHsgdHlwZSwgdmFsdWUgfSA9IHBhcnQ7XG5cbiAgaWYgKHR5cGUgPT09IFwibGl0ZXJhbFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdGVyYWw6IHRydWUsXG4gICAgICB2YWw6IHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHN0eWxlID0gZm9ybWF0T3B0c1t0eXBlXTtcblxuICBsZXQgdmFsID0gcGFydFR5cGVTdHlsZVRvVG9rZW5WYWxbdHlwZV07XG4gIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgdmFsID0gdmFsW3N0eWxlXTtcbiAgfVxuXG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl0ZXJhbDogZmFsc2UsXG4gICAgICB2YWxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZWdleCh1bml0cykge1xuICBjb25zdCByZSA9IHVuaXRzLm1hcCh1ID0+IHUucmVnZXgpLnJlZHVjZSgoZiwgcikgPT4gYCR7Zn0oJHtyLnNvdXJjZX0pYCwgXCJcIik7XG4gIHJldHVybiBbYF4ke3JlfSRgLCB1bml0c107XG59XG5cbmZ1bmN0aW9uIG1hdGNoKGlucHV0LCByZWdleCwgaGFuZGxlcnMpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGlucHV0Lm1hdGNoKHJlZ2V4KTtcblxuICBpZiAobWF0Y2hlcykge1xuICAgIGNvbnN0IGFsbCA9IHt9O1xuICAgIGxldCBtYXRjaEluZGV4ID0gMTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gaGFuZGxlcnMpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShoYW5kbGVycywgaSkpIHtcbiAgICAgICAgY29uc3QgaCA9IGhhbmRsZXJzW2ldLFxuICAgICAgICAgIGdyb3VwcyA9IGguZ3JvdXBzID8gaC5ncm91cHMgKyAxIDogMTtcbiAgICAgICAgaWYgKCFoLmxpdGVyYWwgJiYgaC50b2tlbikge1xuICAgICAgICAgIGFsbFtoLnRva2VuLnZhbFswXV0gPSBoLmRlc2VyKG1hdGNoZXMuc2xpY2UobWF0Y2hJbmRleCwgbWF0Y2hJbmRleCArIGdyb3VwcykpO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoSW5kZXggKz0gZ3JvdXBzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW21hdGNoZXMsIGFsbF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFttYXRjaGVzLCB7fV07XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0ZVRpbWVGcm9tTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIGNvbnN0IHRvRmllbGQgPSB0b2tlbiA9PiB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRcIjtcbiAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgIHJldHVybiBcInNlY29uZFwiO1xuICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgcmV0dXJuIFwibWludXRlXCI7XG4gICAgICBjYXNlIFwiaFwiOlxuICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgcmV0dXJuIFwiaG91clwiO1xuICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgcmV0dXJuIFwiZGF5XCI7XG4gICAgICBjYXNlIFwib1wiOlxuICAgICAgICByZXR1cm4gXCJvcmRpbmFsXCI7XG4gICAgICBjYXNlIFwiTFwiOlxuICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgcmV0dXJuIFwibW9udGhcIjtcbiAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgIHJldHVybiBcInllYXJcIjtcbiAgICAgIGNhc2UgXCJFXCI6XG4gICAgICBjYXNlIFwiY1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrZGF5XCI7XG4gICAgICBjYXNlIFwiV1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrTnVtYmVyXCI7XG4gICAgICBjYXNlIFwia1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrWWVhclwiO1xuICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgcmV0dXJuIFwicXVhcnRlclwiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGxldCB6b25lO1xuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMuWikpIHtcbiAgICB6b25lID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZShtYXRjaGVzLlopO1xuICB9IGVsc2UgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnopKSB7XG4gICAgem9uZSA9IElBTkFab25lLmNyZWF0ZShtYXRjaGVzLnopO1xuICB9IGVsc2Uge1xuICAgIHpvbmUgPSBudWxsO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnEpKSB7XG4gICAgbWF0Y2hlcy5NID0gKG1hdGNoZXMucSAtIDEpICogMyArIDE7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMuaCkpIHtcbiAgICBpZiAobWF0Y2hlcy5oIDwgMTIgJiYgbWF0Y2hlcy5hID09PSAxKSB7XG4gICAgICBtYXRjaGVzLmggKz0gMTI7XG4gICAgfSBlbHNlIGlmIChtYXRjaGVzLmggPT09IDEyICYmIG1hdGNoZXMuYSA9PT0gMCkge1xuICAgICAgbWF0Y2hlcy5oID0gMDtcbiAgICB9XG4gIH1cblxuICBpZiAobWF0Y2hlcy5HID09PSAwICYmIG1hdGNoZXMueSkge1xuICAgIG1hdGNoZXMueSA9IC1tYXRjaGVzLnk7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMudSkpIHtcbiAgICBtYXRjaGVzLlMgPSBwYXJzZU1pbGxpcyhtYXRjaGVzLnUpO1xuICB9XG5cbiAgY29uc3QgdmFscyA9IE9iamVjdC5rZXlzKG1hdGNoZXMpLnJlZHVjZSgociwgaykgPT4ge1xuICAgIGNvbnN0IGYgPSB0b0ZpZWxkKGspO1xuICAgIGlmIChmKSB7XG4gICAgICByW2ZdID0gbWF0Y2hlc1trXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfSwge30pO1xuXG4gIHJldHVybiBbdmFscywgem9uZV07XG59XG5cbmxldCBkdW1teURhdGVUaW1lQ2FjaGUgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXREdW1teURhdGVUaW1lKCkge1xuICBpZiAoIWR1bW15RGF0ZVRpbWVDYWNoZSkge1xuICAgIGR1bW15RGF0ZVRpbWVDYWNoZSA9IERhdGVUaW1lLmZyb21NaWxsaXMoMTU1NTU1NTU1NTU1NSk7XG4gIH1cblxuICByZXR1cm4gZHVtbXlEYXRlVGltZUNhY2hlO1xufVxuXG5mdW5jdGlvbiBtYXliZUV4cGFuZE1hY3JvVG9rZW4odG9rZW4sIGxvY2FsZSkge1xuICBpZiAodG9rZW4ubGl0ZXJhbCkge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdE9wdHMgPSBGb3JtYXR0ZXIubWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbi52YWwpO1xuXG4gIGlmICghZm9ybWF0T3B0cykge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdHRlciA9IEZvcm1hdHRlci5jcmVhdGUobG9jYWxlLCBmb3JtYXRPcHRzKTtcbiAgY29uc3QgcGFydHMgPSBmb3JtYXR0ZXIuZm9ybWF0RGF0ZVRpbWVQYXJ0cyhnZXREdW1teURhdGVUaW1lKCkpO1xuXG4gIGNvbnN0IHRva2VucyA9IHBhcnRzLm1hcChwID0+IHRva2VuRm9yUGFydChwLCBsb2NhbGUsIGZvcm1hdE9wdHMpKTtcblxuICBpZiAodG9rZW5zLmluY2x1ZGVzKHVuZGVmaW5lZCkpIHtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufVxuXG5mdW5jdGlvbiBleHBhbmRNYWNyb1Rva2Vucyh0b2tlbnMsIGxvY2FsZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi50b2tlbnMubWFwKHQgPT4gbWF5YmVFeHBhbmRNYWNyb1Rva2VuKHQsIGxvY2FsZSkpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpIHtcbiAgY29uc3QgdG9rZW5zID0gZXhwYW5kTWFjcm9Ub2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZvcm1hdCksIGxvY2FsZSksXG4gICAgdW5pdHMgPSB0b2tlbnMubWFwKHQgPT4gdW5pdEZvclRva2VuKHQsIGxvY2FsZSkpLFxuICAgIGRpc3F1YWxpZnlpbmdVbml0ID0gdW5pdHMuZmluZCh0ID0+IHQuaW52YWxpZFJlYXNvbik7XG5cbiAgaWYgKGRpc3F1YWxpZnlpbmdVbml0KSB7XG4gICAgcmV0dXJuIHsgaW5wdXQsIHRva2VucywgaW52YWxpZFJlYXNvbjogZGlzcXVhbGlmeWluZ1VuaXQuaW52YWxpZFJlYXNvbiB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtyZWdleFN0cmluZywgaGFuZGxlcnNdID0gYnVpbGRSZWdleCh1bml0cyksXG4gICAgICByZWdleCA9IFJlZ0V4cChyZWdleFN0cmluZywgXCJpXCIpLFxuICAgICAgW3Jhd01hdGNoZXMsIG1hdGNoZXNdID0gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycyksXG4gICAgICBbcmVzdWx0LCB6b25lXSA9IG1hdGNoZXMgPyBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpIDogW251bGwsIG51bGxdO1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShtYXRjaGVzLCBcImFcIikgJiYgaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJIXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgaW5jbHVkZSBtZXJpZGllbSB3aGVuIHNwZWNpZnlpbmcgMjQtaG91ciBmb3JtYXRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5wdXQsIHRva2VucywgcmVnZXgsIHJhd01hdGNoZXMsIG1hdGNoZXMsIHJlc3VsdCwgem9uZSB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KSB7XG4gIGNvbnN0IHsgcmVzdWx0LCB6b25lLCBpbnZhbGlkUmVhc29uIH0gPSBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpO1xuICByZXR1cm4gW3Jlc3VsdCwgem9uZSwgaW52YWxpZFJlYXNvbl07XG59XG4iXSwibmFtZXMiOlsicGFyc2VNaWxsaXMiLCJpc1VuZGVmaW5lZCIsInVudHJ1bmNhdGVZZWFyIiwic2lnbmVkT2Zmc2V0IiwiaGFzT3duUHJvcGVydHkiLCJGb3JtYXR0ZXIiLCJGaXhlZE9mZnNldFpvbmUiLCJJQU5BWm9uZSIsIkRhdGVUaW1lIiwiZGlnaXRSZWdleCIsInBhcnNlRGlnaXRzIiwiQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IiLCJNSVNTSU5HX0ZUUCIsImludFVuaXQiLCJyZWdleCIsInBvc3QiLCJpIiwiZGVzZXIiLCJzIiwiTkJTUCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInNwYWNlT3JOQlNQIiwic3BhY2VPck5CU1BSZWdFeHAiLCJSZWdFeHAiLCJmaXhMaXN0UmVnZXgiLCJyZXBsYWNlIiwic3RyaXBJbnNlbnNpdGl2aXRpZXMiLCJ0b0xvd2VyQ2FzZSIsIm9uZU9mIiwic3RyaW5ncyIsInN0YXJ0SW5kZXgiLCJtYXAiLCJqb2luIiwiZmluZEluZGV4Iiwib2Zmc2V0IiwiZ3JvdXBzIiwiaCIsIm0iLCJzaW1wbGUiLCJlc2NhcGVUb2tlbiIsInZhbHVlIiwidW5pdEZvclRva2VuIiwidG9rZW4iLCJsb2MiLCJvbmUiLCJ0d28iLCJ0aHJlZSIsImZvdXIiLCJzaXgiLCJvbmVPclR3byIsIm9uZVRvVGhyZWUiLCJvbmVUb1NpeCIsIm9uZVRvTmluZSIsInR3b1RvRm91ciIsImZvdXJUb1NpeCIsImxpdGVyYWwiLCJ0IiwidmFsIiwidW5pdGF0ZSIsImVyYXMiLCJtb250aHMiLCJtZXJpZGllbXMiLCJ3ZWVrZGF5cyIsInNvdXJjZSIsInVuaXQiLCJpbnZhbGlkUmVhc29uIiwicGFydFR5cGVTdHlsZVRvVG9rZW5WYWwiLCJ5ZWFyIiwibnVtZXJpYyIsIm1vbnRoIiwic2hvcnQiLCJsb25nIiwiZGF5Iiwid2Vla2RheSIsImRheXBlcmlvZCIsImRheVBlcmlvZCIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJ0b2tlbkZvclBhcnQiLCJwYXJ0IiwibG9jYWxlIiwiZm9ybWF0T3B0cyIsInR5cGUiLCJzdHlsZSIsInVuZGVmaW5lZCIsImJ1aWxkUmVnZXgiLCJ1bml0cyIsInJlIiwidSIsInJlZHVjZSIsImYiLCJyIiwibWF0Y2giLCJpbnB1dCIsImhhbmRsZXJzIiwibWF0Y2hlcyIsImFsbCIsIm1hdGNoSW5kZXgiLCJzbGljZSIsImRhdGVUaW1lRnJvbU1hdGNoZXMiLCJ0b0ZpZWxkIiwiem9uZSIsIloiLCJ6IiwiY3JlYXRlIiwicSIsIk0iLCJhIiwiRyIsInkiLCJTIiwidmFscyIsIk9iamVjdCIsImtleXMiLCJrIiwiZHVtbXlEYXRlVGltZUNhY2hlIiwiZ2V0RHVtbXlEYXRlVGltZSIsImZyb21NaWxsaXMiLCJtYXliZUV4cGFuZE1hY3JvVG9rZW4iLCJtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzIiwiZm9ybWF0dGVyIiwicGFydHMiLCJmb3JtYXREYXRlVGltZVBhcnRzIiwidG9rZW5zIiwicCIsImluY2x1ZGVzIiwiZXhwYW5kTWFjcm9Ub2tlbnMiLCJBcnJheSIsInByb3RvdHlwZSIsImNvbmNhdCIsImV4cGxhaW5Gcm9tVG9rZW5zIiwiZm9ybWF0IiwicGFyc2VGb3JtYXQiLCJkaXNxdWFsaWZ5aW5nVW5pdCIsImZpbmQiLCJyZWdleFN0cmluZyIsInJhd01hdGNoZXMiLCJyZXN1bHQiLCJwYXJzZUZyb21Ub2tlbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/impl/tokenParser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/impl/util.js":
/*!*********************************************!*\
  !*** ./node_modules/luxon/src/impl/util.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asNumber: () => (/* binding */ asNumber),\n/* harmony export */   bestBy: () => (/* binding */ bestBy),\n/* harmony export */   daysInMonth: () => (/* binding */ daysInMonth),\n/* harmony export */   daysInYear: () => (/* binding */ daysInYear),\n/* harmony export */   floorMod: () => (/* binding */ floorMod),\n/* harmony export */   formatOffset: () => (/* binding */ formatOffset),\n/* harmony export */   hasFormatToParts: () => (/* binding */ hasFormatToParts),\n/* harmony export */   hasIntl: () => (/* binding */ hasIntl),\n/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),\n/* harmony export */   hasRelative: () => (/* binding */ hasRelative),\n/* harmony export */   ianaRegex: () => (/* binding */ ianaRegex),\n/* harmony export */   integerBetween: () => (/* binding */ integerBetween),\n/* harmony export */   isDate: () => (/* binding */ isDate),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   isLeapYear: () => (/* binding */ isLeapYear),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   maybeArray: () => (/* binding */ maybeArray),\n/* harmony export */   normalizeObject: () => (/* binding */ normalizeObject),\n/* harmony export */   objToLocalTS: () => (/* binding */ objToLocalTS),\n/* harmony export */   padStart: () => (/* binding */ padStart),\n/* harmony export */   parseInteger: () => (/* binding */ parseInteger),\n/* harmony export */   parseMillis: () => (/* binding */ parseMillis),\n/* harmony export */   parseZoneInfo: () => (/* binding */ parseZoneInfo),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   roundTo: () => (/* binding */ roundTo),\n/* harmony export */   signedOffset: () => (/* binding */ signedOffset),\n/* harmony export */   timeObject: () => (/* binding */ timeObject),\n/* harmony export */   untruncateYear: () => (/* binding */ untruncateYear),\n/* harmony export */   weeksInWeekYear: () => (/* binding */ weeksInWeekYear)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/luxon/src/errors.js\");\n/*\n  This is just a junk drawer, containing anything used across multiple classes.\n  Because Luxon is small(ish), this should stay small and we won't worry about splitting\n  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.\n*/ \n/**\n * @private\n */ // TYPES\nfunction isUndefined(o) {\n    return typeof o === \"undefined\";\n}\nfunction isNumber(o) {\n    return typeof o === \"number\";\n}\nfunction isInteger(o) {\n    return typeof o === \"number\" && o % 1 === 0;\n}\nfunction isString(o) {\n    return typeof o === \"string\";\n}\nfunction isDate(o) {\n    return Object.prototype.toString.call(o) === \"[object Date]\";\n}\n// CAPABILITIES\nfunction hasIntl() {\n    try {\n        return typeof Intl !== \"undefined\" && Intl.DateTimeFormat;\n    } catch (e) {\n        return false;\n    }\n}\nfunction hasFormatToParts() {\n    return !isUndefined(Intl.DateTimeFormat.prototype.formatToParts);\n}\nfunction hasRelative() {\n    try {\n        return typeof Intl !== \"undefined\" && !!Intl.RelativeTimeFormat;\n    } catch (e) {\n        return false;\n    }\n}\n// OBJECTS AND ARRAYS\nfunction maybeArray(thing) {\n    return Array.isArray(thing) ? thing : [\n        thing\n    ];\n}\nfunction bestBy(arr, by, compare) {\n    if (arr.length === 0) {\n        return undefined;\n    }\n    return arr.reduce((best, next)=>{\n        const pair = [\n            by(next),\n            next\n        ];\n        if (!best) {\n            return pair;\n        } else if (compare(best[0], pair[0]) === best[0]) {\n            return best;\n        } else {\n            return pair;\n        }\n    }, null)[1];\n}\nfunction pick(obj, keys) {\n    return keys.reduce((a, k)=>{\n        a[k] = obj[k];\n        return a;\n    }, {});\n}\nfunction hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n// NUMBERS AND STRINGS\nfunction integerBetween(thing, bottom, top) {\n    return isInteger(thing) && thing >= bottom && thing <= top;\n}\n// x % n but takes the sign of n instead of x\nfunction floorMod(x, n) {\n    return x - n * Math.floor(x / n);\n}\nfunction padStart(input, n = 2) {\n    const minus = input < 0 ? \"-\" : \"\";\n    const target = minus ? input * -1 : input;\n    let result;\n    if (target.toString().length < n) {\n        result = (\"0\".repeat(n) + target).slice(-n);\n    } else {\n        result = target.toString();\n    }\n    return `${minus}${result}`;\n}\nfunction parseInteger(string) {\n    if (isUndefined(string) || string === null || string === \"\") {\n        return undefined;\n    } else {\n        return parseInt(string, 10);\n    }\n}\nfunction parseMillis(fraction) {\n    // Return undefined (instead of 0) in these cases, where fraction is not set\n    if (isUndefined(fraction) || fraction === null || fraction === \"\") {\n        return undefined;\n    } else {\n        const f = parseFloat(\"0.\" + fraction) * 1000;\n        return Math.floor(f);\n    }\n}\nfunction roundTo(number, digits, towardZero = false) {\n    const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;\n    return rounder(number * factor) / factor;\n}\n// DATE BASICS\nfunction isLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\nfunction daysInYear(year) {\n    return isLeapYear(year) ? 366 : 365;\n}\nfunction daysInMonth(year, month) {\n    const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;\n    if (modMonth === 2) {\n        return isLeapYear(modYear) ? 29 : 28;\n    } else {\n        return [\n            31,\n            null,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ][modMonth - 1];\n    }\n}\n// covert a calendar object to a local timestamp (epoch, but with the offset baked in)\nfunction objToLocalTS(obj) {\n    let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);\n    // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that\n    if (obj.year < 100 && obj.year >= 0) {\n        d = new Date(d);\n        d.setUTCFullYear(d.getUTCFullYear() - 1900);\n    }\n    return +d;\n}\nfunction weeksInWeekYear(weekYear) {\n    const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;\n    return p1 === 4 || p2 === 3 ? 53 : 52;\n}\nfunction untruncateYear(year) {\n    if (year > 99) {\n        return year;\n    } else return year > 60 ? 1900 + year : 2000 + year;\n}\n// PARSING\nfunction parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {\n    const date = new Date(ts), intlOpts = {\n        hour12: false,\n        year: \"numeric\",\n        month: \"2-digit\",\n        day: \"2-digit\",\n        hour: \"2-digit\",\n        minute: \"2-digit\"\n    };\n    if (timeZone) {\n        intlOpts.timeZone = timeZone;\n    }\n    const modified = Object.assign({\n        timeZoneName: offsetFormat\n    }, intlOpts), intl = hasIntl();\n    if (intl && hasFormatToParts()) {\n        const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m)=>m.type.toLowerCase() === \"timezonename\");\n        return parsed ? parsed.value : null;\n    } else if (intl) {\n        // this probably doesn't work for all locales\n        const without = new Intl.DateTimeFormat(locale, intlOpts).format(date), included = new Intl.DateTimeFormat(locale, modified).format(date), diffed = included.substring(without.length), trimmed = diffed.replace(/^[, \\u200e]+/, \"\");\n        return trimmed;\n    } else {\n        return null;\n    }\n}\n// signedOffset('-5', '30') -> -330\nfunction signedOffset(offHourStr, offMinuteStr) {\n    let offHour = parseInt(offHourStr, 10);\n    // don't || this because we want to preserve -0\n    if (Number.isNaN(offHour)) {\n        offHour = 0;\n    }\n    const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;\n    return offHour * 60 + offMinSigned;\n}\n// COERCION\nfunction asNumber(value) {\n    const numericValue = Number(value);\n    if (typeof value === \"boolean\" || value === \"\" || Number.isNaN(numericValue)) throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(`Invalid unit value ${value}`);\n    return numericValue;\n}\nfunction normalizeObject(obj, normalizer, nonUnitKeys) {\n    const normalized = {};\n    for(const u in obj){\n        if (hasOwnProperty(obj, u)) {\n            if (nonUnitKeys.indexOf(u) >= 0) continue;\n            const v = obj[u];\n            if (v === undefined || v === null) continue;\n            normalized[normalizer(u)] = asNumber(v);\n        }\n    }\n    return normalized;\n}\nfunction formatOffset(offset, format) {\n    const hours = Math.trunc(Math.abs(offset / 60)), minutes = Math.trunc(Math.abs(offset % 60)), sign = offset >= 0 ? \"+\" : \"-\";\n    switch(format){\n        case \"short\":\n            return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;\n        case \"narrow\":\n            return `${sign}${hours}${minutes > 0 ? `:${minutes}` : \"\"}`;\n        case \"techie\":\n            return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;\n        default:\n            throw new RangeError(`Value format ${format} is out of range for property format`);\n    }\n}\nfunction timeObject(obj) {\n    return pick(obj, [\n        \"hour\",\n        \"minute\",\n        \"second\",\n        \"millisecond\"\n    ]);\n}\nconst ianaRegex = /[A-Za-z_+-]{1,256}(:?\\/[A-Za-z_+-]{1,256}(\\/[A-Za-z_+-]{1,256})?)?/;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvdXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0FBSUEsR0FFb0Q7QUFFcEQ7O0NBRUMsR0FFRCxRQUFRO0FBRUQsU0FBU0MsWUFBWUMsQ0FBQztJQUMzQixPQUFPLE9BQU9BLE1BQU07QUFDdEI7QUFFTyxTQUFTQyxTQUFTRCxDQUFDO0lBQ3hCLE9BQU8sT0FBT0EsTUFBTTtBQUN0QjtBQUVPLFNBQVNFLFVBQVVGLENBQUM7SUFDekIsT0FBTyxPQUFPQSxNQUFNLFlBQVlBLElBQUksTUFBTTtBQUM1QztBQUVPLFNBQVNHLFNBQVNILENBQUM7SUFDeEIsT0FBTyxPQUFPQSxNQUFNO0FBQ3RCO0FBRU8sU0FBU0ksT0FBT0osQ0FBQztJQUN0QixPQUFPSyxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDUixPQUFPO0FBQy9DO0FBRUEsZUFBZTtBQUVSLFNBQVNTO0lBQ2QsSUFBSTtRQUNGLE9BQU8sT0FBT0MsU0FBUyxlQUFlQSxLQUFLQyxjQUFjO0lBQzNELEVBQUUsT0FBT0MsR0FBRztRQUNWLE9BQU87SUFDVDtBQUNGO0FBRU8sU0FBU0M7SUFDZCxPQUFPLENBQUNkLFlBQVlXLEtBQUtDLGNBQWMsQ0FBQ0wsU0FBUyxDQUFDUSxhQUFhO0FBQ2pFO0FBRU8sU0FBU0M7SUFDZCxJQUFJO1FBQ0YsT0FBTyxPQUFPTCxTQUFTLGVBQWUsQ0FBQyxDQUFDQSxLQUFLTSxrQkFBa0I7SUFDakUsRUFBRSxPQUFPSixHQUFHO1FBQ1YsT0FBTztJQUNUO0FBQ0Y7QUFFQSxxQkFBcUI7QUFFZCxTQUFTSyxXQUFXQyxLQUFLO0lBQzlCLE9BQU9DLE1BQU1DLE9BQU8sQ0FBQ0YsU0FBU0EsUUFBUTtRQUFDQTtLQUFNO0FBQy9DO0FBRU8sU0FBU0csT0FBT0MsR0FBRyxFQUFFQyxFQUFFLEVBQUVDLE9BQU87SUFDckMsSUFBSUYsSUFB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QUFNO0lBRTdCLE9BQVF6QjtRQUNOLEtBQUs7WUFDSCxPQUFPLENBQUMsRUFBRTZCLEtBQUssRUFBRTlGLFNBQVMyRixPQUFPLEdBQUcsQ0FBQyxFQUFFM0YsU0FBUzZGLFNBQVMsR0FBRyxDQUFDO1FBQy9ELEtBQUs7WUFDSCxPQUFPLENBQUMsRUFBRUMsS0FBSyxFQUFFSCxNQUFNLEVBQUVFLFVBQVUsSUFBSSxDQUFDLENBQUMsRUFBRUEsUUFBUSxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQzdELEtBQUs7WUFDSCxPQUFPLENBQUMsRUFBRUMsS0FBSyxFQUFFOUYsU0FBUzJGLE9BQU8sR0FBRyxFQUFFM0YsU0FBUzZGLFNBQVMsR0FBRyxDQUFDO1FBQzlEO1lBQ0UsTUFBTSxJQUFJRSxXQUFXLENBQUMsYUFBYSxFQUFFOUIsT0FBTyxvQ0FBb0MsQ0FBQztJQUNyRjtBQUNGO0FBRU8sU0FBUytCLFdBQVc5RyxHQUFHO0lBQzVCLE9BQU9ELEtBQUtDLEtBQUs7UUFBQztRQUFRO1FBQVU7UUFBVTtLQUFjO0FBQzlEO0FBRU8sTUFBTStHLFlBQVkscUVBQXFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWF0b29scy1uZXh0Ly4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3V0aWwuanM/ZWQ5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBUaGlzIGlzIGp1c3QgYSBqdW5rIGRyYXdlciwgY29udGFpbmluZyBhbnl0aGluZyB1c2VkIGFjcm9zcyBtdWx0aXBsZSBjbGFzc2VzLlxuICBCZWNhdXNlIEx1eG9uIGlzIHNtYWxsKGlzaCksIHRoaXMgc2hvdWxkIHN0YXkgc21hbGwgYW5kIHdlIHdvbid0IHdvcnJ5IGFib3V0IHNwbGl0dGluZ1xuICBpdCB1cCBpbnRvLCBzYXksIHBhcnNpbmdVdGlsLmpzIGFuZCBiYXNpY1V0aWwuanMgYW5kIHNvIG9uLiBCdXQgdGhleSBhcmUgZGl2aWRlZCB1cCBieSBmZWF0dXJlIGFyZWEuXG4qL1xuXG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8vIFRZUEVTXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZChvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJ1bmRlZmluZWRcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm51bWJlclwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm51bWJlclwiICYmIG8gJSAxID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwic3RyaW5nXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbn1cblxuLy8gQ0FQQUJJTElUSUVTXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnRsKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgSW50bCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBJbnRsLkRhdGVUaW1lRm9ybWF0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNGb3JtYXRUb1BhcnRzKCkge1xuICByZXR1cm4gIWlzVW5kZWZpbmVkKEludGwuRGF0ZVRpbWVGb3JtYXQucHJvdG90eXBlLmZvcm1hdFRvUGFydHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzUmVsYXRpdmUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHR5cGVvZiBJbnRsICE9PSBcInVuZGVmaW5lZFwiICYmICEhSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gT0JKRUNUUyBBTkQgQVJSQVlTXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUFycmF5KHRoaW5nKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHRoaW5nKSA/IHRoaW5nIDogW3RoaW5nXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJlc3RCeShhcnIsIGJ5LCBjb21wYXJlKSB7XG4gIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gYXJyLnJlZHVjZSgoYmVzdCwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IHBhaXIgPSBbYnkobmV4dCksIG5leHRdO1xuICAgIGlmICghYmVzdCkge1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfSBlbHNlIGlmIChjb21wYXJlKGJlc3RbMF0sIHBhaXJbMF0pID09PSBiZXN0WzBdKSB7XG4gICAgICByZXR1cm4gYmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfVxuICB9LCBudWxsKVsxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpY2sob2JqLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZSgoYSwgaykgPT4ge1xuICAgIGFba10gPSBvYmpba107XG4gICAgcmV0dXJuIGE7XG4gIH0sIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbi8vIE5VTUJFUlMgQU5EIFNUUklOR1NcblxuZXhwb3J0IGZ1bmN0aW9uIGludGVnZXJCZXR3ZWVuKHRoaW5nLCBib3R0b20sIHRvcCkge1xuICByZXR1cm4gaXNJbnRlZ2VyKHRoaW5nKSAmJiB0aGluZyA+PSBib3R0b20gJiYgdGhpbmcgPD0gdG9wO1xufVxuXG4vLyB4ICUgbiBidXQgdGFrZXMgdGhlIHNpZ24gb2YgbiBpbnN0ZWFkIG9mIHhcbmV4cG9ydCBmdW5jdGlvbiBmbG9vck1vZCh4LCBuKSB7XG4gIHJldHVybiB4IC0gbiAqIE1hdGguZmxvb3IoeCAvIG4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFkU3RhcnQoaW5wdXQsIG4gPSAyKSB7XG4gIGNvbnN0IG1pbnVzID0gaW5wdXQgPCAwID8gXCItXCIgOiBcIlwiO1xuICBjb25zdCB0YXJnZXQgPSBtaW51cyA/IGlucHV0ICogLTEgOiBpbnB1dDtcbiAgbGV0IHJlc3VsdDtcblxuICBpZiAodGFyZ2V0LnRvU3RyaW5nKCkubGVuZ3RoIDwgbikge1xuICAgIHJlc3VsdCA9IChcIjBcIi5yZXBlYXQobikgKyB0YXJnZXQpLnNsaWNlKC1uKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0YXJnZXQudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiBgJHttaW51c30ke3Jlc3VsdH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbnRlZ2VyKHN0cmluZykge1xuICBpZiAoaXNVbmRlZmluZWQoc3RyaW5nKSB8fCBzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWlsbGlzKGZyYWN0aW9uKSB7XG4gIC8vIFJldHVybiB1bmRlZmluZWQgKGluc3RlYWQgb2YgMCkgaW4gdGhlc2UgY2FzZXMsIHdoZXJlIGZyYWN0aW9uIGlzIG5vdCBzZXRcbiAgaWYgKGlzVW5kZWZpbmVkKGZyYWN0aW9uKSB8fCBmcmFjdGlvbiA9PT0gbnVsbCB8fCBmcmFjdGlvbiA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZiA9IHBhcnNlRmxvYXQoXCIwLlwiICsgZnJhY3Rpb24pICogMTAwMDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihmKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRUbyhudW1iZXIsIGRpZ2l0cywgdG93YXJkWmVybyA9IGZhbHNlKSB7XG4gIGNvbnN0IGZhY3RvciA9IDEwICoqIGRpZ2l0cyxcbiAgICByb3VuZGVyID0gdG93YXJkWmVybyA/IE1hdGgudHJ1bmMgOiBNYXRoLnJvdW5kO1xuICByZXR1cm4gcm91bmRlcihudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xufVxuXG4vLyBEQVRFIEJBU0lDU1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gIGNvbnN0IG1vZE1vbnRoID0gZmxvb3JNb2QobW9udGggLSAxLCAxMikgKyAxLFxuICAgIG1vZFllYXIgPSB5ZWFyICsgKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG5cbiAgaWYgKG1vZE1vbnRoID09PSAyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIobW9kWWVhcikgPyAyOSA6IDI4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb2RNb250aCAtIDFdO1xuICB9XG59XG5cbi8vIGNvdmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGxvY2FsIHRpbWVzdGFtcCAoZXBvY2gsIGJ1dCB3aXRoIHRoZSBvZmZzZXQgYmFrZWQgaW4pXG5leHBvcnQgZnVuY3Rpb24gb2JqVG9Mb2NhbFRTKG9iaikge1xuICBsZXQgZCA9IERhdGUuVVRDKFxuICAgIG9iai55ZWFyLFxuICAgIG9iai5tb250aCAtIDEsXG4gICAgb2JqLmRheSxcbiAgICBvYmouaG91cixcbiAgICBvYmoubWludXRlLFxuICAgIG9iai5zZWNvbmQsXG4gICAgb2JqLm1pbGxpc2Vjb25kXG4gICk7XG5cbiAgLy8gZm9yIGxlZ2FjeSByZWFzb25zLCB5ZWFycyBiZXR3ZWVuIDAgYW5kIDk5IGFyZSBpbnRlcnByZXRlZCBhcyAxOVhYOyByZXZlcnQgdGhhdFxuICBpZiAob2JqLnllYXIgPCAxMDAgJiYgb2JqLnllYXIgPj0gMCkge1xuICAgIGQgPSBuZXcgRGF0ZShkKTtcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDApO1xuICB9XG4gIHJldHVybiArZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtzSW5XZWVrWWVhcih3ZWVrWWVhcikge1xuICBjb25zdCBwMSA9XG4gICAgICAod2Vla1llYXIgK1xuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gNCkgLVxuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gMTAwKSArXG4gICAgICAgIE1hdGguZmxvb3Iod2Vla1llYXIgLyA0MDApKSAlXG4gICAgICA3LFxuICAgIGxhc3QgPSB3ZWVrWWVhciAtIDEsXG4gICAgcDIgPSAobGFzdCArIE1hdGguZmxvb3IobGFzdCAvIDQpIC0gTWF0aC5mbG9vcihsYXN0IC8gMTAwKSArIE1hdGguZmxvb3IobGFzdCAvIDQwMCkpICUgNztcbiAgcmV0dXJuIHAxID09PSA0IHx8IHAyID09PSAzID8gNTMgOiA1Mjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXIpIHtcbiAgaWYgKHllYXIgPiA5OSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9IGVsc2UgcmV0dXJuIHllYXIgPiA2MCA/IDE5MDAgKyB5ZWFyIDogMjAwMCArIHllYXI7XG59XG5cbi8vIFBBUlNJTkdcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlWm9uZUluZm8odHMsIG9mZnNldEZvcm1hdCwgbG9jYWxlLCB0aW1lWm9uZSA9IG51bGwpIHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRzKSxcbiAgICBpbnRsT3B0cyA9IHtcbiAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcIjItZGlnaXRcIixcbiAgICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCJcbiAgICB9O1xuXG4gIGlmICh0aW1lWm9uZSkge1xuICAgIGludGxPcHRzLnRpbWVab25lID0gdGltZVpvbmU7XG4gIH1cblxuICBjb25zdCBtb2RpZmllZCA9IE9iamVjdC5hc3NpZ24oeyB0aW1lWm9uZU5hbWU6IG9mZnNldEZvcm1hdCB9LCBpbnRsT3B0cyksXG4gICAgaW50bCA9IGhhc0ludGwoKTtcblxuICBpZiAoaW50bCAmJiBoYXNGb3JtYXRUb1BhcnRzKCkpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIG1vZGlmaWVkKVxuICAgICAgLmZvcm1hdFRvUGFydHMoZGF0ZSlcbiAgICAgIC5maW5kKG0gPT4gbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IFwidGltZXpvbmVuYW1lXCIpO1xuICAgIHJldHVybiBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBudWxsO1xuICB9IGVsc2UgaWYgKGludGwpIHtcbiAgICAvLyB0aGlzIHByb2JhYmx5IGRvZXNuJ3Qgd29yayBmb3IgYWxsIGxvY2FsZXNcbiAgICBjb25zdCB3aXRob3V0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBpbnRsT3B0cykuZm9ybWF0KGRhdGUpLFxuICAgICAgaW5jbHVkZWQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIG1vZGlmaWVkKS5mb3JtYXQoZGF0ZSksXG4gICAgICBkaWZmZWQgPSBpbmNsdWRlZC5zdWJzdHJpbmcod2l0aG91dC5sZW5ndGgpLFxuICAgICAgdHJpbW1lZCA9IGRpZmZlZC5yZXBsYWNlKC9eWywgXFx1MjAwZV0rLywgXCJcIik7XG4gICAgcmV0dXJuIHRyaW1tZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gc2lnbmVkT2Zmc2V0KCctNScsICczMCcpIC0+IC0zMzBcbmV4cG9ydCBmdW5jdGlvbiBzaWduZWRPZmZzZXQob2ZmSG91clN0ciwgb2ZmTWludXRlU3RyKSB7XG4gIGxldCBvZmZIb3VyID0gcGFyc2VJbnQob2ZmSG91clN0ciwgMTApO1xuXG4gIC8vIGRvbid0IHx8IHRoaXMgYmVjYXVzZSB3ZSB3YW50IHRvIHByZXNlcnZlIC0wXG4gIGlmIChOdW1iZXIuaXNOYU4ob2ZmSG91cikpIHtcbiAgICBvZmZIb3VyID0gMDtcbiAgfVxuXG4gIGNvbnN0IG9mZk1pbiA9IHBhcnNlSW50KG9mZk1pbnV0ZVN0ciwgMTApIHx8IDAsXG4gICAgb2ZmTWluU2lnbmVkID0gb2ZmSG91ciA8IDAgfHwgT2JqZWN0LmlzKG9mZkhvdXIsIC0wKSA/IC1vZmZNaW4gOiBvZmZNaW47XG4gIHJldHVybiBvZmZIb3VyICogNjAgKyBvZmZNaW5TaWduZWQ7XG59XG5cbi8vIENPRVJDSU9OXG5cbmV4cG9ydCBmdW5jdGlvbiBhc051bWJlcih2YWx1ZSkge1xuICBjb25zdCBudW1lcmljVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PT0gXCJcIiB8fCBOdW1iZXIuaXNOYU4obnVtZXJpY1ZhbHVlKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYEludmFsaWQgdW5pdCB2YWx1ZSAke3ZhbHVlfWApO1xuICByZXR1cm4gbnVtZXJpY1ZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplciwgbm9uVW5pdEtleXMpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICBmb3IgKGNvbnN0IHUgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgdSkpIHtcbiAgICAgIGlmIChub25Vbml0S2V5cy5pbmRleE9mKHUpID49IDApIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdiA9IG9ialt1XTtcbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBub3JtYWxpemVkW25vcm1hbGl6ZXIodSldID0gYXNOdW1iZXIodik7XG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0T2Zmc2V0KG9mZnNldCwgZm9ybWF0KSB7XG4gIGNvbnN0IGhvdXJzID0gTWF0aC50cnVuYyhNYXRoLmFicyhvZmZzZXQgLyA2MCkpLFxuICAgIG1pbnV0ZXMgPSBNYXRoLnRydW5jKE1hdGguYWJzKG9mZnNldCAlIDYwKSksXG4gICAgc2lnbiA9IG9mZnNldCA+PSAwID8gXCIrXCIgOiBcIi1cIjtcblxuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtwYWRTdGFydChob3VycywgMil9OiR7cGFkU3RhcnQobWludXRlcywgMil9YDtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke2hvdXJzfSR7bWludXRlcyA+IDAgPyBgOiR7bWludXRlc31gIDogXCJcIn1gO1xuICAgIGNhc2UgXCJ0ZWNoaWVcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7cGFkU3RhcnQoaG91cnMsIDIpfSR7cGFkU3RhcnQobWludXRlcywgMil9YDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFZhbHVlIGZvcm1hdCAke2Zvcm1hdH0gaXMgb3V0IG9mIHJhbmdlIGZvciBwcm9wZXJ0eSBmb3JtYXRgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZU9iamVjdChvYmopIHtcbiAgcmV0dXJuIHBpY2sob2JqLCBbXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0pO1xufVxuXG5leHBvcnQgY29uc3QgaWFuYVJlZ2V4ID0gL1tBLVphLXpfKy1dezEsMjU2fSg6P1xcL1tBLVphLXpfKy1dezEsMjU2fShcXC9bQS1aYS16XystXXsxLDI1Nn0pPyk/LztcbiJdLCJuYW1lcyI6WyJJbnZhbGlkQXJndW1lbnRFcnJvciIsImlzVW5kZWZpbmVkIiwibyIsImlzTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaXNTdHJpbmciLCJpc0RhdGUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJoYXNJbnRsIiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiZSIsImhhc0Zvcm1hdFRvUGFydHMiLCJmb3JtYXRUb1BhcnRzIiwiaGFzUmVsYXRpdmUiLCJSZWxhdGl2ZVRpbWVGb3JtYXQiLCJtYXliZUFycmF5IiwidGhpbmciLCJBcnJheSIsImlzQXJyYXkiLCJiZXN0QnkiLCJhcnIiLCJieSIsImNvbXBhcmUiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJyZWR1Y2UiLCJiZXN0IiwibmV4dCIsInBhaXIiLCJwaWNrIiwib2JqIiwia2V5cyIsImEiLCJrIiwiaGFzT3duUHJvcGVydHkiLCJwcm9wIiwiaW50ZWdlckJldHdlZW4iLCJib3R0b20iLCJ0b3AiLCJmbG9vck1vZCIsIngiLCJuIiwiTWF0aCIsImZsb29yIiwicGFkU3RhcnQiLCJpbnB1dCIsIm1pbnVzIiwidGFyZ2V0IiwicmVzdWx0IiwicmVwZWF0Iiwic2xpY2UiLCJwYXJzZUludGVnZXIiLCJzdHJpbmciLCJwYXJzZUludCIsInBhcnNlTWlsbGlzIiwiZnJhY3Rpb24iLCJmIiwicGFyc2VGbG9hdCIsInJvdW5kVG8iLCJudW1iZXIiLCJkaWdpdHMiLCJ0b3dhcmRaZXJvIiwiZmFjdG9yIiwicm91bmRlciIsInRydW5jIiwicm91bmQiLCJpc0xlYXBZZWFyIiwieWVhciIsImRheXNJblllYXIiLCJkYXlzSW5Nb250aCIsIm1vbnRoIiwibW9kTW9udGgiLCJtb2RZZWFyIiwib2JqVG9Mb2NhbFRTIiwiZCIsIkRhdGUiLCJVVEMiLCJkYXkiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwibWlsbGlzZWNvbmQiLCJzZXRVVENGdWxsWWVhciIsImdldFVUQ0Z1bGxZZWFyIiwid2Vla3NJbldlZWtZZWFyIiwid2Vla1llYXIiLCJwMSIsImxhc3QiLCJwMiIsInVudHJ1bmNhdGVZZWFyIiwicGFyc2Vab25lSW5mbyIsInRzIiwib2Zmc2V0Rm9ybWF0IiwibG9jYWxlIiwidGltZVpvbmUiLCJkYXRlIiwiaW50bE9wdHMiLCJob3VyMTIiLCJtb2RpZmllZCIsImFzc2lnbiIsInRpbWVab25lTmFtZSIsImludGwiLCJwYXJzZWQiLCJmaW5kIiwibSIsInR5cGUiLCJ0b0xvd2VyQ2FzZSIsInZhbHVlIiwid2l0aG91dCIsImZvcm1hdCIsImluY2x1ZGVkIiwiZGlmZmVkIiwic3Vic3RyaW5nIiwidHJpbW1lZCIsInJlcGxhY2UiLCJzaWduZWRPZmZzZXQiLCJvZmZIb3VyU3RyIiwib2ZmTWludXRlU3RyIiwib2ZmSG91ciIsIk51bWJlciIsImlzTmFOIiwib2ZmTWluIiwib2ZmTWluU2lnbmVkIiwiaXMiLCJhc051bWJlciIsIm51bWVyaWNWYWx1ZSIsIm5vcm1hbGl6ZU9iamVjdCIsIm5vcm1hbGl6ZXIiLCJub25Vbml0S2V5cyIsIm5vcm1hbGl6ZWQiLCJ1IiwiaW5kZXhPZiIsInYiLCJmb3JtYXRPZmZzZXQiLCJvZmZzZXQiLCJob3VycyIsImFicyIsIm1pbnV0ZXMiLCJzaWduIiwiUmFuZ2VFcnJvciIsInRpbWVPYmplY3QiLCJpYW5hUmVnZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/impl/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/impl/zoneUtil.js":
/*!*************************************************!*\
  !*** ./node_modules/luxon/src/impl/zoneUtil.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeZone: () => (/* binding */ normalizeZone)\n/* harmony export */ });\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(rsc)/./node_modules/luxon/src/zone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(rsc)/./node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(rsc)/./node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../zones/invalidZone.js */ \"(rsc)/./node_modules/luxon/src/zones/invalidZone.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(rsc)/./node_modules/luxon/src/impl/util.js\");\n/**\n * @private\n */ \n\n\n\n\nfunction normalizeZone(input, defaultZone) {\n    let offset;\n    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(input) || input === null) {\n        return defaultZone;\n    } else if (input instanceof _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n        return input;\n    } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(input)) {\n        const lowered = input.toLowerCase();\n        if (lowered === \"local\") return defaultZone;\n        else if (lowered === \"utc\" || lowered === \"gmt\") return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utcInstance;\n        else if ((offset = _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].parseGMTOffset(input)) != null) {\n            // handle Etc/GMT-4, which V8 chokes on\n            return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instance(offset);\n        } else if (_zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isValidSpecifier(lowered)) return _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(input);\n        else return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].parseSpecifier(lowered) || new _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](input);\n    } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(input)) {\n        return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instance(input);\n    } else if (typeof input === \"object\" && input.offset && typeof input.offset === \"number\") {\n        // This is dumb, but the instanceof check above doesn't seem to really work\n        // so we're duck checking it\n        return input;\n    } else {\n        return new _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](input);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvem9uZVV0aWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FFNkI7QUFDYztBQUNjO0FBQ1I7QUFFVTtBQUVyRCxTQUFTTyxjQUFjQyxLQUFLLEVBQUVDLFdBQVc7SUFDOUMsSUFBSUM7SUFDSixJQUFJTixxREFBV0EsQ0FBQ0ksVUFBVUEsVUFBVSxNQUFNO1FBQ3hDLE9BQU9DO0lBQ1QsT0FBTyxJQUFJRCxpQkFBaUJSLGdEQUFJQSxFQUFFO1FBQ2hDLE9BQU9RO0lBQ1QsT0FBTyxJQUFJSCxrREFBUUEsQ0FBQ0csUUFBUTtRQUMxQixNQUFNRyxVQUFVSCxNQUFNSSxXQUFXO1FBQ2pDLElBQUlELFlBQVksU0FBUyxPQUFPRjthQUMzQixJQUFJRSxZQUFZLFNBQVNBLFlBQVksT0FBTyxPQUFPVCxpRUFBZUEsQ0FBQ1csV0FBVzthQUM5RSxJQUFJLENBQUNILFNBQVNULDBEQUFRQSxDQUFDYSxjQUFjLENBQUNOLE1BQUssS0FBTSxNQUFNO1lBQzFELHVDQUF1QztZQUN2QyxPQUFPTixpRUFBZUEsQ0FBQ2EsUUFBUSxDQUFDTDtRQUNsQyxPQUFPLElBQUlULDBEQUFRQSxDQUFDZSxnQkFBZ0IsQ0FBQ0wsVUFBVSxPQUFPViwwREFBUUEsQ0FBQ2dCLE1BQU0sQ0FBQ1Q7YUFDakUsT0FBT04saUVBQWVBLENBQUNnQixjQUFjLENBQUNQLFlBQVksSUFBSVIsNkRBQVdBLENBQUNLO0lBQ3pFLE9BQU8sSUFBSUYsa0RBQVFBLENBQUNFLFFBQVE7UUFDMUIsT0FBT04saUVBQWVBLENBQUNhLFFBQVEsQ0FBQ1A7SUFDbEMsT0FBTyxJQUFJLE9BQU9BLFVBQVUsWUFBWUEsTUFBTUUsTUFBTSxJQUFJLE9BQU9GLE1BQU1FLE1BQU0sS0FBSyxVQUFVO1FBQ3hGLDJFQUEyRTtRQUMzRSw0QkFBNEI7UUFDNUIsT0FBT0Y7SUFDVCxPQUFPO1FBQ0wsT0FBTyxJQUFJTCw2REFBV0EsQ0FBQ0s7SUFDekI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2lhdG9vbHMtbmV4dC8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC96b25lVXRpbC5qcz85ZDAzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSW52YWxpZFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ludmFsaWRab25lLmpzXCI7XG5cbmltcG9ydCB7IGlzVW5kZWZpbmVkLCBpc1N0cmluZywgaXNOdW1iZXIgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVab25lKGlucHV0LCBkZWZhdWx0Wm9uZSkge1xuICBsZXQgb2Zmc2V0O1xuICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpIHx8IGlucHV0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRab25lO1xuICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgWm9uZSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhpbnB1dCkpIHtcbiAgICBjb25zdCBsb3dlcmVkID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJlZCA9PT0gXCJsb2NhbFwiKSByZXR1cm4gZGVmYXVsdFpvbmU7XG4gICAgZWxzZSBpZiAobG93ZXJlZCA9PT0gXCJ1dGNcIiB8fCBsb3dlcmVkID09PSBcImdtdFwiKSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlO1xuICAgIGVsc2UgaWYgKChvZmZzZXQgPSBJQU5BWm9uZS5wYXJzZUdNVE9mZnNldChpbnB1dCkpICE9IG51bGwpIHtcbiAgICAgIC8vIGhhbmRsZSBFdGMvR01ULTQsIHdoaWNoIFY4IGNob2tlcyBvblxuICAgICAgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShvZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihsb3dlcmVkKSkgcmV0dXJuIElBTkFab25lLmNyZWF0ZShpbnB1dCk7XG4gICAgZWxzZSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKGxvd2VyZWQpIHx8IG5ldyBJbnZhbGlkWm9uZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiICYmIGlucHV0Lm9mZnNldCAmJiB0eXBlb2YgaW5wdXQub2Zmc2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgLy8gVGhpcyBpcyBkdW1iLCBidXQgdGhlIGluc3RhbmNlb2YgY2hlY2sgYWJvdmUgZG9lc24ndCBzZWVtIHRvIHJlYWxseSB3b3JrXG4gICAgLy8gc28gd2UncmUgZHVjayBjaGVja2luZyBpdFxuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEludmFsaWRab25lKGlucHV0KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlpvbmUiLCJJQU5BWm9uZSIsIkZpeGVkT2Zmc2V0Wm9uZSIsIkludmFsaWRab25lIiwiaXNVbmRlZmluZWQiLCJpc1N0cmluZyIsImlzTnVtYmVyIiwibm9ybWFsaXplWm9uZSIsImlucHV0IiwiZGVmYXVsdFpvbmUiLCJvZmZzZXQiLCJsb3dlcmVkIiwidG9Mb3dlckNhc2UiLCJ1dGNJbnN0YW5jZSIsInBhcnNlR01UT2Zmc2V0IiwiaW5zdGFuY2UiLCJpc1ZhbGlkU3BlY2lmaWVyIiwiY3JlYXRlIiwicGFyc2VTcGVjaWZpZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/impl/zoneUtil.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/info.js":
/*!****************************************!*\
  !*** ./node_modules/luxon/src/info.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Info)\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datetime.js */ \"(rsc)/./node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings.js */ \"(rsc)/./node_modules/luxon/src/settings.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/locale.js */ \"(rsc)/./node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(rsc)/./node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(rsc)/./node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ \"(rsc)/./node_modules/luxon/src/impl/util.js\");\n\n\n\n\n\n\n/**\n * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.\n */ class Info {\n    /**\n   * Return whether the specified zone contains a DST.\n   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.\n   * @return {boolean}\n   */ static hasDST(zone = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultZone) {\n        const proto = _datetime_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].now().setZone(zone).set({\n            month: 12\n        });\n        return !zone.universal && proto.offset !== proto.set({\n            month: 6\n        }).offset;\n    }\n    /**\n   * Return whether the specified zone is a valid IANA specifier.\n   * @param {string} zone - Zone to check\n   * @return {boolean}\n   */ static isValidIANAZone(zone) {\n        return _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isValidSpecifier(zone) && _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isValidZone(zone);\n    }\n    /**\n   * Converts the input into a {@link Zone} instance.\n   *\n   * * If `input` is already a Zone instance, it is returned unchanged.\n   * * If `input` is a string containing a valid time zone name, a Zone instance\n   *   with that name is returned.\n   * * If `input` is a string that doesn't refer to a known time zone, a Zone\n   *   instance with {@link Zone.isValid} == false is returned.\n   * * If `input is a number, a Zone instance with the specified fixed offset\n   *   in minutes is returned.\n   * * If `input` is `null` or `undefined`, the default zone is returned.\n   * @param {string|Zone|number} [input] - the value to be converted\n   * @return {Zone}\n   */ static normalizeZone(input) {\n        return (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_3__.normalizeZone)(input, _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultZone);\n    }\n    /**\n   * Return an array of standalone month names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @example Info.months()[0] //=> 'January'\n   * @example Info.months('short')[0] //=> 'Jan'\n   * @example Info.months('numeric')[0] //=> '1'\n   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'\n   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'\n   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'\n   * @return {[string]}\n   */ static months(length = \"long\", { locale = null, numberingSystem = null, locObj = null, outputCalendar = \"gregory\" } = {}) {\n        return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(locale, numberingSystem, outputCalendar)).months(length);\n    }\n    /**\n   * Return an array of format month names.\n   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that\n   * changes the string.\n   * See {@link months}\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @return {[string]}\n   */ static monthsFormat(length = \"long\", { locale = null, numberingSystem = null, locObj = null, outputCalendar = \"gregory\" } = {}) {\n        return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(locale, numberingSystem, outputCalendar)).months(length, true);\n    }\n    /**\n   * Return an array of standalone week names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @example Info.weekdays()[0] //=> 'Monday'\n   * @example Info.weekdays('short')[0] //=> 'Mon'\n   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'\n   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'\n   * @return {[string]}\n   */ static weekdays(length = \"long\", { locale = null, numberingSystem = null, locObj = null } = {}) {\n        return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(locale, numberingSystem, null)).weekdays(length);\n    }\n    /**\n   * Return an array of format week names.\n   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that\n   * changes the string.\n   * See {@link weekdays}\n   * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale=null] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @return {[string]}\n   */ static weekdaysFormat(length = \"long\", { locale = null, numberingSystem = null, locObj = null } = {}) {\n        return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(locale, numberingSystem, null)).weekdays(length, true);\n    }\n    /**\n   * Return an array of meridiems.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.meridiems() //=> [ 'AM', 'PM' ]\n   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]\n   * @return {[string]}\n   */ static meridiems({ locale = null } = {}) {\n        return _impl_locale_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(locale).meridiems();\n    }\n    /**\n   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.\n   * @param {string} [length='short'] - the length of the era representation, such as \"short\" or \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.eras() //=> [ 'BC', 'AD' ]\n   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]\n   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]\n   * @return {[string]}\n   */ static eras(length = \"short\", { locale = null } = {}) {\n        return _impl_locale_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(locale, null, \"gregory\").eras(length);\n    }\n    /**\n   * Return the set of available features in this environment.\n   * Some features of Luxon are not available in all environments. For example, on older browsers, timezone support is not available. Use this function to figure out if that's the case.\n   * Keys:\n   * * `zones`: whether this environment supports IANA timezones\n   * * `intlTokens`: whether this environment supports internationalized token-based formatting/parsing\n   * * `intl`: whether this environment supports general internationalization\n   * * `relative`: whether this environment supports relative time formatting\n   * @example Info.features() //=> { intl: true, intlTokens: false, zones: true, relative: false }\n   * @return {Object}\n   */ static features() {\n        let intl = false, intlTokens = false, zones = false, relative = false;\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasIntl)()) {\n            intl = true;\n            intlTokens = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasFormatToParts)();\n            relative = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasRelative)();\n            try {\n                zones = new Intl.DateTimeFormat(\"en\", {\n                    timeZone: \"America/New_York\"\n                }).resolvedOptions().timeZone === \"America/New_York\";\n            } catch (e) {\n                zones = false;\n            }\n        }\n        return {\n            intl,\n            intlTokens,\n            zones,\n            relative\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2luZm8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFxQztBQUNBO0FBQ0M7QUFDSztBQUNRO0FBRXFCO0FBRXhFOztDQUVDLEdBQ2MsTUFBTVE7SUFDbkI7Ozs7R0FJQyxHQUNELE9BQU9DLE9BQU9DLE9BQU9ULG9EQUFRQSxDQUFDVSxXQUFXLEVBQUU7UUFDekMsTUFBTUMsUUFBUVosb0RBQVFBLENBQUNhLEdBQUcsR0FDdkJDLE9BQU8sQ0FBQ0osTUFDUkssR0FBRyxDQUFDO1lBQUVDLE9BQU87UUFBRztRQUVuQixPQUFPLENBQUNOLEtBQUtPLFNBQVMsSUFBSUwsTUFBTU0sTUFBTSxLQUFLTixNQUFNRyxHQUFHLENBQUM7WUFBRUMsT0FBTztRQUFFLEdBQUdFLE1BQU07SUFDM0U7SUFFQTs7OztHQUlDLEdBQ0QsT0FBT0MsZ0JBQWdCVCxJQUFJLEVBQUU7UUFDM0IsT0FBT1AsMERBQVFBLENBQUNpQixnQkFBZ0IsQ0FBQ1YsU0FBU1AsMERBQVFBLENBQUNrQixXQUFXLENBQUNYO0lBQ2pFO0lBRUE7Ozs7Ozs7Ozs7Ozs7R0FhQyxHQUNELE9BQU9OLGNBQWNrQixLQUFLLEVBQUU7UUFDMUIsT0FBT2xCLGdFQUFhQSxDQUFDa0IsT0FBT3JCLG9EQUFRQSxDQUFDVSxXQUFXO0lBQ2xEO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkMsR0FDRCxPQUFPWSxPQUNMQyxTQUFTLE1BQU0sRUFDZixFQUFFQyxTQUFTLElBQUksRUFBRUMsa0JBQWtCLElBQUksRUFBRUMsU0FBUyxJQUFJLEVBQUVDLGlCQUFpQixTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFDekY7UUFDQSxPQUFPLENBQUNELFVBQVV6Qix1REFBTUEsQ0FBQzJCLE1BQU0sQ0FBQ0osUUFBUUMsaUJBQWlCRSxlQUFjLEVBQUdMLE1BQU0sQ0FBQ0M7SUFDbkY7SUFFQTs7Ozs7Ozs7Ozs7O0dBWUMsR0FDRCxPQUFPTSxhQUNMTixTQUFTLE1BQU0sRUFDZixFQUFFQyxTQUFTLElBQUksRUFBRUMsa0JBQWtCLElBQUksRUFBRUMsU0FBUyxJQUFJLEVBQUVDLGlCQUFpQixTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFDekY7UUFDQSxPQUFPLENBQUNELFVBQVV6Qix1REFBTUEsQ0FBQzJCLE1BQU0sQ0FBQ0osUUFBUUMsaUJBQWlCRSxlQUFjLEVBQUdMLE1BQU0sQ0FBQ0MsUUFBUTtJQUMzRjtJQUVBOzs7Ozs7Ozs7Ozs7O0dBYUMsR0FDRCxPQUFPTyxTQUFTUCxTQUFTLE1BQU0sRUFBRSxFQUFFQyxTQUFTLElBQUksRUFBRUMsa0JBQWtCLElBQUksRUFBRUMsU0FBUyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUM5RixPQUFPLENBQUNBLFVBQVV6Qix1REFBTUEsQ0FBQzJCLE1BQU0sQ0FBQ0osUUFBUUMsaUJBQWlCLEtBQUksRUFBR0ssUUFBUSxDQUFDUDtJQUMzRTtJQUVBOzs7Ozs7Ozs7OztHQVdDLEdBQ0QsT0FBT1EsZUFDTFIsU0FBUyxNQUFNLEVBQ2YsRUFBRUMsU0FBUyxJQUFJLEVBQUVDLGtCQUFrQixJQUFJLEVBQUVDLFNBQVMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQzdEO1FBQ0EsT0FBTyxDQUFDQSxVQUFVekIsdURBQU1BLENBQUMyQixNQUFNLENBQUNKLFFBQVFDLGlCQUFpQixLQUFJLEVBQUdLLFFBQVEsQ0FBQ1AsUUFBUTtJQUNuRjtJQUVBOzs7Ozs7O0dBT0MsR0FDRCxPQUFPUyxVQUFVLEVBQUVSLFNBQVMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDdkMsT0FBT3ZCLHVEQUFNQSxDQUFDMkIsTUFBTSxDQUFDSixRQUFRUSxTQUFTO0lBQ3hDO0lBRUE7Ozs7Ozs7OztHQVNDLEdBQ0QsT0FBT0MsS0FBS1YsU0FBUyxPQUFPLEVBQUUsRUFBRUMsU0FBUyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUNwRCxPQUFPdkIsdURBQU1BLENBQUMyQixNQUFNLENBQUNKLFFBQVEsTUFBTSxXQUFXUyxJQUFJLENBQUNWO0lBQ3JEO0lBRUE7Ozs7Ozs7Ozs7R0FVQyxHQUNELE9BQU9XLFdBQVc7UUFDaEIsSUFBSUMsT0FBTyxPQUNUQyxhQUFhLE9BQ2JDLFFBQVEsT0FDUkMsV0FBVztRQUViLElBQUlqQyxzREFBT0EsSUFBSTtZQUNiOEIsT0FBTztZQUNQQyxhQUFhaEMsK0RBQWdCQTtZQUM3QmtDLFdBQVdoQywwREFBV0E7WUFFdEIsSUFBSTtnQkFDRitCLFFBQ0UsSUFBSUUsS0FBS0MsY0FBYyxDQUFDLE1BQU07b0JBQUVDLFVBQVU7Z0JBQW1CLEdBQUdDLGVBQWUsR0FDNUVELFFBQVEsS0FBSztZQUNwQixFQUFFLE9BQU9FLEdBQUc7Z0JBQ1ZOLFFBQVE7WUFDVjtRQUNGO1FBRUEsT0FBTztZQUFFRjtZQUFNQztZQUFZQztZQUFPQztRQUFTO0lBQzdDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pYXRvb2xzLW5leHQvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2luZm8uanM/NGZmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVab25lIH0gZnJvbSBcIi4vaW1wbC96b25lVXRpbC5qc1wiO1xuXG5pbXBvcnQgeyBoYXNGb3JtYXRUb1BhcnRzLCBoYXNJbnRsLCBoYXNSZWxhdGl2ZSB9IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuXG4vKipcbiAqIFRoZSBJbmZvIGNsYXNzIGNvbnRhaW5zIHN0YXRpYyBtZXRob2RzIGZvciByZXRyaWV2aW5nIGdlbmVyYWwgdGltZSBhbmQgZGF0ZSByZWxhdGVkIGRhdGEuIEZvciBleGFtcGxlLCBpdCBoYXMgbWV0aG9kcyBmb3IgZmluZGluZyBvdXQgaWYgYSB0aW1lIHpvbmUgaGFzIGEgRFNULCBmb3IgbGlzdGluZyB0aGUgbW9udGhzIGluIGFueSBzdXBwb3J0ZWQgbG9jYWxlLCBhbmQgZm9yIGRpc2NvdmVyaW5nIHdoaWNoIG9mIEx1eG9uIGZlYXR1cmVzIGFyZSBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZm8ge1xuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB6b25lIGNvbnRhaW5zIGEgRFNULlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbem9uZT0nbG9jYWwnXSAtIFpvbmUgdG8gY2hlY2suIERlZmF1bHRzIHRvIHRoZSBlbnZpcm9ubWVudCdzIGxvY2FsIHpvbmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaGFzRFNUKHpvbmUgPSBTZXR0aW5ncy5kZWZhdWx0Wm9uZSkge1xuICAgIGNvbnN0IHByb3RvID0gRGF0ZVRpbWUubm93KClcbiAgICAgIC5zZXRab25lKHpvbmUpXG4gICAgICAuc2V0KHsgbW9udGg6IDEyIH0pO1xuXG4gICAgcmV0dXJuICF6b25lLnVuaXZlcnNhbCAmJiBwcm90by5vZmZzZXQgIT09IHByb3RvLnNldCh7IG1vbnRoOiA2IH0pLm9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgaXMgYSB2YWxpZCBJQU5BIHNwZWNpZmllci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBab25lIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZElBTkFab25lKHpvbmUpIHtcbiAgICByZXR1cm4gSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcih6b25lKSAmJiBJQU5BWm9uZS5pc1ZhbGlkWm9uZSh6b25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgaW5wdXQgaW50byBhIHtAbGluayBab25lfSBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBJZiBgaW5wdXRgIGlzIGFscmVhZHkgYSBab25lIGluc3RhbmNlLCBpdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuXG4gICAqICogSWYgYGlucHV0YCBpcyBhIHN0cmluZyBjb250YWluaW5nIGEgdmFsaWQgdGltZSB6b25lIG5hbWUsIGEgWm9uZSBpbnN0YW5jZVxuICAgKiAgIHdpdGggdGhhdCBuYW1lIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgdGhhdCBkb2Vzbid0IHJlZmVyIHRvIGEga25vd24gdGltZSB6b25lLCBhIFpvbmVcbiAgICogICBpbnN0YW5jZSB3aXRoIHtAbGluayBab25lLmlzVmFsaWR9ID09IGZhbHNlIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dCBpcyBhIG51bWJlciwgYSBab25lIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBmaXhlZCBvZmZzZXRcbiAgICogICBpbiBtaW51dGVzIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCB0aGUgZGVmYXVsdCB6b25lIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfG51bWJlcn0gW2lucHV0XSAtIHRoZSB2YWx1ZSB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVab25lKGlucHV0KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSBtb250aCBuYW1lcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJudW1lcmljXCIsIFwiMi1kaWdpdFwiLCBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcj0nZ3JlZ29yeSddIC0gdGhlIGNhbGVuZGFyXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKClbMF0gLy89PiAnSmFudWFyeSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ3Nob3J0JylbMF0gLy89PiAnSmFuJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbnVtZXJpYycpWzBdIC8vPT4gJzEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0gKVswXSAvLz0+ICdqYW52LidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICfZoSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ2xvbmcnLCB7IG91dHB1dENhbGVuZGFyOiAnaXNsYW1pYycgfSlbMF0gLy89PiAnUmFiacq7IEknXG4gICAqIEByZXR1cm4ge1tzdHJpbmddfVxuICAgKi9cbiAgc3RhdGljIG1vbnRocyhcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwsIG91dHB1dENhbGVuZGFyID0gXCJncmVnb3J5XCIgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSkubW9udGhzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZvcm1hdCBtb250aCBuYW1lcy5cbiAgICogRm9ybWF0IG1vbnRocyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIG1vbnRocyBpbiB0aGF0IHRoZXkncmUgbWVhbnQgdG8gYXBwZWFyIG5leHQgdG8gdGhlIGRheSBvZiB0aGUgbW9udGguIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayBtb250aHN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBtb250aCByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm51bWVyaWNcIiwgXCIyLWRpZ2l0XCIsIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyPSdncmVnb3J5J10gLSB0aGUgY2FsZW5kYXJcbiAgICogQHJldHVybiB7W3N0cmluZ119XG4gICAqL1xuICBzdGF0aWMgbW9udGhzRm9ybWF0KFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCwgb3V0cHV0Q2FsZW5kYXIgPSBcImdyZWdvcnlcIiB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpKS5tb250aHMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSB3ZWVrIG5hbWVzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSB3ZWVrZGF5IHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoKVswXSAvLz0+ICdNb25kYXknXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JylbMF0gLy89PiAnTW9uJ1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0pWzBdIC8vPT4gJ2x1bi4nXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JywgeyBsb2NhbGU6ICdhcicgfSlbMF0gLy89PiAn2KfZhNin2KvZhtmK2YYnXG4gICAqIEByZXR1cm4ge1tzdHJpbmddfVxuICAgKi9cbiAgc3RhdGljIHdlZWtkYXlzKGxlbmd0aCA9IFwibG9uZ1wiLCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgbnVsbCkpLndlZWtkYXlzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZvcm1hdCB3ZWVrIG5hbWVzLlxuICAgKiBGb3JtYXQgd2Vla2RheXMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSB3ZWVrZGF5cyBpbiB0aGF0IHRoZXkncmUgbWVhbnQgdG8gYXBwZWFyIG5leHQgdG8gbW9yZSBkYXRlIGluZm9ybWF0aW9uLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgd2Vla2RheXN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSB3ZWVrZGF5IHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPW51bGxdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHJldHVybiB7W3N0cmluZ119XG4gICAqL1xuICBzdGF0aWMgd2Vla2RheXNGb3JtYXQoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKSkud2Vla2RheXMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgbWVyaWRpZW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoKSAvLz0+IFsgJ0FNJywgJ1BNJyBdXG4gICAqIEBleGFtcGxlIEluZm8ubWVyaWRpZW1zKHsgbG9jYWxlOiAnbXknIH0pIC8vPT4gWyAn4YCU4YC24YCU4YCA4YC6JywgJ+GAiuGAlOGAsScgXVxuICAgKiBAcmV0dXJuIHtbc3RyaW5nXX1cbiAgICovXG4gIHN0YXRpYyBtZXJpZGllbXMoeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSkubWVyaWRpZW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGVyYXMsIHN1Y2ggYXMgWydCQycsICdBRCddLiBUaGUgbG9jYWxlIGNhbiBiZSBzcGVjaWZpZWQsIGJ1dCB0aGUgY2FsZW5kYXIgc3lzdGVtIGlzIGFsd2F5cyBHcmVnb3JpYW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdzaG9ydCddIC0gdGhlIGxlbmd0aCBvZiB0aGUgZXJhIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwic2hvcnRcIiBvciBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygpIC8vPT4gWyAnQkMnLCAnQUQnIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJykgLy89PiBbICdCZWZvcmUgQ2hyaXN0JywgJ0Fubm8gRG9taW5pJyBdXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygnbG9uZycsIHsgbG9jYWxlOiAnZnInIH0pIC8vPT4gWyAnYXZhbnQgSsOpc3VzLUNocmlzdCcsICdhcHLDqHMgSsOpc3VzLUNocmlzdCcgXVxuICAgKiBAcmV0dXJuIHtbc3RyaW5nXX1cbiAgICovXG4gIHN0YXRpYyBlcmFzKGxlbmd0aCA9IFwic2hvcnRcIiwgeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVsbCwgXCJncmVnb3J5XCIpLmVyYXMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHNldCBvZiBhdmFpbGFibGUgZmVhdHVyZXMgaW4gdGhpcyBlbnZpcm9ubWVudC5cbiAgICogU29tZSBmZWF0dXJlcyBvZiBMdXhvbiBhcmUgbm90IGF2YWlsYWJsZSBpbiBhbGwgZW52aXJvbm1lbnRzLiBGb3IgZXhhbXBsZSwgb24gb2xkZXIgYnJvd3NlcnMsIHRpbWV6b25lIHN1cHBvcnQgaXMgbm90IGF2YWlsYWJsZS4gVXNlIHRoaXMgZnVuY3Rpb24gdG8gZmlndXJlIG91dCBpZiB0aGF0J3MgdGhlIGNhc2UuXG4gICAqIEtleXM6XG4gICAqICogYHpvbmVzYDogd2hldGhlciB0aGlzIGVudmlyb25tZW50IHN1cHBvcnRzIElBTkEgdGltZXpvbmVzXG4gICAqICogYGludGxUb2tlbnNgOiB3aGV0aGVyIHRoaXMgZW52aXJvbm1lbnQgc3VwcG9ydHMgaW50ZXJuYXRpb25hbGl6ZWQgdG9rZW4tYmFzZWQgZm9ybWF0dGluZy9wYXJzaW5nXG4gICAqICogYGludGxgOiB3aGV0aGVyIHRoaXMgZW52aXJvbm1lbnQgc3VwcG9ydHMgZ2VuZXJhbCBpbnRlcm5hdGlvbmFsaXphdGlvblxuICAgKiAqIGByZWxhdGl2ZWA6IHdoZXRoZXIgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0cyByZWxhdGl2ZSB0aW1lIGZvcm1hdHRpbmdcbiAgICogQGV4YW1wbGUgSW5mby5mZWF0dXJlcygpIC8vPT4geyBpbnRsOiB0cnVlLCBpbnRsVG9rZW5zOiBmYWxzZSwgem9uZXM6IHRydWUsIHJlbGF0aXZlOiBmYWxzZSB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmZWF0dXJlcygpIHtcbiAgICBsZXQgaW50bCA9IGZhbHNlLFxuICAgICAgaW50bFRva2VucyA9IGZhbHNlLFxuICAgICAgem9uZXMgPSBmYWxzZSxcbiAgICAgIHJlbGF0aXZlID0gZmFsc2U7XG5cbiAgICBpZiAoaGFzSW50bCgpKSB7XG4gICAgICBpbnRsID0gdHJ1ZTtcbiAgICAgIGludGxUb2tlbnMgPSBoYXNGb3JtYXRUb1BhcnRzKCk7XG4gICAgICByZWxhdGl2ZSA9IGhhc1JlbGF0aXZlKCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHpvbmVzID1cbiAgICAgICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuXCIsIHsgdGltZVpvbmU6IFwiQW1lcmljYS9OZXdfWW9ya1wiIH0pLnJlc29sdmVkT3B0aW9ucygpXG4gICAgICAgICAgICAudGltZVpvbmUgPT09IFwiQW1lcmljYS9OZXdfWW9ya1wiO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB6b25lcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGludGwsIGludGxUb2tlbnMsIHpvbmVzLCByZWxhdGl2ZSB9O1xuICB9XG59XG4iXSwibmFtZXMiOlsiRGF0ZVRpbWUiLCJTZXR0aW5ncyIsIkxvY2FsZSIsIklBTkFab25lIiwibm9ybWFsaXplWm9uZSIsImhhc0Zvcm1hdFRvUGFydHMiLCJoYXNJbnRsIiwiaGFzUmVsYXRpdmUiLCJJbmZvIiwiaGFzRFNUIiwiem9uZSIsImRlZmF1bHRab25lIiwicHJvdG8iLCJub3ciLCJzZXRab25lIiwic2V0IiwibW9udGgiLCJ1bml2ZXJzYWwiLCJvZmZzZXQiLCJpc1ZhbGlkSUFOQVpvbmUiLCJpc1ZhbGlkU3BlY2lmaWVyIiwiaXNWYWxpZFpvbmUiLCJpbnB1dCIsIm1vbnRocyIsImxlbmd0aCIsImxvY2FsZSIsIm51bWJlcmluZ1N5c3RlbSIsImxvY09iaiIsIm91dHB1dENhbGVuZGFyIiwiY3JlYXRlIiwibW9udGhzRm9ybWF0Iiwid2Vla2RheXMiLCJ3ZWVrZGF5c0Zvcm1hdCIsIm1lcmlkaWVtcyIsImVyYXMiLCJmZWF0dXJlcyIsImludGwiLCJpbnRsVG9rZW5zIiwiem9uZXMiLCJyZWxhdGl2ZSIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsInRpbWVab25lIiwicmVzb2x2ZWRPcHRpb25zIiwiZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/info.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/interval.js":
/*!********************************************!*\
  !*** ./node_modules/luxon/src/interval.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Interval)\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./datetime.js */ \"(rsc)/./node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./duration.js */ \"(rsc)/./node_modules/luxon/src/duration.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings.js */ \"(rsc)/./node_modules/luxon/src/settings.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./impl/invalid.js */ \"(rsc)/./node_modules/luxon/src/impl/invalid.js\");\n\n\n\n\n\nconst INVALID = \"Invalid Interval\";\n// checks if the start is equal to or before the end\nfunction validateStartEnd(start, end) {\n    if (!start || !start.isValid) {\n        return Interval.invalid(\"missing or invalid start\");\n    } else if (!end || !end.isValid) {\n        return Interval.invalid(\"missing or invalid end\");\n    } else if (end < start) {\n        return Interval.invalid(\"end before start\", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);\n    } else {\n        return null;\n    }\n}\n/**\n * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.\n *\n * Here is a brief overview of the most commonly used methods and getters in Interval:\n *\n * * **Creation** To create an Interval, use {@link fromDateTimes}, {@link after}, {@link before}, or {@link fromISO}.\n * * **Accessors** Use {@link start} and {@link end} to get the start and end.\n * * **Interrogation** To analyze the Interval, use {@link count}, {@link length}, {@link hasSame}, {@link contains}, {@link isAfter}, or {@link isBefore}.\n * * **Transformation** To create other Intervals out of this one, use {@link set}, {@link splitAt}, {@link splitBy}, {@link divideEqually}, {@link merge}, {@link xor}, {@link union}, {@link intersection}, or {@link difference}.\n * * **Comparison** To compare this Interval to another one, use {@link equals}, {@link overlaps}, {@link abutsStart}, {@link abutsEnd}, {@link engulfs}.\n * * **Output** To convert the Interval into other representations, see {@link toString}, {@link toISO}, {@link toISODate}, {@link toISOTime}, {@link toFormat}, and {@link toDuration}.\n */ class Interval {\n    /**\n   * @private\n   */ constructor(config){\n        /**\n     * @access private\n     */ this.s = config.start;\n        /**\n     * @access private\n     */ this.e = config.end;\n        /**\n     * @access private\n     */ this.invalid = config.invalid || null;\n        /**\n     * @access private\n     */ this.isLuxonInterval = true;\n    }\n    /**\n   * Create an invalid Interval.\n   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {Interval}\n   */ static invalid(reason, explanation = null) {\n        if (!reason) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\"need to specify a reason the Interval is invalid\");\n        }\n        const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](reason, explanation);\n        if (_settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].throwOnInvalid) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidIntervalError(invalid);\n        } else {\n            return new Interval({\n                invalid\n            });\n        }\n    }\n    /**\n   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.\n   * @param {DateTime|Date|Object} start\n   * @param {DateTime|Date|Object} end\n   * @return {Interval}\n   */ static fromDateTimes(start, end) {\n        const builtStart = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_3__.friendlyDateTime)(start), builtEnd = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_3__.friendlyDateTime)(end);\n        const validateError = validateStartEnd(builtStart, builtEnd);\n        if (validateError == null) {\n            return new Interval({\n                start: builtStart,\n                end: builtEnd\n            });\n        } else {\n            return validateError;\n        }\n    }\n    /**\n   * Create an Interval from a start DateTime and a Duration to extend to.\n   * @param {DateTime|Date|Object} start\n   * @param {Duration|Object|number} duration - the length of the Interval.\n   * @return {Interval}\n   */ static after(start, duration) {\n        const dur = (0,_duration_js__WEBPACK_IMPORTED_MODULE_4__.friendlyDuration)(duration), dt = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_3__.friendlyDateTime)(start);\n        return Interval.fromDateTimes(dt, dt.plus(dur));\n    }\n    /**\n   * Create an Interval from an end DateTime and a Duration to extend backwards to.\n   * @param {DateTime|Date|Object} end\n   * @param {Duration|Object|number} duration - the length of the Interval.\n   * @return {Interval}\n   */ static before(end, duration) {\n        const dur = (0,_duration_js__WEBPACK_IMPORTED_MODULE_4__.friendlyDuration)(duration), dt = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_3__.friendlyDateTime)(end);\n        return Interval.fromDateTimes(dt.minus(dur), dt);\n    }\n    /**\n   * Create an Interval from an ISO 8601 string.\n   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.\n   * @param {string} text - the ISO string to parse\n   * @param {Object} [opts] - options to pass {@link DateTime.fromISO} and optionally {@link Duration.fromISO}\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @return {Interval}\n   */ static fromISO(text, opts) {\n        const [s, e] = (text || \"\").split(\"/\", 2);\n        if (s && e) {\n            let start, startIsValid;\n            try {\n                start = _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromISO(s, opts);\n                startIsValid = start.isValid;\n            } catch (e) {\n                startIsValid = false;\n            }\n            let end, endIsValid;\n            try {\n                end = _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromISO(e, opts);\n                endIsValid = end.isValid;\n            } catch (e) {\n                endIsValid = false;\n            }\n            if (startIsValid && endIsValid) {\n                return Interval.fromDateTimes(start, end);\n            }\n            if (startIsValid) {\n                const dur = _duration_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fromISO(e, opts);\n                if (dur.isValid) {\n                    return Interval.after(start, dur);\n                }\n            } else if (endIsValid) {\n                const dur = _duration_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fromISO(s, opts);\n                if (dur.isValid) {\n                    return Interval.before(end, dur);\n                }\n            }\n        }\n        return Interval.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n    }\n    /**\n   * Check if an object is an Interval. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */ static isInterval(o) {\n        return o && o.isLuxonInterval || false;\n    }\n    /**\n   * Returns the start of the Interval\n   * @type {DateTime}\n   */ get start() {\n        return this.isValid ? this.s : null;\n    }\n    /**\n   * Returns the end of the Interval\n   * @type {DateTime}\n   */ get end() {\n        return this.isValid ? this.e : null;\n    }\n    /**\n   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.\n   * @type {boolean}\n   */ get isValid() {\n        return this.invalidReason === null;\n    }\n    /**\n   * Returns an error code if this Interval is invalid, or null if the Interval is valid\n   * @type {string}\n   */ get invalidReason() {\n        return this.invalid ? this.invalid.reason : null;\n    }\n    /**\n   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid\n   * @type {string}\n   */ get invalidExplanation() {\n        return this.invalid ? this.invalid.explanation : null;\n    }\n    /**\n   * Returns the length of the Interval in the specified unit.\n   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.\n   * @return {number}\n   */ length(unit = \"milliseconds\") {\n        return this.isValid ? this.toDuration(...[\n            unit\n        ]).get(unit) : NaN;\n    }\n    /**\n   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.\n   * Unlike {@link length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'\n   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'\n   * @param {string} [unit='milliseconds'] - the unit of time to count.\n   * @return {number}\n   */ count(unit = \"milliseconds\") {\n        if (!this.isValid) return NaN;\n        const start = this.start.startOf(unit), end = this.end.startOf(unit);\n        return Math.floor(end.diff(start, unit).get(unit)) + 1;\n    }\n    /**\n   * Returns whether this Interval's start and end are both in the same unit of time\n   * @param {string} unit - the unit of time to check sameness on\n   * @return {boolean}\n   */ hasSame(unit) {\n        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;\n    }\n    /**\n   * Return whether this Interval has the same start and end DateTimes.\n   * @return {boolean}\n   */ isEmpty() {\n        return this.s.valueOf() === this.e.valueOf();\n    }\n    /**\n   * Return whether this Interval's start is after the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */ isAfter(dateTime) {\n        if (!this.isValid) return false;\n        return this.s > dateTime;\n    }\n    /**\n   * Return whether this Interval's end is before the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */ isBefore(dateTime) {\n        if (!this.isValid) return false;\n        return this.e <= dateTime;\n    }\n    /**\n   * Return whether this Interval contains the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */ contains(dateTime) {\n        if (!this.isValid) return false;\n        return this.s <= dateTime && this.e > dateTime;\n    }\n    /**\n   * \"Sets\" the start and/or end dates. Returns a newly-constructed Interval.\n   * @param {Object} values - the values to set\n   * @param {DateTime} values.start - the starting DateTime\n   * @param {DateTime} values.end - the ending DateTime\n   * @return {Interval}\n   */ set({ start, end } = {}) {\n        if (!this.isValid) return this;\n        return Interval.fromDateTimes(start || this.s, end || this.e);\n    }\n    /**\n   * Split this Interval at each of the specified DateTimes\n   * @param {...[DateTime]} dateTimes - the unit of time to count.\n   * @return {[Interval]}\n   */ splitAt(...dateTimes) {\n        if (!this.isValid) return [];\n        const sorted = dateTimes.map(_datetime_js__WEBPACK_IMPORTED_MODULE_3__.friendlyDateTime).filter((d)=>this.contains(d)).sort(), results = [];\n        let { s } = this, i = 0;\n        while(s < this.e){\n            const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;\n            results.push(Interval.fromDateTimes(s, next));\n            s = next;\n            i += 1;\n        }\n        return results;\n    }\n    /**\n   * Split this Interval into smaller Intervals, each of the specified length.\n   * Left over time is grouped into a smaller interval\n   * @param {Duration|Object|number} duration - The length of each resulting interval.\n   * @return {[Interval]}\n   */ splitBy(duration) {\n        const dur = (0,_duration_js__WEBPACK_IMPORTED_MODULE_4__.friendlyDuration)(duration);\n        if (!this.isValid || !dur.isValid || dur.as(\"milliseconds\") === 0) {\n            return [];\n        }\n        let { s } = this, idx = 1, next;\n        const results = [];\n        while(s < this.e){\n            const added = this.start.plus(dur.mapUnits((x)=>x * idx));\n            next = +added > +this.e ? this.e : added;\n            results.push(Interval.fromDateTimes(s, next));\n            s = next;\n            idx += 1;\n        }\n        return results;\n    }\n    /**\n   * Split this Interval into the specified number of smaller intervals.\n   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.\n   * @return {[Interval]}\n   */ divideEqually(numberOfParts) {\n        if (!this.isValid) return [];\n        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);\n    }\n    /**\n   * Return whether this Interval overlaps with the specified Interval\n   * @param {Interval} other\n   * @return {boolean}\n   */ overlaps(other) {\n        return this.e > other.s && this.s < other.e;\n    }\n    /**\n   * Return whether this Interval's end is adjacent to the specified Interval's start.\n   * @param {Interval} other\n   * @return {boolean}\n   */ abutsStart(other) {\n        if (!this.isValid) return false;\n        return +this.e === +other.s;\n    }\n    /**\n   * Return whether this Interval's start is adjacent to the specified Interval's end.\n   * @param {Interval} other\n   * @return {boolean}\n   */ abutsEnd(other) {\n        if (!this.isValid) return false;\n        return +other.e === +this.s;\n    }\n    /**\n   * Return whether this Interval engulfs the start and end of the specified Interval.\n   * @param {Interval} other\n   * @return {boolean}\n   */ engulfs(other) {\n        if (!this.isValid) return false;\n        return this.s <= other.s && this.e >= other.e;\n    }\n    /**\n   * Return whether this Interval has the same start and end as the specified Interval.\n   * @param {Interval} other\n   * @return {boolean}\n   */ equals(other) {\n        if (!this.isValid || !other.isValid) {\n            return false;\n        }\n        return this.s.equals(other.s) && this.e.equals(other.e);\n    }\n    /**\n   * Return an Interval representing the intersection of this Interval and the specified Interval.\n   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.\n   * Returns null if the intersection is empty, meaning, the intervals don't intersect.\n   * @param {Interval} other\n   * @return {Interval}\n   */ intersection(other) {\n        if (!this.isValid) return this;\n        const s = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;\n        if (s >= e) {\n            return null;\n        } else {\n            return Interval.fromDateTimes(s, e);\n        }\n    }\n    /**\n   * Return an Interval representing the union of this Interval and the specified Interval.\n   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.\n   * @param {Interval} other\n   * @return {Interval}\n   */ union(other) {\n        if (!this.isValid) return this;\n        const s = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;\n        return Interval.fromDateTimes(s, e);\n    }\n    /**\n   * Merge an array of Intervals into a equivalent minimal set of Intervals.\n   * Combines overlapping and adjacent Intervals.\n   * @param {[Interval]} intervals\n   * @return {[Interval]}\n   */ static merge(intervals) {\n        const [found, final] = intervals.sort((a, b)=>a.s - b.s).reduce(([sofar, current], item)=>{\n            if (!current) {\n                return [\n                    sofar,\n                    item\n                ];\n            } else if (current.overlaps(item) || current.abutsStart(item)) {\n                return [\n                    sofar,\n                    current.union(item)\n                ];\n            } else {\n                return [\n                    sofar.concat([\n                        current\n                    ]),\n                    item\n                ];\n            }\n        }, [\n            [],\n            null\n        ]);\n        if (final) {\n            found.push(final);\n        }\n        return found;\n    }\n    /**\n   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.\n   * @param {[Interval]} intervals\n   * @return {[Interval]}\n   */ static xor(intervals) {\n        let start = null, currentCount = 0;\n        const results = [], ends = intervals.map((i)=>[\n                {\n                    time: i.s,\n                    type: \"s\"\n                },\n                {\n                    time: i.e,\n                    type: \"e\"\n                }\n            ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b)=>a.time - b.time);\n        for (const i of arr){\n            currentCount += i.type === \"s\" ? 1 : -1;\n            if (currentCount === 1) {\n                start = i.time;\n            } else {\n                if (start && +start !== +i.time) {\n                    results.push(Interval.fromDateTimes(start, i.time));\n                }\n                start = null;\n            }\n        }\n        return Interval.merge(results);\n    }\n    /**\n   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.\n   * @param {...Interval} intervals\n   * @return {[Interval]}\n   */ difference(...intervals) {\n        return Interval.xor([\n            this\n        ].concat(intervals)).map((i)=>this.intersection(i)).filter((i)=>i && !i.isEmpty());\n    }\n    /**\n   * Returns a string representation of this Interval appropriate for debugging.\n   * @return {string}\n   */ toString() {\n        if (!this.isValid) return INVALID;\n        return `[${this.s.toISO()} – ${this.e.toISO()})`;\n    }\n    /**\n   * Returns an ISO 8601-compliant string representation of this Interval.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @param {Object} opts - The same options as {@link DateTime.toISO}\n   * @return {string}\n   */ toISO(opts) {\n        if (!this.isValid) return INVALID;\n        return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;\n    }\n    /**\n   * Returns an ISO 8601-compliant string representation of date of this Interval.\n   * The time components are ignored.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @return {string}\n   */ toISODate() {\n        if (!this.isValid) return INVALID;\n        return `${this.s.toISODate()}/${this.e.toISODate()}`;\n    }\n    /**\n   * Returns an ISO 8601-compliant string representation of time of this Interval.\n   * The date components are ignored.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @param {Object} opts - The same options as {@link DateTime.toISO}\n   * @return {string}\n   */ toISOTime(opts) {\n        if (!this.isValid) return INVALID;\n        return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;\n    }\n    /**\n   * Returns a string representation of this Interval formatted according to the specified format string.\n   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime.toFormat} for details.\n   * @param {Object} opts - options\n   * @param {string} [opts.separator =  ' – '] - a separator to place between the start and end representations\n   * @return {string}\n   */ toFormat(dateFormat, { separator = \" – \" } = {}) {\n        if (!this.isValid) return INVALID;\n        return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;\n    }\n    /**\n   * Return a Duration representing the time spanned by this interval.\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }\n   * @return {Duration}\n   */ toDuration(unit, opts) {\n        if (!this.isValid) {\n            return _duration_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].invalid(this.invalidReason);\n        }\n        return this.e.diff(this.s, unit, opts);\n    }\n    /**\n   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes\n   * @param {function} mapFn\n   * @return {Interval}\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))\n   */ mapEndpoints(mapFn) {\n        return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ludGVydmFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEyRDtBQUNBO0FBQ3RCO0FBQ29DO0FBQ2pDO0FBRXhDLE1BQU1RLFVBQVU7QUFFaEIsb0RBQW9EO0FBQ3BELFNBQVNDLGlCQUFpQkMsS0FBSyxFQUFFQyxHQUFHO0lBQ2xDLElBQUksQ0FBQ0QsU0FBUyxDQUFDQSxNQUFNRSxPQUFPLEVBQUU7UUFDNUIsT0FBT0MsU0FBU0MsT0FBTyxDQUFDO0lBQzFCLE9BQU8sSUFBSSxDQUFDSCxPQUFPLENBQUNBLElBQUlDLE9BQU8sRUFBRTtRQUMvQixPQUFPQyxTQUFTQyxPQUFPLENBQUM7SUFDMUIsT0FBTyxJQUFJSCxNQUFNRCxPQUFPO1FBQ3RCLE9BQU9HLFNBQVNDLE9BQU8sQ0FDckIsb0JBQ0EsQ0FBQyxrRUFBa0UsRUFBRUosTUFBTUssS0FBSyxHQUFHLFNBQVMsRUFBRUosSUFBSUksS0FBSyxHQUFHLENBQUM7SUFFL0csT0FBTztRQUNMLE9BQU87SUFDVDtBQUNGO0FBRUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDYyxNQUFNRjtJQUNuQjs7R0FFQyxHQUNERyxZQUFZQyxNQUFNLENBQUU7UUFDbEI7O0tBRUMsR0FDRCxJQUFJLENBQUNDLENBQUMsR0FBR0QsT0FBT1AsS0FBSztRQUNyQjs7S0FFQyxHQUNELElBQUksQ0FBQ1MsQ0FBQyxHQUFHRixPQUFPTixHQUFHO1FBQ25COztLQUVDLEdBQ0QsSUFBSSxDQUFDRyxPQUFPLEdBQUdHLE9BQU9ILE9BQU8sSUFBSTtRQUNqQzs7S0FFQyxHQUNELElBQUksQ0FBQ00sZUFBZSxHQUFHO0lBQ3pCO0lBRUE7Ozs7O0dBS0MsR0FDRCxPQUFPTixRQUFRTyxNQUFNLEVBQUVDLGNBQWMsSUFBSSxFQUFFO1FBQ3pDLElBQUksQ0FBQ0QsUUFBUTtZQUNYLE1BQU0sSUFBSWhCLDREQUFvQkEsQ0FBQztRQUNqQztRQUVBLE1BQU1TLFVBQVVPLGtCQUFrQmQsd0RBQU9B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bGVzL2x1eG9uL3NyYy9pbnRlcnZhbC5qcz85OGJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEYXRlVGltZSwgeyBmcmllbmRseURhdGVUaW1lIH0gZnJvbSBcIi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBEdXJhdGlvbiwgeyBmcmllbmRseUR1cmF0aW9uIH0gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWRJbnRlcnZhbEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcblxuY29uc3QgSU5WQUxJRCA9IFwiSW52YWxpZCBJbnRlcnZhbFwiO1xuXG4vLyBjaGVja3MgaWYgdGhlIHN0YXJ0IGlzIGVxdWFsIHRvIG9yIGJlZm9yZSB0aGUgZW5kXG5mdW5jdGlvbiB2YWxpZGF0ZVN0YXJ0RW5kKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCB8fCAhc3RhcnQuaXNWYWxpZCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwibWlzc2luZyBvciBpbnZhbGlkIHN0YXJ0XCIpO1xuICB9IGVsc2UgaWYgKCFlbmQgfHwgIWVuZC5pc1ZhbGlkKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kXCIpO1xuICB9IGVsc2UgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXG4gICAgICBcImVuZCBiZWZvcmUgc3RhcnRcIixcbiAgICAgIGBUaGUgZW5kIG9mIGFuIGludGVydmFsIG11c3QgYmUgYWZ0ZXIgaXRzIHN0YXJ0LCBidXQgeW91IGhhZCBzdGFydD0ke3N0YXJ0LnRvSVNPKCl9IGFuZCBlbmQ9JHtlbmQudG9JU08oKX1gXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEFuIEludGVydmFsIG9iamVjdCByZXByZXNlbnRzIGEgaGFsZi1vcGVuIGludGVydmFsIG9mIHRpbWUsIHdoZXJlIGVhY2ggZW5kcG9pbnQgaXMgYSB7QGxpbmsgRGF0ZVRpbWV9LiBDb25jZXB0dWFsbHksIGl0J3MgYSBjb250YWluZXIgZm9yIHRob3NlIHR3byBlbmRwb2ludHMsIGFjY29tcGFuaWVkIGJ5IG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCBjb21wYXJpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBtZXRob2RzIGFuZCBnZXR0ZXJzIGluIEludGVydmFsOlxuICpcbiAqICogKipDcmVhdGlvbioqIFRvIGNyZWF0ZSBhbiBJbnRlcnZhbCwgdXNlIHtAbGluayBmcm9tRGF0ZVRpbWVzfSwge0BsaW5rIGFmdGVyfSwge0BsaW5rIGJlZm9yZX0sIG9yIHtAbGluayBmcm9tSVNPfS5cbiAqICogKipBY2Nlc3NvcnMqKiBVc2Uge0BsaW5rIHN0YXJ0fSBhbmQge0BsaW5rIGVuZH0gdG8gZ2V0IHRoZSBzdGFydCBhbmQgZW5kLlxuICogKiAqKkludGVycm9nYXRpb24qKiBUbyBhbmFseXplIHRoZSBJbnRlcnZhbCwgdXNlIHtAbGluayBjb3VudH0sIHtAbGluayBsZW5ndGh9LCB7QGxpbmsgaGFzU2FtZX0sIHtAbGluayBjb250YWluc30sIHtAbGluayBpc0FmdGVyfSwgb3Ige0BsaW5rIGlzQmVmb3JlfS5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqIFRvIGNyZWF0ZSBvdGhlciBJbnRlcnZhbHMgb3V0IG9mIHRoaXMgb25lLCB1c2Uge0BsaW5rIHNldH0sIHtAbGluayBzcGxpdEF0fSwge0BsaW5rIHNwbGl0Qnl9LCB7QGxpbmsgZGl2aWRlRXF1YWxseX0sIHtAbGluayBtZXJnZX0sIHtAbGluayB4b3J9LCB7QGxpbmsgdW5pb259LCB7QGxpbmsgaW50ZXJzZWN0aW9ufSwgb3Ige0BsaW5rIGRpZmZlcmVuY2V9LlxuICogKiAqKkNvbXBhcmlzb24qKiBUbyBjb21wYXJlIHRoaXMgSW50ZXJ2YWwgdG8gYW5vdGhlciBvbmUsIHVzZSB7QGxpbmsgZXF1YWxzfSwge0BsaW5rIG92ZXJsYXBzfSwge0BsaW5rIGFidXRzU3RhcnR9LCB7QGxpbmsgYWJ1dHNFbmR9LCB7QGxpbmsgZW5ndWxmc30uXG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgSW50ZXJ2YWwgaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgdG9TdHJpbmd9LCB7QGxpbmsgdG9JU099LCB7QGxpbmsgdG9JU09EYXRlfSwge0BsaW5rIHRvSVNPVGltZX0sIHtAbGluayB0b0Zvcm1hdH0sIGFuZCB7QGxpbmsgdG9EdXJhdGlvbn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVydmFsIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnMgPSBjb25maWcuc3RhcnQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lID0gY29uZmlnLmVuZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBjb25maWcuaW52YWxpZCB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkludGVydmFsID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBJbnRlcnZhbCBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSW50ZXJ2YWxFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGEgc3RhcnQgRGF0ZVRpbWUgYW5kIGFuIGVuZCBEYXRlVGltZS4gSW5jbHVzaXZlIG9mIHRoZSBzdGFydCBidXQgbm90IHRoZSBlbmQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0ZVRpbWVzKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBidWlsdFN0YXJ0ID0gZnJpZW5kbHlEYXRlVGltZShzdGFydCksXG4gICAgICBidWlsdEVuZCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcblxuICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSB2YWxpZGF0ZVN0YXJ0RW5kKGJ1aWx0U3RhcnQsIGJ1aWx0RW5kKTtcblxuICAgIGlmICh2YWxpZGF0ZUVycm9yID09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoe1xuICAgICAgICBzdGFydDogYnVpbHRTdGFydCxcbiAgICAgICAgZW5kOiBidWlsdEVuZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZUVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhIHN0YXJ0IERhdGVUaW1lIGFuZCBhIER1cmF0aW9uIHRvIGV4dGVuZCB0by5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gc3RhcnRcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsLlxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBhZnRlcihzdGFydCwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBmcmllbmRseUR1cmF0aW9uKGR1cmF0aW9uKSxcbiAgICAgIGR0ID0gZnJpZW5kbHlEYXRlVGltZShzdGFydCk7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQsIGR0LnBsdXMoZHVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYW4gZW5kIERhdGVUaW1lIGFuZCBhIER1cmF0aW9uIHRvIGV4dGVuZCBiYWNrd2FyZHMgdG8uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGJlZm9yZShlbmQsIGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gZnJpZW5kbHlEdXJhdGlvbihkdXJhdGlvbiksXG4gICAgICBkdCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdC5taW51cyhkdXIpLCBkdCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYW4gSVNPIDg2MDEgc3RyaW5nLlxuICAgKiBBY2NlcHRzIGA8c3RhcnQ+LzxlbmQ+YCwgYDxzdGFydD4vPGR1cmF0aW9uPmAsIGFuZCBgPGR1cmF0aW9uPi88ZW5kPmAgZm9ybWF0cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSVNPIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gb3B0aW9ucyB0byBwYXNzIHtAbGluayBEYXRlVGltZS5mcm9tSVNPfSBhbmQgb3B0aW9uYWxseSB7QGxpbmsgRHVyYXRpb24uZnJvbUlTT31cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcywgZV0gPSAodGV4dCB8fCBcIlwiKS5zcGxpdChcIi9cIiwgMik7XG4gICAgaWYgKHMgJiYgZSkge1xuICAgICAgbGV0IHN0YXJ0LCBzdGFydElzVmFsaWQ7XG4gICAgICB0cnkge1xuICAgICAgICBzdGFydCA9IERhdGVUaW1lLmZyb21JU08ocywgb3B0cyk7XG4gICAgICAgIHN0YXJ0SXNWYWxpZCA9IHN0YXJ0LmlzVmFsaWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN0YXJ0SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsZXQgZW5kLCBlbmRJc1ZhbGlkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZW5kID0gRGF0ZVRpbWUuZnJvbUlTTyhlLCBvcHRzKTtcbiAgICAgICAgZW5kSXNWYWxpZCA9IGVuZC5pc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlbmRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydElzVmFsaWQgJiYgZW5kSXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCwgZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0SXNWYWxpZCkge1xuICAgICAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tSVNPKGUsIG9wdHMpO1xuICAgICAgICBpZiAoZHVyLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gSW50ZXJ2YWwuYWZ0ZXIoc3RhcnQsIGR1cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kSXNWYWxpZCkge1xuICAgICAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tSVNPKHMsIG9wdHMpO1xuICAgICAgICBpZiAoZHVyLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gSW50ZXJ2YWwuYmVmb3JlKGVuZCwgZHVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYW4gSW50ZXJ2YWwuIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0ludGVydmFsKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uSW50ZXJ2YWwpIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXJ0IG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAdHlwZSB7RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgc3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMucyA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZW5kIG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAdHlwZSB7RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgZW5kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGF0IGxlYXN0IGl0cyBzdGFydCwgbWVhbmluZyB0aGF0IHRoZSBJbnRlcnZhbCBpc24ndCAnYmFja3dhcmRzJy5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkUmVhc29uID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIEludGVydmFsIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBJbnRlcnZhbCBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgSW50ZXJ2YWwgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbCBpbiB0aGUgc3BlY2lmaWVkIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIHJldHVybiB0aGUgbGVuZ3RoIGluLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBsZW5ndGgodW5pdCA9IFwibWlsbGlzZWNvbmRzXCIpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50b0R1cmF0aW9uKC4uLlt1bml0XSkuZ2V0KHVuaXQpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIG1pbnV0ZXMsIGhvdXJzLCBkYXlzLCBtb250aHMsIG9yIHllYXJzIGluY2x1ZGVkIGluIHRoZSBJbnRlcnZhbCwgZXZlbiBpbiBwYXJ0LlxuICAgKiBVbmxpa2Uge0BsaW5rIGxlbmd0aH0gdGhpcyBjb3VudHMgc2VjdGlvbnMgb2YgdGhlIGNhbGVuZGFyLCBub3QgcGVyaW9kcyBvZiB0aW1lLCBlLmcuIHNwZWNpZnlpbmcgJ2RheSdcbiAgICogYXNrcyAnd2hhdCBkYXRlcyBhcmUgaW5jbHVkZWQgaW4gdGhpcyBpbnRlcnZhbD8nLCBub3QgJ2hvdyBtYW55IGRheXMgbG9uZyBpcyB0aGlzIGludGVydmFsPydcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt1bml0PSdtaWxsaXNlY29uZHMnXSAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNvdW50KHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBOYU47XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXJ0LnN0YXJ0T2YodW5pdCksXG4gICAgICBlbmQgPSB0aGlzLmVuZC5zdGFydE9mKHVuaXQpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGVuZC5kaWZmKHN0YXJ0LCB1bml0KS5nZXQodW5pdCkpICsgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGFuZCBlbmQgYXJlIGJvdGggaW4gdGhlIHNhbWUgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgb2YgdGltZSB0byBjaGVjayBzYW1lbmVzcyBvblxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzU2FtZSh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuaXNFbXB0eSgpIHx8IHRoaXMuZS5taW51cygxKS5oYXNTYW1lKHRoaXMucywgdW5pdCkgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGhhcyB0aGUgc2FtZSBzdGFydCBhbmQgZW5kIERhdGVUaW1lcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucy52YWx1ZU9mKCkgPT09IHRoaXMuZS52YWx1ZU9mKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFmdGVyIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FmdGVyKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zID4gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBiZWZvcmUgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQmVmb3JlKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5lIDw9IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgY29udGFpbnMgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW5zKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zIDw9IGRhdGVUaW1lICYmIHRoaXMuZSA+IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0c1wiIHRoZSBzdGFydCBhbmQvb3IgZW5kIGRhdGVzLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgdmFsdWVzIHRvIHNldFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSB2YWx1ZXMuc3RhcnQgLSB0aGUgc3RhcnRpbmcgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWVzLmVuZCAtIHRoZSBlbmRpbmcgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzZXQoeyBzdGFydCwgZW5kIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCB8fCB0aGlzLnMsIGVuZCB8fCB0aGlzLmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgYXQgZWFjaCBvZiB0aGUgc3BlY2lmaWVkIERhdGVUaW1lc1xuICAgKiBAcGFyYW0gey4uLltEYXRlVGltZV19IGRhdGVUaW1lcyAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gICAqIEByZXR1cm4ge1tJbnRlcnZhbF19XG4gICAqL1xuICBzcGxpdEF0KC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gW107XG4gICAgY29uc3Qgc29ydGVkID0gZGF0ZVRpbWVzXG4gICAgICAgIC5tYXAoZnJpZW5kbHlEYXRlVGltZSlcbiAgICAgICAgLmZpbHRlcihkID0+IHRoaXMuY29udGFpbnMoZCkpXG4gICAgICAgIC5zb3J0KCksXG4gICAgICByZXN1bHRzID0gW107XG4gICAgbGV0IHsgcyB9ID0gdGhpcyxcbiAgICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGNvbnN0IGFkZGVkID0gc29ydGVkW2ldIHx8IHRoaXMuZSxcbiAgICAgICAgbmV4dCA9ICthZGRlZCA+ICt0aGlzLmUgPyB0aGlzLmUgOiBhZGRlZDtcbiAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIG5leHQpKTtcbiAgICAgIHMgPSBuZXh0O1xuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgaW50byBzbWFsbGVyIEludGVydmFscywgZWFjaCBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAgICogTGVmdCBvdmVyIHRpbWUgaXMgZ3JvdXBlZCBpbnRvIGEgc21hbGxlciBpbnRlcnZhbFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGxlbmd0aCBvZiBlYWNoIHJlc3VsdGluZyBpbnRlcnZhbC5cbiAgICogQHJldHVybiB7W0ludGVydmFsXX1cbiAgICovXG4gIHNwbGl0QnkoZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBmcmllbmRseUR1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFkdXIuaXNWYWxpZCB8fCBkdXIuYXMoXCJtaWxsaXNlY29uZHNcIikgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaWR4ID0gMSxcbiAgICAgIG5leHQ7XG5cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGNvbnN0IGFkZGVkID0gdGhpcy5zdGFydC5wbHVzKGR1ci5tYXBVbml0cyh4ID0+IHggKiBpZHgpKTtcbiAgICAgIG5leHQgPSArYWRkZWQgPiArdGhpcy5lID8gdGhpcy5lIDogYWRkZWQ7XG4gICAgICByZXN1bHRzLnB1c2goSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBuZXh0KSk7XG4gICAgICBzID0gbmV4dDtcbiAgICAgIGlkeCArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgaW50byB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzbWFsbGVyIGludGVydmFscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mUGFydHMgLSBUaGUgbnVtYmVyIG9mIEludGVydmFscyB0byBkaXZpZGUgdGhlIEludGVydmFsIGludG8uXG4gICAqIEByZXR1cm4ge1tJbnRlcnZhbF19XG4gICAqL1xuICBkaXZpZGVFcXVhbGx5KG51bWJlck9mUGFydHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiB0aGlzLnNwbGl0QnkodGhpcy5sZW5ndGgoKSAvIG51bWJlck9mUGFydHMpLnNsaWNlKDAsIG51bWJlck9mUGFydHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIEludGVydmFsXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBvdmVybGFwcyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmUgPiBvdGhlci5zICYmIHRoaXMucyA8IG90aGVyLmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3Mgc3RhcnQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c1N0YXJ0KG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK3RoaXMuZSA9PT0gK290aGVyLnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBlbmQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c0VuZChvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICtvdGhlci5lID09PSArdGhpcy5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgZW5ndWxmcyB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZW5ndWxmcyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBvdGhlci5zICYmIHRoaXMuZSA+PSBvdGhlci5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgYXMgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucy5lcXVhbHMob3RoZXIucykgJiYgdGhpcy5lLmVxdWFscyhvdGhlci5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWF4aW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWluaW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogUmV0dXJucyBudWxsIGlmIHRoZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHksIG1lYW5pbmcsIHRoZSBpbnRlcnZhbHMgZG9uJ3QgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zID4gb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICBlID0gdGhpcy5lIDwgb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG5cbiAgICBpZiAocyA+PSBlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMocywgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHVuaW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1pbmltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1heGltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW5pb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMucyA8IG90aGVyLnMgPyB0aGlzLnMgOiBvdGhlci5zLFxuICAgICAgZSA9IHRoaXMuZSA+IG90aGVyLmUgPyB0aGlzLmUgOiBvdGhlci5lO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIGFycmF5IG9mIEludGVydmFscyBpbnRvIGEgZXF1aXZhbGVudCBtaW5pbWFsIHNldCBvZiBJbnRlcnZhbHMuXG4gICAqIENvbWJpbmVzIG92ZXJsYXBwaW5nIGFuZCBhZGphY2VudCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7W0ludGVydmFsXX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge1tJbnRlcnZhbF19XG4gICAqL1xuICBzdGF0aWMgbWVyZ2UoaW50ZXJ2YWxzKSB7XG4gICAgY29uc3QgW2ZvdW5kLCBmaW5hbF0gPSBpbnRlcnZhbHMuc29ydCgoYSwgYikgPT4gYS5zIC0gYi5zKS5yZWR1Y2UoXG4gICAgICAoW3NvZmFyLCBjdXJyZW50XSwgaXRlbSkgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gW3NvZmFyLCBpdGVtXTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Lm92ZXJsYXBzKGl0ZW0pIHx8IGN1cnJlbnQuYWJ1dHNTdGFydChpdGVtKSkge1xuICAgICAgICAgIHJldHVybiBbc29mYXIsIGN1cnJlbnQudW5pb24oaXRlbSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbc29mYXIuY29uY2F0KFtjdXJyZW50XSksIGl0ZW1dO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW1tdLCBudWxsXVxuICAgICk7XG4gICAgaWYgKGZpbmFsKSB7XG4gICAgICBmb3VuZC5wdXNoKGZpbmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBJbnRlcnZhbHMgcmVwcmVzZW50aW5nIHRoZSBzcGFucyBvZiB0aW1lIHRoYXQgb25seSBhcHBlYXIgaW4gb25lIG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge1tJbnRlcnZhbF19IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtbSW50ZXJ2YWxdfVxuICAgKi9cbiAgc3RhdGljIHhvcihpbnRlcnZhbHMpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsLFxuICAgICAgY3VycmVudENvdW50ID0gMDtcbiAgICBjb25zdCByZXN1bHRzID0gW10sXG4gICAgICBlbmRzID0gaW50ZXJ2YWxzLm1hcChpID0+IFt7IHRpbWU6IGkucywgdHlwZTogXCJzXCIgfSwgeyB0aW1lOiBpLmUsIHR5cGU6IFwiZVwiIH1dKSxcbiAgICAgIGZsYXR0ZW5lZCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4uZW5kcyksXG4gICAgICBhcnIgPSBmbGF0dGVuZWQuc29ydCgoYSwgYikgPT4gYS50aW1lIC0gYi50aW1lKTtcblxuICAgIGZvciAoY29uc3QgaSBvZiBhcnIpIHtcbiAgICAgIGN1cnJlbnRDb3VudCArPSBpLnR5cGUgPT09IFwic1wiID8gMSA6IC0xO1xuXG4gICAgICBpZiAoY3VycmVudENvdW50ID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gaS50aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0ICYmICtzdGFydCAhPT0gK2kudGltZSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBpLnRpbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSW50ZXJ2YWwubWVyZ2UocmVzdWx0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgc3BhbiBvZiB0aW1lIGluIHRoaXMgSW50ZXJ2YWwgdGhhdCBkb2Vzbid0IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7Li4uSW50ZXJ2YWx9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtbSW50ZXJ2YWxdfVxuICAgKi9cbiAgZGlmZmVyZW5jZSguLi5pbnRlcnZhbHMpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwueG9yKFt0aGlzXS5jb25jYXQoaW50ZXJ2YWxzKSlcbiAgICAgIC5tYXAoaSA9PiB0aGlzLmludGVyc2VjdGlvbihpKSlcbiAgICAgIC5maWx0ZXIoaSA9PiBpICYmICFpLmlzRW1wdHkoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsIGFwcHJvcHJpYXRlIGZvciBkZWJ1Z2dpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYFske3RoaXMucy50b0lTTygpfSDigJMgJHt0aGlzLmUudG9JU08oKX0pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBzYW1lIG9wdGlvbnMgYXMge0BsaW5rIERhdGVUaW1lLnRvSVNPfVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTTyhvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU08ob3B0cyl9LyR7dGhpcy5lLnRvSVNPKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGRhdGUgb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogVGhlIHRpbWUgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT0RhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU09EYXRlKCl9LyR7dGhpcy5lLnRvSVNPRGF0ZSgpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRpbWUgb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogVGhlIGRhdGUgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBzYW1lIG9wdGlvbnMgYXMge0BsaW5rIERhdGVUaW1lLnRvSVNPfVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUob3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPVGltZShvcHRzKX0vJHt0aGlzLmUudG9JU09UaW1lKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0ZUZvcm1hdCAtIHRoZSBmb3JtYXQgc3RyaW5nLiBUaGlzIHN0cmluZyBmb3JtYXRzIHRoZSBzdGFydCBhbmQgZW5kIHRpbWUuIFNlZSB7QGxpbmsgRGF0ZVRpbWUudG9Gb3JtYXR9IGZvciBkZXRhaWxzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnNlcGFyYXRvciA9ICAnIOKAkyAnXSAtIGEgc2VwYXJhdG9yIHRvIHBsYWNlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgcmVwcmVzZW50YXRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0KGRhdGVGb3JtYXQsIHsgc2VwYXJhdG9yID0gXCIg4oCTIFwiIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvRm9ybWF0KGRhdGVGb3JtYXQpfSR7c2VwYXJhdG9yfSR7dGhpcy5lLnRvRm9ybWF0KGRhdGVGb3JtYXQpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgRHVyYXRpb24gcmVwcmVzZW50aW5nIHRoZSB0aW1lIHNwYW5uZWQgYnkgdGhpcyBpbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbigpLnRvT2JqZWN0KCkgLy89PiB7IG1pbGxpc2Vjb25kczogODg0ODkyNTcgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCdkYXlzJykudG9PYmplY3QoKSAvLz0+IHsgZGF5czogMS4wMjQxODEyMTUyNzc3Nzc4IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbihbJ2hvdXJzJywgJ21pbnV0ZXMnXSkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDI0LCBtaW51dGVzOiAzNC44MjA5NSB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oWydob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXSkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDI0LCBtaW51dGVzOiAzNCwgc2Vjb25kczogNDkuMjU3IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbignc2Vjb25kcycpLnRvT2JqZWN0KCkgLy89PiB7IHNlY29uZHM6IDg4NDg5LjI1NyB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgdG9EdXJhdGlvbih1bml0LCBvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKHRoaXMuaW52YWxpZFJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmUuZGlmZih0aGlzLnMsIHVuaXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBtYXBGbiBvbiB0aGUgaW50ZXJ2YWwgc3RhcnQgYW5kIGVuZCwgcmV0dXJuaW5nIGEgbmV3IEludGVydmFsIGZyb20gdGhlIHJlc3VsdGluZyBEYXRlVGltZXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWFwRm5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLm1hcEVuZHBvaW50cyhlbmRwb2ludCA9PiBlbmRwb2ludC50b1VUQygpKVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS5tYXBFbmRwb2ludHMoZW5kcG9pbnQgPT4gZW5kcG9pbnQucGx1cyh7IGhvdXJzOiAyIH0pKVxuICAgKi9cbiAgbWFwRW5kcG9pbnRzKG1hcEZuKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMobWFwRm4odGhpcy5zKSwgbWFwRm4odGhpcy5lKSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJEYXRlVGltZSIsImZyaWVuZGx5RGF0ZVRpbWUiLCJEdXJhdGlvbiIsImZyaWVuZGx5RHVyYXRpb24iLCJTZXR0aW5ncyIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiSW52YWxpZEludGVydmFsRXJyb3IiLCJJbnZhbGlkIiwiSU5WQUxJRCIsInZhbGlkYXRlU3RhcnRFbmQiLCJzdGFydCIsImVuZCIsImlzVmFsaWQiLCJJbnRlcnZhbCIsImludmFsaWQiLCJ0b0lTTyIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwicyIsImUiLCJpc0x1eG9uSW50ZXJ2YWwiLCJyZWFzb24iLCJleHBsYW5hdGlvbiIsInRocm93T25JbnZhbGlkIiwiZnJvbURhdGVUaW1lcyIsImJ1aWx0U3RhcnQiLCJidWlsdEVuZCIsInZhbGlkYXRlRXJyb3IiLCJhZnRlciIsImR1cmF0aW9uIiwiZHVyIiwiZHQiLCJwbHVzIiwiYmVmb3JlIiwibWludXMiLCJmcm9tSVNPIiwidGV4dCIsIm9wdHMiLCJzcGxpdCIsInN0YXJ0SXNWYWxpZCIsImVuZElzVmFsaWQiLCJpc0ludGVydmFsIiwibyIsImludmFsaWRSZWFzb24iLCJpbnZhbGlkRXhwbGFuYXRpb24iLCJsZW5ndGgiLCJ1bml0IiwidG9EdXJhdGlvbiIsImdldCIsIk5hTiIsImNvdW50Iiwic3RhcnRPZiIsIk1hdGgiLCJmbG9vciIsImRpZmYiLCJoYXNTYW1lIiwiaXNFbXB0eSIsInZhbHVlT2YiLCJpc0FmdGVyIiwiZGF0ZVRpbWUiLCJpc0JlZm9yZSIsImNvbnRhaW5zIiwic2V0Iiwic3BsaXRBdCIsImRhdGVUaW1lcyIsInNvcnRlZCIsIm1hcCIsImZpbHRlciIsImQiLCJzb3J0IiwicmVzdWx0cyIsImkiLCJhZGRlZCIsIm5leHQiLCJwdXNoIiwic3BsaXRCeSIsImFzIiwiaWR4IiwibWFwVW5pdHMiLCJ4IiwiZGl2aWRlRXF1YWxseSIsIm51bWJlck9mUGFydHMiLCJzbGljZSIsIm92ZXJsYXBzIiwib3RoZXIiLCJhYnV0c1N0YXJ0IiwiYWJ1dHNFbmQiLCJlbmd1bGZzIiwiZXF1YWxzIiwiaW50ZXJzZWN0aW9uIiwidW5pb24iLCJtZXJnZSIsImludGVydmFscyIsImZvdW5kIiwiZmluYWwiLCJhIiwiYiIsInJlZHVjZSIsInNvZmFyIiwiY3VycmVudCIsIml0ZW0iLCJjb25jYXQiLCJ4b3IiLCJjdXJyZW50Q291bnQiLCJlbmRzIiwidGltZSIsInR5cGUiLCJmbGF0dGVuZWQiLCJBcnJheSIsInByb3RvdHlwZSIsImFyciIsImRpZmZlcmVuY2UiLCJ0b1N0cmluZyIsInRvSVNPRGF0ZSIsInRvSVNPVGltZSIsInRvRm9ybWF0IiwiZGF0ZUZvcm1hdCIsInNlcGFyYXRvciIsIm1hcEVuZHBvaW50cyIsIm1hcEZuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/interval.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/luxon.js":
/*!*****************************************!*\
  !*** ./node_modules/luxon/src/luxon.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* reexport safe */ _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   Duration: () => (/* reexport safe */ _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   FixedOffsetZone: () => (/* reexport safe */ _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   IANAZone: () => (/* reexport safe */ _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   Info: () => (/* reexport safe */ _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   Interval: () => (/* reexport safe */ _interval_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   InvalidZone: () => (/* reexport safe */ _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   LocalZone: () => (/* reexport safe */ _zones_localZone_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   Settings: () => (/* reexport safe */ _settings_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   Zone: () => (/* reexport safe */ _zone_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ \"(rsc)/./node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ \"(rsc)/./node_modules/luxon/src/duration.js\");\n/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval.js */ \"(rsc)/./node_modules/luxon/src/interval.js\");\n/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./info.js */ \"(rsc)/./node_modules/luxon/src/info.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zone.js */ \"(rsc)/./node_modules/luxon/src/zone.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zones/fixedOffsetZone.js */ \"(rsc)/./node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(rsc)/./node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zones/invalidZone.js */ \"(rsc)/./node_modules/luxon/src/zones/invalidZone.js\");\n/* harmony import */ var _zones_localZone_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./zones/localZone.js */ \"(rsc)/./node_modules/luxon/src/zones/localZone.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./settings.js */ \"(rsc)/./node_modules/luxon/src/settings.js\");\n\n\n\n\n\n\n\n\n\n\nconst VERSION = \"1.28.1\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2x1eG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNBO0FBQ0E7QUFDUjtBQUNBO0FBQzRCO0FBQ2Q7QUFDTTtBQUNKO0FBQ1I7QUFFckMsTUFBTVUsVUFBVTtBQWNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWF0b29scy1uZXh0Ly4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9sdXhvbi5qcz9kMGE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgSW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCBJbmZvIGZyb20gXCIuL2luZm8uanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuL3pvbmUuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi96b25lcy9pbnZhbGlkWm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsWm9uZSBmcm9tIFwiLi96b25lcy9sb2NhbFpvbmUuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuXG5jb25zdCBWRVJTSU9OID0gXCIxLjI4LjFcIjtcblxuZXhwb3J0IHtcbiAgVkVSU0lPTixcbiAgRGF0ZVRpbWUsXG4gIER1cmF0aW9uLFxuICBJbnRlcnZhbCxcbiAgSW5mbyxcbiAgWm9uZSxcbiAgRml4ZWRPZmZzZXRab25lLFxuICBJQU5BWm9uZSxcbiAgSW52YWxpZFpvbmUsXG4gIExvY2FsWm9uZSxcbiAgU2V0dGluZ3Ncbn07XG4iXSwibmFtZXMiOlsiRGF0ZVRpbWUiLCJEdXJhdGlvbiIsIkludGVydmFsIiwiSW5mbyIsIlpvbmUiLCJGaXhlZE9mZnNldFpvbmUiLCJJQU5BWm9uZSIsIkludmFsaWRab25lIiwiTG9jYWxab25lIiwiU2V0dGluZ3MiLCJWRVJTSU9OIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/luxon.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/settings.js":
/*!********************************************!*\
  !*** ./node_modules/luxon/src/settings.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Settings)\n/* harmony export */ });\n/* harmony import */ var _zones_localZone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zones/localZone.js */ \"(rsc)/./node_modules/luxon/src/zones/localZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(rsc)/./node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/locale.js */ \"(rsc)/./node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(rsc)/./node_modules/luxon/src/impl/zoneUtil.js\");\n\n\n\n\nlet now = ()=>Date.now(), defaultZone = null, defaultLocale = null, defaultNumberingSystem = null, defaultOutputCalendar = null, throwOnInvalid = false;\n/**\n * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.\n */ class Settings {\n    /**\n   * Get the callback for returning the current timestamp.\n   * @type {function}\n   */ static get now() {\n        return now;\n    }\n    /**\n   * Set the callback for returning the current timestamp.\n   * The function should return a number, which will be interpreted as an Epoch millisecond count\n   * @type {function}\n   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future\n   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time\n   */ static set now(n) {\n        now = n;\n    }\n    /**\n   * Get the default time zone to create DateTimes in.\n   * @type {string}\n   */ static get defaultZoneName() {\n        return Settings.defaultZone.name;\n    }\n    /**\n   * Set the default time zone to create DateTimes in. Does not affect existing instances.\n   * @type {string}\n   */ static set defaultZoneName(z) {\n        if (!z) {\n            defaultZone = null;\n        } else {\n            defaultZone = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZone)(z);\n        }\n    }\n    /**\n   * Get the default time zone object to create DateTimes in. Does not affect existing instances.\n   * @type {Zone}\n   */ static get defaultZone() {\n        return defaultZone || _zones_localZone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].instance;\n    }\n    /**\n   * Get the default locale to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */ static get defaultLocale() {\n        return defaultLocale;\n    }\n    /**\n   * Set the default locale to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */ static set defaultLocale(locale) {\n        defaultLocale = locale;\n    }\n    /**\n   * Get the default numbering system to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */ static get defaultNumberingSystem() {\n        return defaultNumberingSystem;\n    }\n    /**\n   * Set the default numbering system to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */ static set defaultNumberingSystem(numberingSystem) {\n        defaultNumberingSystem = numberingSystem;\n    }\n    /**\n   * Get the default output calendar to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */ static get defaultOutputCalendar() {\n        return defaultOutputCalendar;\n    }\n    /**\n   * Set the default output calendar to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */ static set defaultOutputCalendar(outputCalendar) {\n        defaultOutputCalendar = outputCalendar;\n    }\n    /**\n   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n   * @type {boolean}\n   */ static get throwOnInvalid() {\n        return throwOnInvalid;\n    }\n    /**\n   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n   * @type {boolean}\n   */ static set throwOnInvalid(t) {\n        throwOnInvalid = t;\n    }\n    /**\n   * Reset Luxon's global caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */ static resetCaches() {\n        _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].resetCache();\n        _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].resetCache();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3NldHRpbmdzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZDO0FBQ0Y7QUFDTDtBQUVhO0FBRW5ELElBQUlJLE1BQU0sSUFBTUMsS0FBS0QsR0FBRyxJQUN0QkUsY0FBYyxNQUNkQyxnQkFBZ0IsTUFDaEJDLHlCQUF5QixNQUN6QkMsd0JBQXdCLE1BQ3hCQyxpQkFBaUI7QUFFbkI7O0NBRUMsR0FDYyxNQUFNQztJQUNuQjs7O0dBR0MsR0FDRCxXQUFXUCxNQUFNO1FBQ2YsT0FBT0E7SUFDVDtJQUVBOzs7Ozs7R0FNQyxHQUNELFdBQVdBLElBQUlRLENBQUMsRUFBRTtRQUNoQlIsTUFBTVE7SUFDUjtJQUVBOzs7R0FHQyxHQUNELFdBQVdDLGtCQUFrQjtRQUMzQixPQUFPRixTQUFTTCxXQUFXLENBQUNRLElBQUk7SUFDbEM7SUFFQTs7O0dBR0MsR0FDRCxXQUFXRCxnQkFBZ0JFLENBQUMsRUFBRTtRQUM1QixJQUFJLENBQUNBLEdBQUc7WUFDTlQsY0FBYztRQUNoQixPQUFPO1lBQ0xBLGNBQWNILGdFQUFhQSxDQUFDWTtRQUM5QjtJQUNGO0lBRUE7OztHQUdDLEdBQ0QsV0FBV1QsY0FBYztRQUN2QixPQUFPQSxlQUFlTiwyREFBU0EsQ0FBQ2dCLFFBQVE7SUFDMUM7SUFFQTs7O0dBR0MsR0FDRCxXQUFXVCxnQkFBZ0I7UUFDekIsT0FBT0E7SUFDVDtJQUVBOzs7R0FHQyxHQUNELFdBQVdBLGNBQWNVLE1BQU0sRUFBRTtRQUMvQlYsZ0JBQWdCVTtJQUNsQjtJQUVBOzs7R0FHQyxHQUNELFdBQVdULHlCQUF5QjtRQUNsQyxPQUFPQTtJQUNUO0lBRUE7OztHQUdDLEdBQ0QsV0FBV0EsdUJBQXVCVSxlQUFlLEVBQUU7UUFDakRWLHlCQUF5QlU7SUFDM0I7SUFFQTs7O0dBR0MsR0FDRCxXQUFXVCx3QkFBd0I7UUFDakMsT0FBT0E7SUFDVDtJQUVBOzs7R0FHQyxHQUNELFdBQVdBLHNCQUFzQlUsY0FBYyxFQUFFO1FBQy9DVix3QkFBd0JVO0lBQzFCO0lBRUE7OztHQUdDLEdBQ0QsV0FBV1QsaUJBQWlCO1FBQzFCLE9BQU9BO0lBQ1Q7SUFFQTs7O0dBR0MsR0FDRCxXQUFXQSxlQUFlVSxDQUFDLEVBQUU7UUFDM0JWLGlCQUFpQlU7SUFDbkI7SUFFQTs7O0dBR0MsR0FDRCxPQUFPQyxjQUFjO1FBQ25CbkIsdURBQU1BLENBQUNvQixVQUFVO1FBQ2pCckIsMERBQVFBLENBQUNxQixVQUFVO0lBQ3JCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pYXRvb2xzLW5leHQvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3NldHRpbmdzLmpzPzRlZGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExvY2FsWm9uZSBmcm9tIFwiLi96b25lcy9sb2NhbFpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuXG5pbXBvcnQgeyBub3JtYWxpemVab25lIH0gZnJvbSBcIi4vaW1wbC96b25lVXRpbC5qc1wiO1xuXG5sZXQgbm93ID0gKCkgPT4gRGF0ZS5ub3coKSxcbiAgZGVmYXVsdFpvbmUgPSBudWxsLCAvLyBub3Qgc2V0dGluZyB0aGlzIGRpcmVjdGx5IHRvIExvY2FsWm9uZS5pbnN0YW5jZSBiYyBsb2FkaW5nIG9yZGVyIGlzc3Vlc1xuICBkZWZhdWx0TG9jYWxlID0gbnVsbCxcbiAgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSA9IG51bGwsXG4gIGRlZmF1bHRPdXRwdXRDYWxlbmRhciA9IG51bGwsXG4gIHRocm93T25JbnZhbGlkID0gZmFsc2U7XG5cbi8qKlxuICogU2V0dGluZ3MgY29udGFpbnMgc3RhdGljIGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCBjb250cm9sIEx1eG9uJ3Mgb3ZlcmFsbCBiZWhhdmlvci4gTHV4b24gaXMgYSBzaW1wbGUgbGlicmFyeSB3aXRoIGZldyBvcHRpb25zLCBidXQgdGhlIG9uZXMgaXQgZG9lcyBoYXZlIGxpdmUgaGVyZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0dGluZ3Mge1xuICAvKipcbiAgICogR2V0IHRoZSBjYWxsYmFjayBmb3IgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKi9cbiAgc3RhdGljIGdldCBub3coKSB7XG4gICAgcmV0dXJuIG5vdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNhbGxiYWNrIGZvciByZXR1cm5pbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wLlxuICAgKiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIG51bWJlciwgd2hpY2ggd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhbiBFcG9jaCBtaWxsaXNlY29uZCBjb3VudFxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLm5vdyA9ICgpID0+IERhdGUubm93KCkgKyAzMDAwIC8vIHByZXRlbmQgaXQgaXMgMyBzZWNvbmRzIGluIHRoZSBmdXR1cmVcbiAgICogQGV4YW1wbGUgU2V0dGluZ3Mubm93ID0gKCkgPT4gMCAvLyBhbHdheXMgcHJldGVuZCBpdCdzIEphbiAxLCAxOTcwIGF0IG1pZG5pZ2h0IGluIFVUQyB0aW1lXG4gICAqL1xuICBzdGF0aWMgc2V0IG5vdyhuKSB7XG4gICAgbm93ID0gbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgdGltZSB6b25lIHRvIGNyZWF0ZSBEYXRlVGltZXMgaW4uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRab25lTmFtZSgpIHtcbiAgICByZXR1cm4gU2V0dGluZ3MuZGVmYXVsdFpvbmUubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgdGltZSB6b25lIHRvIGNyZWF0ZSBEYXRlVGltZXMgaW4uIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRab25lTmFtZSh6KSB7XG4gICAgaWYgKCF6KSB7XG4gICAgICBkZWZhdWx0Wm9uZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRab25lID0gbm9ybWFsaXplWm9uZSh6KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSBvYmplY3QgdG8gY3JlYXRlIERhdGVUaW1lcyBpbi4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge1pvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRab25lKCkge1xuICAgIHJldHVybiBkZWZhdWx0Wm9uZSB8fCBMb2NhbFpvbmUuaW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IGxvY2FsZSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRMb2NhbGUoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRMb2NhbGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IGxvY2FsZSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRMb2NhbGUobG9jYWxlKSB7XG4gICAgZGVmYXVsdExvY2FsZSA9IGxvY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgbnVtYmVyaW5nIHN5c3RlbSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtKG51bWJlcmluZ1N5c3RlbSkge1xuICAgIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBudW1iZXJpbmdTeXN0ZW07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IG91dHB1dCBjYWxlbmRhciB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRPdXRwdXRDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE91dHB1dENhbGVuZGFyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBvdXRwdXQgY2FsZW5kYXIgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIob3V0cHV0Q2FsZW5kYXIpIHtcbiAgICBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRocm93T25JbnZhbGlkKCkge1xuICAgIHJldHVybiB0aHJvd09uSW52YWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgc2V0IHRocm93T25JbnZhbGlkKHQpIHtcbiAgICB0aHJvd09uSW52YWxpZCA9IHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgTHV4b24ncyBnbG9iYWwgY2FjaGVzLiBTaG91bGQgb25seSBiZSBuZWNlc3NhcnkgaW4gdGVzdGluZyBzY2VuYXJpb3MuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgcmVzZXRDYWNoZXMoKSB7XG4gICAgTG9jYWxlLnJlc2V0Q2FjaGUoKTtcbiAgICBJQU5BWm9uZS5yZXNldENhY2hlKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJMb2NhbFpvbmUiLCJJQU5BWm9uZSIsIkxvY2FsZSIsIm5vcm1hbGl6ZVpvbmUiLCJub3ciLCJEYXRlIiwiZGVmYXVsdFpvbmUiLCJkZWZhdWx0TG9jYWxlIiwiZGVmYXVsdE51bWJlcmluZ1N5c3RlbSIsImRlZmF1bHRPdXRwdXRDYWxlbmRhciIsInRocm93T25JbnZhbGlkIiwiU2V0dGluZ3MiLCJuIiwiZGVmYXVsdFpvbmVOYW1lIiwibmFtZSIsInoiLCJpbnN0YW5jZSIsImxvY2FsZSIsIm51bWJlcmluZ1N5c3RlbSIsIm91dHB1dENhbGVuZGFyIiwidCIsInJlc2V0Q2FjaGVzIiwicmVzZXRDYWNoZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/settings.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/zone.js":
/*!****************************************!*\
  !*** ./node_modules/luxon/src/zone.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Zone)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/luxon/src/errors.js\");\n/* eslint no-unused-vars: \"off\" */ \n/**\n * @interface\n */ class Zone {\n    /**\n   * The type of zone\n   * @abstract\n   * @type {string}\n   */ get type() {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n    }\n    /**\n   * The name of this zone.\n   * @abstract\n   * @type {string}\n   */ get name() {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n    }\n    /**\n   * Returns whether the offset is known to be fixed for the whole year.\n   * @abstract\n   * @type {boolean}\n   */ get universal() {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n    }\n    /**\n   * Returns the offset's common name (such as EST) at the specified timestamp\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to get the name\n   * @param {Object} opts - Options to affect the format\n   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.\n   * @param {string} opts.locale - What locale to return the offset name in.\n   * @return {string}\n   */ offsetName(ts, opts) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n    }\n    /**\n   * Returns the offset's value as a string\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to get the offset\n   * @param {string} format - What style of offset to return.\n   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n   * @return {string}\n   */ formatOffset(ts, format) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n    }\n    /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to compute the offset\n   * @return {number}\n   */ offset(ts) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n    }\n    /**\n   * Return whether this Zone is equal to another zone\n   * @abstract\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */ equals(otherZone) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n    }\n    /**\n   * Return whether this Zone is valid.\n   * @abstract\n   * @type {boolean}\n   */ get isValid() {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxnQ0FBZ0MsR0FDa0I7QUFFbEQ7O0NBRUMsR0FDYyxNQUFNQztJQUNuQjs7OztHQUlDLEdBQ0QsSUFBSUMsT0FBTztRQUNULE1BQU0sSUFBSUYsMkRBQW1CQTtJQUMvQjtJQUVBOzs7O0dBSUMsR0FDRCxJQUFJRyxPQUFPO1FBQ1QsTUFBTSxJQUFJSCwyREFBbUJBO0lBQy9CO0lBRUE7Ozs7R0FJQyxHQUNELElBQUlJLFlBQVk7UUFDZCxNQUFNLElBQUlKLDJEQUFtQkE7SUFDL0I7SUFFQTs7Ozs7Ozs7R0FRQyxHQUNESyxXQUFXQyxFQUFFLEVBQUVDLElBQUksRUFBRTtRQUNuQixNQUFNLElBQUlQLDJEQUFtQkE7SUFDL0I7SUFFQTs7Ozs7OztHQU9DLEdBQ0RRLGFBQWFGLEVBQUUsRUFBRUcsTUFBTSxFQUFFO1FBQ3ZCLE1BQU0sSUFBSVQsMkRBQW1CQTtJQUMvQjtJQUVBOzs7OztHQUtDLEdBQ0RVLE9BQU9KLEVBQUUsRUFBRTtRQUNULE1BQU0sSUFBSU4sMkRBQW1CQTtJQUMvQjtJQUVBOzs7OztHQUtDLEdBQ0RXLE9BQU9DLFNBQVMsRUFBRTtRQUNoQixNQUFNLElBQUlaLDJEQUFtQkE7SUFDL0I7SUFFQTs7OztHQUlDLEdBQ0QsSUFBSWEsVUFBVTtRQUNaLE1BQU0sSUFBSWIsMkRBQW1CQTtJQUMvQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWF0b29scy1uZXh0Ly4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lLmpzPzcwYjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcIm9mZlwiICovXG5pbXBvcnQgeyBab25lSXNBYnN0cmFjdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBab25lIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgem9uZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgb2Zmc2V0IGlzIGtub3duIHRvIGJlIGZpeGVkIGZvciB0aGUgd2hvbGUgeWVhci5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IHVuaXZlcnNhbCgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIGNvbW1vbiBuYW1lIChzdWNoIGFzIEVTVCkgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXBcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucyB0byBhZmZlY3QgdGhlIGZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5mb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uIEFjY2VwdHMgJ2xvbmcnIG9yICdzaG9ydCcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmxvY2FsZSAtIFdoYXQgbG9jYWxlIHRvIHJldHVybiB0aGUgb2Zmc2V0IG5hbWUgaW4uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIG9mZnNldE5hbWUodHMsIG9wdHMpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIHZhbHVlIGFzIGEgc3RyaW5nXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgb2Zmc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBBY2NlcHRzICduYXJyb3cnLCAnc2hvcnQnLCBvciAndGVjaGllJy4gUmV0dXJuaW5nICcrNicsICcrMDY6MDAnLCBvciAnKzA2MDAnIHJlc3BlY3RpdmVseVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBvZmZzZXQgaW4gbWludXRlcyBmb3IgdGhpcyB6b25lIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBjb21wdXRlIHRoZSBvZmZzZXRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgb2Zmc2V0KHRzKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgZXF1YWwgdG8gYW5vdGhlciB6b25lXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge1pvbmV9IG90aGVyWm9uZSAtIHRoZSB6b25lIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyB2YWxpZC5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlpvbmVJc0Fic3RyYWN0RXJyb3IiLCJab25lIiwidHlwZSIsIm5hbWUiLCJ1bml2ZXJzYWwiLCJvZmZzZXROYW1lIiwidHMiLCJvcHRzIiwiZm9ybWF0T2Zmc2V0IiwiZm9ybWF0Iiwib2Zmc2V0IiwiZXF1YWxzIiwib3RoZXJab25lIiwiaXNWYWxpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/zone.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/zones/IANAZone.js":
/*!**************************************************!*\
  !*** ./node_modules/luxon/src/zones/IANAZone.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ IANAZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ \"(rsc)/./node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(rsc)/./node_modules/luxon/src/zone.js\");\n\n\nconst matchingRegex = RegExp(`^${_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.ianaRegex.source}$`);\nlet dtfCache = {};\nfunction makeDTF(zone) {\n    if (!dtfCache[zone]) {\n        dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n            hour12: false,\n            timeZone: zone,\n            year: \"numeric\",\n            month: \"2-digit\",\n            day: \"2-digit\",\n            hour: \"2-digit\",\n            minute: \"2-digit\",\n            second: \"2-digit\"\n        });\n    }\n    return dtfCache[zone];\n}\nconst typeToPos = {\n    year: 0,\n    month: 1,\n    day: 2,\n    hour: 3,\n    minute: 4,\n    second: 5\n};\nfunction hackyOffset(dtf, date) {\n    const formatted = dtf.format(date).replace(/\\u200E/g, \"\"), parsed = /(\\d+)\\/(\\d+)\\/(\\d+),? (\\d+):(\\d+):(\\d+)/.exec(formatted), [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed;\n    return [\n        fYear,\n        fMonth,\n        fDay,\n        fHour,\n        fMinute,\n        fSecond\n    ];\n}\nfunction partsOffset(dtf, date) {\n    const formatted = dtf.formatToParts(date), filled = [];\n    for(let i = 0; i < formatted.length; i++){\n        const { type, value } = formatted[i], pos = typeToPos[type];\n        if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(pos)) {\n            filled[pos] = parseInt(value, 10);\n        }\n    }\n    return filled;\n}\nlet ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */ class IANAZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */ static create(name) {\n        if (!ianaZoneCache[name]) {\n            ianaZoneCache[name] = new IANAZone(name);\n        }\n        return ianaZoneCache[name];\n    }\n    /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */ static resetCache() {\n        ianaZoneCache = {};\n        dtfCache = {};\n    }\n    /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Fantasia/Castle\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */ static isValidSpecifier(s) {\n        return !!(s && s.match(matchingRegex));\n    }\n    /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */ static isValidZone(zone) {\n        try {\n            new Intl.DateTimeFormat(\"en-US\", {\n                timeZone: zone\n            }).format();\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    // Etc/GMT+8 -> -480\n    /** @ignore */ static parseGMTOffset(specifier) {\n        if (specifier) {\n            const match = specifier.match(/^Etc\\/GMT(0|[+-]\\d{1,2})$/i);\n            if (match) {\n                return -60 * parseInt(match[1]);\n            }\n        }\n        return null;\n    }\n    constructor(name){\n        super();\n        /** @private **/ this.zoneName = name;\n        /** @private **/ this.valid = IANAZone.isValidZone(name);\n    }\n    /** @override **/ get type() {\n        return \"iana\";\n    }\n    /** @override **/ get name() {\n        return this.zoneName;\n    }\n    /** @override **/ get universal() {\n        return false;\n    }\n    /** @override **/ offsetName(ts, { format, locale }) {\n        return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.parseZoneInfo)(ts, format, locale, this.name);\n    }\n    /** @override **/ formatOffset(ts, format) {\n        return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.offset(ts), format);\n    }\n    /** @override **/ offset(ts) {\n        const date = new Date(ts);\n        if (isNaN(date)) return NaN;\n        const dtf = makeDTF(this.name), [year, month, day, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date), // work around https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n        adjustedHour = hour === 24 ? 0 : hour;\n        const asUTC = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.objToLocalTS)({\n            year,\n            month,\n            day,\n            hour: adjustedHour,\n            minute,\n            second,\n            millisecond: 0\n        });\n        let asTS = +date;\n        const over = asTS % 1000;\n        asTS -= over >= 0 ? over : 1000 + over;\n        return (asUTC - asTS) / (60 * 1000);\n    }\n    /** @override **/ equals(otherZone) {\n        return otherZone.type === \"iana\" && otherZone.name === this.name;\n    }\n    /** @override **/ get isValid() {\n        return this.valid;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL0lBTkFab25lLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRztBQUN0RTtBQUU5QixNQUFNTSxnQkFBZ0JDLE9BQU8sQ0FBQyxDQUFDLEVBQUVKLG9EQUFTQSxDQUFDSyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBRXBELElBQUlDLFdBQVcsQ0FBQztBQUNoQixTQUFTQyxRQUFRQyxJQUFJO0lBQ25CLElBQUksQ0FBQ0YsUUFBUSxDQUFDRSxLQUFLLEVBQUU7UUFDbkJGLFFBQVEsQ0FBQ0UsS0FBSyxHQUFHLElBQUlDLEtBQUtDLGNBQWMsQ0FBQyxTQUFTO1lBQ2hEQyxRQUFRO1lBQ1JDLFVBQVVKO1lBQ1ZLLE1BQU07WUFDTkMsT0FBTztZQUNQQyxLQUFLO1lBQ0xDLE1BQU07WUFDTkMsUUFBUTtZQUNSQyxRQUFRO1FBQ1Y7SUFDRjtJQUNBLE9BQU9aLFFBQVEsQ0FBQ0UsS0FBSztBQUN2QjtBQUVBLE1BQU1XLFlBQVk7SUFDaEJOLE1BQU07SUFDTkMsT0FBTztJQUNQQyxLQUFLO0lBQ0xDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxRQUFRO0FBQ1Y7QUFFQSxTQUFTRSxZQUFZQyxHQUFHLEVBQUVDLElBQUk7SUFDNUIsTUFBTUMsWUFBWUYsSUFBSUcsTUFBTSxDQUFDRixNQUFNRyxPQUFPLENBQUMsV0FBVyxLQUNwREMsU0FBUywwQ0FBMENDLElBQUksQ0FBQ0osWUFDeEQsR0FBR0ssUUFBUUMsTUFBTUMsT0FBT0MsT0FBT0MsU0FBU0MsUUFBUSxHQUFHUDtJQUNyRCxPQUFPO1FBQUNJO1FBQU9GO1FBQVFDO1FBQU1FO1FBQU9DO1FBQVNDO0tBQVE7QUFDdkQ7QUFFQSxTQUFTQyxZQUFZYixHQUFHLEVBQUVDLElBQUk7SUFDNUIsTUFBTUMsWUFBWUYsSUFBSWMsYUFBYSxDQUFDYixPQUNsQ2MsU0FBUyxFQUFFO0lBQ2IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlkLFVBQVVlLE1BQU0sRUFBRUQs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QUM7WUFDQUMsTUFBTWtEO1lBQ05qRDtZQUNBQztZQUNBa0QsYUFBYTtRQUNmO1FBRUEsSUFBSUMsT0FBTyxDQUFDL0M7UUFDWixNQUFNZ0QsT0FBT0QsT0FBTztRQUNwQkEsUUFBUUMsUUFBUSxJQUFJQSxPQUFPLE9BQU9BO1FBQ2xDLE9BQU8sQ0FBQ0gsUUFBUUUsSUFBRyxJQUFNLE1BQUssSUFBRztJQUNuQztJQUVBLGVBQWUsR0FDZkUsT0FBT0MsU0FBUyxFQUFFO1FBQ2hCLE9BQU9BLFVBQVVqQyxJQUFJLEtBQUssVUFBVWlDLFVBQVUxQixJQUFJLEtBQUssSUFBSSxDQUFDQSxJQUFJO0lBQ2xFO0lBRUEsZUFBZSxHQUNmLElBQUkyQixVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUNoQixLQUFLO0lBQ25CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pYXRvb2xzLW5leHQvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL0lBTkFab25lLmpzP2VlODEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBwYXJzZVpvbmVJbmZvLCBpc1VuZGVmaW5lZCwgaWFuYVJlZ2V4LCBvYmpUb0xvY2FsVFMgfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5jb25zdCBtYXRjaGluZ1JlZ2V4ID0gUmVnRXhwKGBeJHtpYW5hUmVnZXguc291cmNlfSRgKTtcblxubGV0IGR0ZkNhY2hlID0ge307XG5mdW5jdGlvbiBtYWtlRFRGKHpvbmUpIHtcbiAgaWYgKCFkdGZDYWNoZVt6b25lXSkge1xuICAgIGR0ZkNhY2hlW3pvbmVdID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7XG4gICAgICBob3VyMTI6IGZhbHNlLFxuICAgICAgdGltZVpvbmU6IHpvbmUsXG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcIjItZGlnaXRcIixcbiAgICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICBzZWNvbmQ6IFwiMi1kaWdpdFwiXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGR0ZkNhY2hlW3pvbmVdO1xufVxuXG5jb25zdCB0eXBlVG9Qb3MgPSB7XG4gIHllYXI6IDAsXG4gIG1vbnRoOiAxLFxuICBkYXk6IDIsXG4gIGhvdXI6IDMsXG4gIG1pbnV0ZTogNCxcbiAgc2Vjb25kOiA1XG59O1xuXG5mdW5jdGlvbiBoYWNreU9mZnNldChkdGYsIGRhdGUpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gZHRmLmZvcm1hdChkYXRlKS5yZXBsYWNlKC9cXHUyMDBFL2csIFwiXCIpLFxuICAgIHBhcnNlZCA9IC8oXFxkKylcXC8oXFxkKylcXC8oXFxkKyksPyAoXFxkKyk6KFxcZCspOihcXGQrKS8uZXhlYyhmb3JtYXR0ZWQpLFxuICAgIFssIGZNb250aCwgZkRheSwgZlllYXIsIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXSA9IHBhcnNlZDtcbiAgcmV0dXJuIFtmWWVhciwgZk1vbnRoLCBmRGF5LCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF07XG59XG5cbmZ1bmN0aW9uIHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICBjb25zdCBmb3JtYXR0ZWQgPSBkdGYuZm9ybWF0VG9QYXJ0cyhkYXRlKSxcbiAgICBmaWxsZWQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBmb3JtYXR0ZWRbaV0sXG4gICAgICBwb3MgPSB0eXBlVG9Qb3NbdHlwZV07XG5cbiAgICBpZiAoIWlzVW5kZWZpbmVkKHBvcykpIHtcbiAgICAgIGZpbGxlZFtwb3NdID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbGxlZDtcbn1cblxubGV0IGlhbmFab25lQ2FjaGUgPSB7fTtcbi8qKlxuICogQSB6b25lIGlkZW50aWZpZWQgYnkgYW4gSUFOQSBpZGVudGlmaWVyLCBsaWtlIEFtZXJpY2EvTmV3X1lvcmtcbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJQU5BWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBab25lIG5hbWVcbiAgICogQHJldHVybiB7SUFOQVpvbmV9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKG5hbWUpIHtcbiAgICBpZiAoIWlhbmFab25lQ2FjaGVbbmFtZV0pIHtcbiAgICAgIGlhbmFab25lQ2FjaGVbbmFtZV0gPSBuZXcgSUFOQVpvbmUobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBpYW5hWm9uZUNhY2hlW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGxvY2FsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgaWFuYVpvbmVDYWNoZSA9IHt9O1xuICAgIGR0ZkNhY2hlID0ge307XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgYSB2YWxpZCBzcGVjaWZpZXIuIFRoaXMgb25seSBjaGVja3MgdGhlIHN0cmluZydzIGZvcm1hdCwgbm90IHRoYXQgdGhlIHNwZWNpZmllciBpZGVudGlmaWVzIGEga25vd24gem9uZTsgc2VlIGlzVmFsaWRab25lIGZvciB0aGF0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIFRoZSBzdHJpbmcgdG8gY2hlY2sgdmFsaWRpdHkgb25cbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJGYW50YXNpYS9DYXN0bGVcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRTcGVjaWZpZXIocykge1xuICAgIHJldHVybiAhIShzICYmIHMubWF0Y2gobWF0Y2hpbmdSZWdleCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlkZW50aWZpZXMgYSByZWFsIHpvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiQW1lcmljYS9OZXdfWW9ya1wiKSAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJGYW50YXNpYS9DYXN0bGVcIikgLy89PiBmYWxzZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIlNwb3J0fn5ibG9ycFwiKSAvLz0+IGZhbHNlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZFpvbmUoem9uZSkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgdGltZVpvbmU6IHpvbmUgfSkuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gRXRjL0dNVCs4IC0+IC00ODBcbiAgLyoqIEBpZ25vcmUgKi9cbiAgc3RhdGljIHBhcnNlR01UT2Zmc2V0KHNwZWNpZmllcikge1xuICAgIGlmIChzcGVjaWZpZXIpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gc3BlY2lmaWVyLm1hdGNoKC9eRXRjXFwvR01UKDB8WystXVxcZHsxLDJ9KSQvaSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIC02MCAqIHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy56b25lTmFtZSA9IG5hbWU7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMudmFsaWQgPSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShuYW1lKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImlhbmFcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHVuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKHRzLCB7IGZvcm1hdCwgbG9jYWxlIH0pIHtcbiAgICByZXR1cm4gcGFyc2Vab25lSW5mbyh0cywgZm9ybWF0LCBsb2NhbGUsIHRoaXMubmFtZSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5vZmZzZXQodHMpLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KHRzKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRzKTtcblxuICAgIGlmIChpc05hTihkYXRlKSkgcmV0dXJuIE5hTjtcblxuICAgIGNvbnN0IGR0ZiA9IG1ha2VEVEYodGhpcy5uYW1lKSxcbiAgICAgIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZF0gPSBkdGYuZm9ybWF0VG9QYXJ0c1xuICAgICAgICA/IHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSlcbiAgICAgICAgOiBoYWNreU9mZnNldChkdGYsIGRhdGUpLFxuICAgICAgLy8gd29yayBhcm91bmQgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTAyNTU2NCZjYW49MiZxPSUyMjI0JTNBMDAlMjIlMjBkYXRldGltZWZvcm1hdFxuICAgICAgYWRqdXN0ZWRIb3VyID0gaG91ciA9PT0gMjQgPyAwIDogaG91cjtcblxuICAgIGNvbnN0IGFzVVRDID0gb2JqVG9Mb2NhbFRTKHtcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheSxcbiAgICAgIGhvdXI6IGFkanVzdGVkSG91cixcbiAgICAgIG1pbnV0ZSxcbiAgICAgIHNlY29uZCxcbiAgICAgIG1pbGxpc2Vjb25kOiAwXG4gICAgfSk7XG5cbiAgICBsZXQgYXNUUyA9ICtkYXRlO1xuICAgIGNvbnN0IG92ZXIgPSBhc1RTICUgMTAwMDtcbiAgICBhc1RTIC09IG92ZXIgPj0gMCA/IG92ZXIgOiAxMDAwICsgb3ZlcjtcbiAgICByZXR1cm4gKGFzVVRDIC0gYXNUUykgLyAoNjAgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwiaWFuYVwiICYmIG90aGVyWm9uZS5uYW1lID09PSB0aGlzLm5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImZvcm1hdE9mZnNldCIsInBhcnNlWm9uZUluZm8iLCJpc1VuZGVmaW5lZCIsImlhbmFSZWdleCIsIm9ialRvTG9jYWxUUyIsIlpvbmUiLCJtYXRjaGluZ1JlZ2V4IiwiUmVnRXhwIiwic291cmNlIiwiZHRmQ2FjaGUiLCJtYWtlRFRGIiwiem9uZSIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsImhvdXIxMiIsInRpbWVab25lIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInNlY29uZCIsInR5cGVUb1BvcyIsImhhY2t5T2Zmc2V0IiwiZHRmIiwiZGF0ZSIsImZvcm1hdHRlZCIsImZvcm1hdCIsInJlcGxhY2UiLCJwYXJzZWQiLCJleGVjIiwiZk1vbnRoIiwiZkRheSIsImZZZWFyIiwiZkhvdXIiLCJmTWludXRlIiwiZlNlY29uZCIsInBhcnRzT2Zmc2V0IiwiZm9ybWF0VG9QYXJ0cyIsImZpbGxlZCIsImkiLCJsZW5ndGgiLCJ0eXBlIiwidmFsdWUiLCJwb3MiLCJwYXJzZUludCIsImlhbmFab25lQ2FjaGUiLCJJQU5BWm9uZSIsImNyZWF0ZSIsIm5hbWUiLCJyZXNldENhY2hlIiwiaXNWYWxpZFNwZWNpZmllciIsInMiLCJtYXRjaCIsImlzVmFsaWRab25lIiwiZSIsInBhcnNlR01UT2Zmc2V0Iiwic3BlY2lmaWVyIiwiY29uc3RydWN0b3IiLCJ6b25lTmFtZSIsInZhbGlkIiwidW5pdmVyc2FsIiwib2Zmc2V0TmFtZSIsInRzIiwibG9jYWxlIiwib2Zmc2V0IiwiRGF0ZSIsImlzTmFOIiwiTmFOIiwiYWRqdXN0ZWRIb3VyIiwiYXNVVEMiLCJtaWxsaXNlY29uZCIsImFzVFMiLCJvdmVyIiwiZXF1YWxzIiwib3RoZXJab25lIiwiaXNWYWxpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/zones/IANAZone.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/zones/fixedOffsetZone.js":
/*!*********************************************************!*\
  !*** ./node_modules/luxon/src/zones/fixedOffsetZone.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FixedOffsetZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../impl/util.js */ \"(rsc)/./node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../zone.js */ \"(rsc)/./node_modules/luxon/src/zone.js\");\n\n\nlet singleton = null;\n/**\n * A zone with a fixed offset (meaning no DST)\n * @implements {Zone}\n */ class FixedOffsetZone extends _zone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\n   * Get a singleton instance of UTC\n   * @return {FixedOffsetZone}\n   */ static get utcInstance() {\n        if (singleton === null) {\n            singleton = new FixedOffsetZone(0);\n        }\n        return singleton;\n    }\n    /**\n   * Get an instance with a specified offset\n   * @param {number} offset - The offset in minutes\n   * @return {FixedOffsetZone}\n   */ static instance(offset) {\n        return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);\n    }\n    /**\n   * Get an instance of FixedOffsetZone from a UTC offset string, like \"UTC+6\"\n   * @param {string} s - The offset string to parse\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+6\")\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+06\")\n   * @example FixedOffsetZone.parseSpecifier(\"UTC-6:00\")\n   * @return {FixedOffsetZone}\n   */ static parseSpecifier(s) {\n        if (s) {\n            const r = s.match(/^utc(?:([+-]\\d{1,2})(?::(\\d{2}))?)?$/i);\n            if (r) {\n                return new FixedOffsetZone((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_1__.signedOffset)(r[1], r[2]));\n            }\n        }\n        return null;\n    }\n    constructor(offset){\n        super();\n        /** @private **/ this.fixed = offset;\n    }\n    /** @override **/ get type() {\n        return \"fixed\";\n    }\n    /** @override **/ get name() {\n        return this.fixed === 0 ? \"UTC\" : `UTC${(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_1__.formatOffset)(this.fixed, \"narrow\")}`;\n    }\n    /** @override **/ offsetName() {\n        return this.name;\n    }\n    /** @override **/ formatOffset(ts, format) {\n        return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_1__.formatOffset)(this.fixed, format);\n    }\n    /** @override **/ get universal() {\n        return true;\n    }\n    /** @override **/ offset() {\n        return this.fixed;\n    }\n    /** @override **/ equals(otherZone) {\n        return otherZone.type === \"fixed\" && otherZone.fixed === this.fixed;\n    }\n    /** @override **/ get isValid() {\n        return true;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkQ7QUFDL0I7QUFFOUIsSUFBSUcsWUFBWTtBQUVoQjs7O0NBR0MsR0FDYyxNQUFNQyx3QkFBd0JGLGdEQUFJQTtJQUMvQzs7O0dBR0MsR0FDRCxXQUFXRyxjQUFjO1FBQ3ZCLElBQUlGLGNBQWMsTUFBTTtZQUN0QkEsWUFBWSxJQUFJQyxnQkFBZ0I7UUFDbEM7UUFDQSxPQUFPRDtJQUNUO0lBRUE7Ozs7R0FJQyxHQUNELE9BQU9HLFNBQVNDLE1BQU0sRUFBRTtRQUN0QixPQUFPQSxXQUFXLElBQUlILGdCQUFnQkMsV0FBVyxHQUFHLElBQUlELGdCQUFnQkc7SUFDMUU7SUFFQTs7Ozs7OztHQU9DLEdBQ0QsT0FBT0MsZUFBZUMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUlBLEdBQUc7WUFDTCxNQUFNQyxJQUFJRCxFQUFFRSxLQUFLLENBQUM7WUFDbEIsSUFBSUQsR0FBRztnQkFDTCxPQUFPLElBQUlOLGdCQUFnQkgsMkRBQVlBLENBQUNTLENBQUMsQ0FBQyxFQUFFLEVBQUVBLENBQUMsQ0FBQyxFQUFFO1lBQ3BEO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFFQUUsWUFBWUwsTUFBTSxDQUFFO1FBQ2xCLEtBQUs7UUFDTCxjQUFjLEdBQ2QsSUFBSSxDQUFDTSxLQUFLLEdBQUdOO0lBQ2Y7SUFFQSxlQUFlLEdBQ2YsSUFBSU8sT0FBTztRQUNULE9BQU87SUFDVDtJQUVBLGVBQWUsR0FDZixJQUFJQyxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUNGLEtBQUssS0FBSyxJQUFJLFFBQVEsQ0FBQyxHQUFHLEVBQUViLDJEQUFZQSxDQUFDLElBQUksQ0FBQ2EsS0FBSyxFQUFFLFVBQVUsQ0FBQztJQUM5RTtJQUVBLGVBQWUsR0FDZkcsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDRCxJQUFJO0lBQ2xCO0lBRUEsZUFBZSxHQUNmZixhQUFhaUIsRUFBRSxFQUFFQyxNQUFNLEVBQUU7UUFDdkIsT0FBT2xCLDJEQUFZQSxDQUFDLElBQUksQ0FBQ2EsS0FBSyxFQUFFSztJQUNsQztJQUVBLGVBQWUsR0FDZixJQUFJQyxZQUFZO1FBQ2QsT0FBTztJQUNUO0lBRUEsZUFBZSxHQUNmWixTQUFTO1FBQ1AsT0FBTyxJQUFJLENBQUNNLEtBQUs7SUFDbkI7SUFFQSxlQUFlLEdBQ2ZPLE9BQU9DLFNBQVMsRUFBRTtRQUNoQixPQUFPQSxVQUFVUCxJQUFJLEtBQUssV0FBV08sVUFBVVIsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSztJQUNyRTtJQUVBLGVBQWUsR0FDZixJQUFJUyxVQUFVO1FBQ1osT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pYXRvb2xzLW5leHQvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qcz9lYTE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcm1hdE9mZnNldCwgc2lnbmVkT2Zmc2V0IH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5cbi8qKlxuICogQSB6b25lIHdpdGggYSBmaXhlZCBvZmZzZXQgKG1lYW5pbmcgbm8gRFNUKVxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeGVkT2Zmc2V0Wm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIFVUQ1xuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHV0Y0luc3RhbmNlKCkge1xuICAgIGlmIChzaW5nbGV0b24gPT09IG51bGwpIHtcbiAgICAgIHNpbmdsZXRvbiA9IG5ldyBGaXhlZE9mZnNldFpvbmUoMCk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGV0b247XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpZWQgb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGluIG1pbnV0ZXNcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIGluc3RhbmNlKG9mZnNldCkge1xuICAgIHJldHVybiBvZmZzZXQgPT09IDAgPyBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2UgOiBuZXcgRml4ZWRPZmZzZXRab25lKG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIGEgVVRDIG9mZnNldCBzdHJpbmcsIGxpa2UgXCJVVEMrNlwiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIC0gVGhlIG9mZnNldCBzdHJpbmcgdG8gcGFyc2VcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzA2XCIpXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQy02OjAwXCIpXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBwYXJzZVNwZWNpZmllcihzKSB7XG4gICAgaWYgKHMpIHtcbiAgICAgIGNvbnN0IHIgPSBzLm1hdGNoKC9edXRjKD86KFsrLV1cXGR7MSwyfSkoPzo6KFxcZHsyfSkpPyk/JC9pKTtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWRPZmZzZXRab25lKHNpZ25lZE9mZnNldChyWzFdLCByWzJdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob2Zmc2V0KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy5maXhlZCA9IG9mZnNldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImZpeGVkXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZCA9PT0gMCA/IFwiVVRDXCIgOiBgVVRDJHtmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgXCJuYXJyb3dcIil9YDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLmZpeGVkLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHVuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwiZml4ZWRcIiAmJiBvdGhlclpvbmUuZml4ZWQgPT09IHRoaXMuZml4ZWQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImZvcm1hdE9mZnNldCIsInNpZ25lZE9mZnNldCIsIlpvbmUiLCJzaW5nbGV0b24iLCJGaXhlZE9mZnNldFpvbmUiLCJ1dGNJbnN0YW5jZSIsImluc3RhbmNlIiwib2Zmc2V0IiwicGFyc2VTcGVjaWZpZXIiLCJzIiwiciIsIm1hdGNoIiwiY29uc3RydWN0b3IiLCJmaXhlZCIsInR5cGUiLCJuYW1lIiwib2Zmc2V0TmFtZSIsInRzIiwiZm9ybWF0IiwidW5pdmVyc2FsIiwiZXF1YWxzIiwib3RoZXJab25lIiwiaXNWYWxpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/zones/fixedOffsetZone.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/zones/invalidZone.js":
/*!*****************************************************!*\
  !*** ./node_modules/luxon/src/zones/invalidZone.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ InvalidZone)\n/* harmony export */ });\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../zone.js */ \"(rsc)/./node_modules/luxon/src/zone.js\");\n\n/**\n * A zone that failed to parse. You should never need to instantiate this.\n * @implements {Zone}\n */ class InvalidZone extends _zone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(zoneName){\n        super();\n        /**  @private */ this.zoneName = zoneName;\n    }\n    /** @override **/ get type() {\n        return \"invalid\";\n    }\n    /** @override **/ get name() {\n        return this.zoneName;\n    }\n    /** @override **/ get universal() {\n        return false;\n    }\n    /** @override **/ offsetName() {\n        return null;\n    }\n    /** @override **/ formatOffset() {\n        return \"\";\n    }\n    /** @override **/ offset() {\n        return NaN;\n    }\n    /** @override **/ equals() {\n        return false;\n    }\n    /** @override **/ get isValid() {\n        return false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ludmFsaWRab25lLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThCO0FBRTlCOzs7Q0FHQyxHQUNjLE1BQU1DLG9CQUFvQkQsZ0RBQUlBO0lBQzNDRSxZQUFZQyxRQUFRLENBQUU7UUFDcEIsS0FBSztRQUNMLGNBQWMsR0FDZCxJQUFJLENBQUNBLFFBQVEsR0FBR0E7SUFDbEI7SUFFQSxlQUFlLEdBQ2YsSUFBSUMsT0FBTztRQUNULE9BQU87SUFDVDtJQUVBLGVBQWUsR0FDZixJQUFJQyxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUNGLFFBQVE7SUFDdEI7SUFFQSxlQUFlLEdBQ2YsSUFBSUcsWUFBWTtRQUNkLE9BQU87SUFDVDtJQUVBLGVBQWUsR0FDZkMsYUFBYTtRQUNYLE9BQU87SUFDVDtJQUVBLGVBQWUsR0FDZkMsZUFBZTtRQUNiLE9BQU87SUFDVDtJQUVBLGVBQWUsR0FDZkMsU0FBUztRQUNQLE9BQU9DO0lBQ1Q7SUFFQSxlQUFlLEdBQ2ZDLFNBQVM7UUFDUCxPQUFPO0lBQ1Q7SUFFQSxlQUFlLEdBQ2YsSUFBSUMsVUFBVTtRQUNaLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWF0b29scy1uZXh0Ly4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9pbnZhbGlkWm9uZS5qcz85MWU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbi8qKlxuICogQSB6b25lIHRoYXQgZmFpbGVkIHRvIHBhcnNlLiBZb3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZhbGlkWm9uZSBleHRlbmRzIFpvbmUge1xuICBjb25zdHJ1Y3Rvcih6b25lTmFtZSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqICBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuem9uZU5hbWUgPSB6b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImludmFsaWRcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHVuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXSwibmFtZXMiOlsiWm9uZSIsIkludmFsaWRab25lIiwiY29uc3RydWN0b3IiLCJ6b25lTmFtZSIsInR5cGUiLCJuYW1lIiwidW5pdmVyc2FsIiwib2Zmc2V0TmFtZSIsImZvcm1hdE9mZnNldCIsIm9mZnNldCIsIk5hTiIsImVxdWFscyIsImlzVmFsaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/zones/invalidZone.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/luxon/src/zones/localZone.js":
/*!***************************************************!*\
  !*** ./node_modules/luxon/src/zones/localZone.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LocalZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../impl/util.js */ \"(rsc)/./node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../zone.js */ \"(rsc)/./node_modules/luxon/src/zone.js\");\n\n\nlet singleton = null;\n/**\n * Represents the local zone for this JavaScript environment.\n * @implements {Zone}\n */ class LocalZone extends _zone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\n   * Get a singleton instance of the local zone\n   * @return {LocalZone}\n   */ static get instance() {\n        if (singleton === null) {\n            singleton = new LocalZone();\n        }\n        return singleton;\n    }\n    /** @override **/ get type() {\n        return \"local\";\n    }\n    /** @override **/ get name() {\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_1__.hasIntl)()) {\n            return new Intl.DateTimeFormat().resolvedOptions().timeZone;\n        } else return \"local\";\n    }\n    /** @override **/ get universal() {\n        return false;\n    }\n    /** @override **/ offsetName(ts, { format, locale }) {\n        return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_1__.parseZoneInfo)(ts, format, locale);\n    }\n    /** @override **/ formatOffset(ts, format) {\n        return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_1__.formatOffset)(this.offset(ts), format);\n    }\n    /** @override **/ offset(ts) {\n        return -new Date(ts).getTimezoneOffset();\n    }\n    /** @override **/ equals(otherZone) {\n        return otherZone.type === \"local\";\n    }\n    /** @override **/ get isValid() {\n        return true;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2xvY2FsWm9uZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUU7QUFDekM7QUFFOUIsSUFBSUksWUFBWTtBQUVoQjs7O0NBR0MsR0FDYyxNQUFNQyxrQkFBa0JGLGdEQUFJQTtJQUN6Qzs7O0dBR0MsR0FDRCxXQUFXRyxXQUFXO1FBQ3BCLElBQUlGLGNBQWMsTUFBTTtZQUN0QkEsWUFBWSxJQUFJQztRQUNsQjtRQUNBLE9BQU9EO0lBQ1Q7SUFFQSxlQUFlLEdBQ2YsSUFBSUcsT0FBTztRQUNULE9BQU87SUFDVDtJQUVBLGVBQWUsR0FDZixJQUFJQyxPQUFPO1FBQ1QsSUFBSU4sc0RBQU9BLElBQUk7WUFDYixPQUFPLElBQUlPLEtBQUtDLGNBQWMsR0FBR0MsZUFBZSxHQUFHQyxRQUFRO1FBQzdELE9BQU8sT0FBTztJQUNoQjtJQUVBLGVBQWUsR0FDZixJQUFJQyxZQUFZO1FBQ2QsT0FBTztJQUNUO0lBRUEsZUFBZSxHQUNmQyxXQUFXQyxFQUFFLEVBQUUsRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUUsRUFBRTtRQUNqQyxPQUFPaEIsNERBQWFBLENBQUNjLElBQUlDLFFBQVFDO0lBQ25DO0lBRUEsZUFBZSxHQUNmakIsYUFBYWUsRUFBRSxFQUFFQyxNQUFNLEVBQUU7UUFDdkIsT0FBT2hCLDJEQUFZQSxDQUFDLElBQUksQ0FBQ2tCLE1BQU0sQ0FBQ0gsS0FBS0M7SUFDdkM7SUFFQSxlQUFlLEdBQ2ZFLE9BQU9ILEVBQUUsRUFBRTtRQUNULE9BQU8sQ0FBQyxJQUFJSSxLQUFLSixJQUFJSyxpQkFBaUI7SUFDeEM7SUFFQSxlQUFlLEdBQ2ZDLE9BQU9DLFNBQVMsRUFBRTtRQUNoQixPQUFPQSxVQUFVZixJQUFJLEtBQUs7SUFDNUI7SUFFQSxlQUFlLEdBQ2YsSUFBSWdCLFVBQVU7UUFDWixPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2lhdG9vbHMtbmV4dC8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvbG9jYWxab25lLmpzPzliMjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBwYXJzZVpvbmVJbmZvLCBoYXNJbnRsIH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbG9jYWwgem9uZSBmb3IgdGhpcyBKYXZhU2NyaXB0IGVudmlyb25tZW50LlxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvY2FsWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBsb2NhbCB6b25lXG4gICAqIEByZXR1cm4ge0xvY2FsWm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgaW5zdGFuY2UoKSB7XG4gICAgaWYgKHNpbmdsZXRvbiA9PT0gbnVsbCkge1xuICAgICAgc2luZ2xldG9uID0gbmV3IExvY2FsWm9uZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xldG9uO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwibG9jYWxcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIGlmIChoYXNJbnRsKCkpIHtcbiAgICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xuICAgIH0gZWxzZSByZXR1cm4gXCJsb2NhbFwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHVuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKHRzLCB7IGZvcm1hdCwgbG9jYWxlIH0pIHtcbiAgICByZXR1cm4gcGFyc2Vab25lSW5mbyh0cywgZm9ybWF0LCBsb2NhbGUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCh0cykge1xuICAgIHJldHVybiAtbmV3IERhdGUodHMpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImxvY2FsXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImZvcm1hdE9mZnNldCIsInBhcnNlWm9uZUluZm8iLCJoYXNJbnRsIiwiWm9uZSIsInNpbmdsZXRvbiIsIkxvY2FsWm9uZSIsImluc3RhbmNlIiwidHlwZSIsIm5hbWUiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJyZXNvbHZlZE9wdGlvbnMiLCJ0aW1lWm9uZSIsInVuaXZlcnNhbCIsIm9mZnNldE5hbWUiLCJ0cyIsImZvcm1hdCIsImxvY2FsZSIsIm9mZnNldCIsIkRhdGUiLCJnZXRUaW1lem9uZU9mZnNldCIsImVxdWFscyIsIm90aGVyWm9uZSIsImlzVmFsaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/luxon/src/zones/localZone.js\n");

/***/ })

};
;