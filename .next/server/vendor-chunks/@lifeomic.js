"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lifeomic";
exports.ids = ["vendor-chunks/@lifeomic"];
exports.modules = {

/***/ "(rsc)/./node_modules/@lifeomic/attempt/dist/es6/src/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lifeomic/attempt/dist/es6/src/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultCalculateDelay: () => (/* binding */ defaultCalculateDelay),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\nfunction applyDefaults(options) {\n    if (!options) {\n        options = {};\n    }\n    return {\n        delay: options.delay === undefined ? 200 : options.delay,\n        initialDelay: options.initialDelay === undefined ? 0 : options.initialDelay,\n        minDelay: options.minDelay === undefined ? 0 : options.minDelay,\n        maxDelay: options.maxDelay === undefined ? 0 : options.maxDelay,\n        factor: options.factor === undefined ? 0 : options.factor,\n        maxAttempts: options.maxAttempts === undefined ? 3 : options.maxAttempts,\n        timeout: options.timeout === undefined ? 0 : options.timeout,\n        jitter: options.jitter === true,\n        initialJitter: options.initialJitter === true,\n        handleError: options.handleError === undefined ? null : options.handleError,\n        handleTimeout: options.handleTimeout === undefined ? null : options.handleTimeout,\n        beforeAttempt: options.beforeAttempt === undefined ? null : options.beforeAttempt,\n        calculateDelay: options.calculateDelay === undefined ? null : options.calculateDelay\n    };\n}\nasync function sleep(delay) {\n    return new Promise((resolve)=>setTimeout(resolve, delay));\n}\nfunction defaultCalculateDelay(context, options) {\n    let delay = options.delay;\n    if (delay === 0) {\n        // no delay between attempts\n        return 0;\n    }\n    if (options.factor) {\n        delay *= Math.pow(options.factor, context.attemptNum - 1);\n        if (options.maxDelay !== 0) {\n            delay = Math.min(delay, options.maxDelay);\n        }\n    }\n    if (options.jitter) {\n        // Jitter will result in a random value between `minDelay` and\n        // calculated delay for a given attempt.\n        // See https://www.awsarchitectureblog.com/2015/03/backoff.html\n        // We're using the \"full jitter\" strategy.\n        const min = Math.ceil(options.minDelay);\n        const max = Math.floor(delay);\n        delay = Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return Math.round(delay);\n}\nasync function retry(attemptFunc, attemptOptions) {\n    const options = applyDefaults(attemptOptions);\n    for (const prop of [\n        \"delay\",\n        \"initialDelay\",\n        \"minDelay\",\n        \"maxDelay\",\n        \"maxAttempts\",\n        \"timeout\"\n    ]){\n        const value = options[prop];\n        if (!Number.isInteger(value) || value < 0) {\n            throw new Error(`Value for ${prop} must be an integer greater than or equal to 0`);\n        }\n    }\n    if (options.factor.constructor !== Number || options.factor < 0) {\n        throw new Error(`Value for factor must be a number greater than or equal to 0`);\n    }\n    if (options.delay < options.minDelay) {\n        throw new Error(`delay cannot be less than minDelay (delay: ${options.delay}, minDelay: ${options.minDelay}`);\n    }\n    const context = {\n        attemptNum: 0,\n        attemptsRemaining: options.maxAttempts ? options.maxAttempts : -1,\n        aborted: false,\n        abort () {\n            context.aborted = true;\n        }\n    };\n    const calculateDelay = options.calculateDelay || defaultCalculateDelay;\n    async function makeAttempt() {\n        if (options.beforeAttempt) {\n            options.beforeAttempt(context, options);\n        }\n        if (context.aborted) {\n            const err = new Error(`Attempt aborted`);\n            err.code = \"ATTEMPT_ABORTED\";\n            throw err;\n        }\n        const onError = async (err)=>{\n            if (options.handleError) {\n                await options.handleError(err, context, options);\n            }\n            if (context.aborted || context.attemptsRemaining === 0) {\n                throw err;\n            }\n            // We are about to try again so increment attempt number\n            context.attemptNum++;\n            const delay = calculateDelay(context, options);\n            if (delay) {\n                await sleep(delay);\n            }\n            return makeAttempt();\n        };\n        if (context.attemptsRemaining > 0) {\n            context.attemptsRemaining--;\n        }\n        if (options.timeout) {\n            return new Promise((resolve, reject)=>{\n                const timer = setTimeout(()=>{\n                    if (options.handleTimeout) {\n                        // If calling handleTimeout throws an error that is not wrapped in a promise\n                        // we want to catch the error and reject.\n                        try {\n                            resolve(options.handleTimeout(context, options));\n                        } catch (e) {\n                            reject(e);\n                        }\n                    } else {\n                        const err = new Error(`Retry timeout (attemptNum: ${context.attemptNum}, timeout: ${options.timeout})`);\n                        err.code = \"ATTEMPT_TIMEOUT\";\n                        reject(err);\n                    }\n                }, options.timeout);\n                attemptFunc(context, options).then((result)=>{\n                    clearTimeout(timer);\n                    resolve(result);\n                }).catch((err)=>{\n                    clearTimeout(timer);\n                    // Calling resolve with a Promise that rejects here will result\n                    // in an unhandled rejection. Calling `reject` with errors\n                    // does not result in an unhandled rejection\n                    onError(err).then(resolve).catch(reject);\n                });\n            });\n        } else {\n            // No timeout provided so wait indefinitely for the returned promise\n            // to be resolved.\n            return attemptFunc(context, options).catch(onError);\n        }\n    }\n    const initialDelay = options.calculateDelay ? options.calculateDelay(context, options) : options.initialDelay;\n    if (initialDelay) {\n        await sleep(initialDelay);\n    }\n    if (context.attemptNum < 1 && options.initialJitter) {\n        const delay = calculateDelay(context, options);\n        if (delay) {\n            await sleep(delay);\n        }\n    }\n    return makeAttempt();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxpZmVvbWljL2F0dGVtcHQvZGlzdC9lczYvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLFNBQVNBLGNBQWNDLE9BQU87SUFDMUIsSUFBSSxDQUFDQSxTQUFTO1FBQ1ZBLFVBQVUsQ0FBQztJQUNmO0lBQ0EsT0FBTztRQUNIQyxPQUFPLFFBQVNBLEtBQUssS0FBS0MsWUFBYSxNQUFNRixRQUFRQyxLQUFLO1FBQzFERSxjQUFjLFFBQVNBLFlBQVksS0FBS0QsWUFBYSxJQUFJRixRQUFRRyxZQUFZO1FBQzdFQyxVQUFVLFFBQVNBLFFBQVEsS0FBS0YsWUFBYSxJQUFJRixRQUFRSSxRQUFRO1FBQ2pFQyxVQUFVLFFBQVNBLFFBQVEsS0FBS0gsWUFBYSxJQUFJRixRQUFRSyxRQUFRO1FBQ2pFQyxRQUFRLFFBQVNBLE1BQU0sS0FBS0osWUFBYSxJQUFJRixRQUFRTSxNQUFNO1FBQzNEQyxhQUFhLFFBQVNBLFdBQVcsS0FBS0wsWUFBYSxJQUFJRixRQUFRTyxXQUFXO1FBQzFFQyxTQUFTLFFBQVNBLE9BQU8sS0FBS04sWUFBYSxJQUFJRixRQUFRUSxPQUFPO1FBQzlEQyxRQUFTVCxRQUFRUyxNQUFNLEtBQUs7UUFDNUJDLGVBQWdCVixRQUFRVSxhQUFhLEtBQUs7UUFDMUNDLGFBQWEsUUFBU0EsV0FBVyxLQUFLVCxZQUFhLE9BQU9GLFFBQVFXLFdBQVc7UUFDN0VDLGVBQWUsUUFBU0EsYUFBYSxLQUFLVixZQUFhLE9BQU9GLFFBQVFZLGFBQWE7UUFDbkZDLGVBQWUsUUFBU0EsYUFBYSxLQUFLWCxZQUFhLE9BQU9GLFFBQVFhLGFBQWE7UUFDbkZDLGdCQUFnQixRQUFTQSxjQUFjLEtBQUtaLFlBQWEsT0FBT0YsUUFBUWMsY0FBYztJQUMxRjtBQUNKO0FBQ08sZUFBZUMsTUFBTWQsS0FBSztJQUM3QixPQUFPLElBQUllLFFBQVEsQ0FBQ0MsVUFBWUMsV0FBV0QsU0FBU2hCO0FBQ3hEO0FBQ08sU0FBU2tCLHNCQUFz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RUFBRTtRQUNqRCxNQUFNVCxRQUFRYSxlQUFlTSxTQUFTcEI7UUFDdEMsSUFBSUMsT0FBTztZQUNQLE1BQU1jLE1BQU1kO1FBQ2hCO0lBQ0o7SUFDQSxPQUFPeUM7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2lhdG9vbHMtbmV4dC8uL25vZGVfbW9kdWxlcy9AbGlmZW9taWMvYXR0ZW1wdC9kaXN0L2VzNi9zcmMvaW5kZXguanM/MmRlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhcHBseURlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheTogKG9wdGlvbnMuZGVsYXkgPT09IHVuZGVmaW5lZCkgPyAyMDAgOiBvcHRpb25zLmRlbGF5LFxuICAgICAgICBpbml0aWFsRGVsYXk6IChvcHRpb25zLmluaXRpYWxEZWxheSA9PT0gdW5kZWZpbmVkKSA/IDAgOiBvcHRpb25zLmluaXRpYWxEZWxheSxcbiAgICAgICAgbWluRGVsYXk6IChvcHRpb25zLm1pbkRlbGF5ID09PSB1bmRlZmluZWQpID8gMCA6IG9wdGlvbnMubWluRGVsYXksXG4gICAgICAgIG1heERlbGF5OiAob3B0aW9ucy5tYXhEZWxheSA9PT0gdW5kZWZpbmVkKSA/IDAgOiBvcHRpb25zLm1heERlbGF5LFxuICAgICAgICBmYWN0b3I6IChvcHRpb25zLmZhY3RvciA9PT0gdW5kZWZpbmVkKSA/IDAgOiBvcHRpb25zLmZhY3RvcixcbiAgICAgICAgbWF4QXR0ZW1wdHM6IChvcHRpb25zLm1heEF0dGVtcHRzID09PSB1bmRlZmluZWQpID8gMyA6IG9wdGlvbnMubWF4QXR0ZW1wdHMsXG4gICAgICAgIHRpbWVvdXQ6IChvcHRpb25zLnRpbWVvdXQgPT09IHVuZGVmaW5lZCkgPyAwIDogb3B0aW9ucy50aW1lb3V0LFxuICAgICAgICBqaXR0ZXI6IChvcHRpb25zLmppdHRlciA9PT0gdHJ1ZSksXG4gICAgICAgIGluaXRpYWxKaXR0ZXI6IChvcHRpb25zLmluaXRpYWxKaXR0ZXIgPT09IHRydWUpLFxuICAgICAgICBoYW5kbGVFcnJvcjogKG9wdGlvbnMuaGFuZGxlRXJyb3IgPT09IHVuZGVmaW5lZCkgPyBudWxsIDogb3B0aW9ucy5oYW5kbGVFcnJvcixcbiAgICAgICAgaGFuZGxlVGltZW91dDogKG9wdGlvbnMuaGFuZGxlVGltZW91dCA9PT0gdW5kZWZpbmVkKSA/IG51bGwgOiBvcHRpb25zLmhhbmRsZVRpbWVvdXQsXG4gICAgICAgIGJlZm9yZUF0dGVtcHQ6IChvcHRpb25zLmJlZm9yZUF0dGVtcHQgPT09IHVuZGVmaW5lZCkgPyBudWxsIDogb3B0aW9ucy5iZWZvcmVBdHRlbXB0LFxuICAgICAgICBjYWxjdWxhdGVEZWxheTogKG9wdGlvbnMuY2FsY3VsYXRlRGVsYXkgPT09IHVuZGVmaW5lZCkgPyBudWxsIDogb3B0aW9ucy5jYWxjdWxhdGVEZWxheVxuICAgIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2xlZXAoZGVsYXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0Q2FsY3VsYXRlRGVsYXkoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGxldCBkZWxheSA9IG9wdGlvbnMuZGVsYXk7XG4gICAgaWYgKGRlbGF5ID09PSAwKSB7XG4gICAgICAgIC8vIG5vIGRlbGF5IGJldHdlZW4gYXR0ZW1wdHNcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZhY3Rvcikge1xuICAgICAgICBkZWxheSAqPSBNYXRoLnBvdyhvcHRpb25zLmZhY3RvciwgY29udGV4dC5hdHRlbXB0TnVtIC0gMSk7XG4gICAgICAgIGlmIChvcHRpb25zLm1heERlbGF5ICE9PSAwKSB7XG4gICAgICAgICAgICBkZWxheSA9IE1hdGgubWluKGRlbGF5LCBvcHRpb25zLm1heERlbGF5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5qaXR0ZXIpIHtcbiAgICAgICAgLy8gSml0dGVyIHdpbGwgcmVzdWx0IGluIGEgcmFuZG9tIHZhbHVlIGJldHdlZW4gYG1pbkRlbGF5YCBhbmRcbiAgICAgICAgLy8gY2FsY3VsYXRlZCBkZWxheSBmb3IgYSBnaXZlbiBhdHRlbXB0LlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly93d3cuYXdzYXJjaGl0ZWN0dXJlYmxvZy5jb20vMjAxNS8wMy9iYWNrb2ZmLmh0bWxcbiAgICAgICAgLy8gV2UncmUgdXNpbmcgdGhlIFwiZnVsbCBqaXR0ZXJcIiBzdHJhdGVneS5cbiAgICAgICAgY29uc3QgbWluID0gTWF0aC5jZWlsKG9wdGlvbnMubWluRGVsYXkpO1xuICAgICAgICBjb25zdCBtYXggPSBNYXRoLmZsb29yKGRlbGF5KTtcbiAgICAgICAgZGVsYXkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5yb3VuZChkZWxheSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV0cnkoYXR0ZW1wdEZ1bmMsIGF0dGVtcHRPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdHMoYXR0ZW1wdE9wdGlvbnMpO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBbXG4gICAgICAgICdkZWxheScsXG4gICAgICAgICdpbml0aWFsRGVsYXknLFxuICAgICAgICAnbWluRGVsYXknLFxuICAgICAgICAnbWF4RGVsYXknLFxuICAgICAgICAnbWF4QXR0ZW1wdHMnLFxuICAgICAgICAndGltZW91dCdcbiAgICBdKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1twcm9wXTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCAodmFsdWUgPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBmb3IgJHtwcm9wfSBtdXN0IGJlIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDBgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoKG9wdGlvbnMuZmFjdG9yLmNvbnN0cnVjdG9yICE9PSBOdW1iZXIpIHx8IChvcHRpb25zLmZhY3RvciA8IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgZm9yIGZhY3RvciBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwYCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRlbGF5IDwgb3B0aW9ucy5taW5EZWxheSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRlbGF5IGNhbm5vdCBiZSBsZXNzIHRoYW4gbWluRGVsYXkgKGRlbGF5OiAke29wdGlvbnMuZGVsYXl9LCBtaW5EZWxheTogJHtvcHRpb25zLm1pbkRlbGF5fWApO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBhdHRlbXB0TnVtOiAwLFxuICAgICAgICBhdHRlbXB0c1JlbWFpbmluZzogb3B0aW9ucy5tYXhBdHRlbXB0cyA/IG9wdGlvbnMubWF4QXR0ZW1wdHMgOiAtMSxcbiAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgIGFib3J0KCkge1xuICAgICAgICAgICAgY29udGV4dC5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2FsY3VsYXRlRGVsYXkgPSBvcHRpb25zLmNhbGN1bGF0ZURlbGF5IHx8IGRlZmF1bHRDYWxjdWxhdGVEZWxheTtcbiAgICBhc3luYyBmdW5jdGlvbiBtYWtlQXR0ZW1wdCgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYmVmb3JlQXR0ZW1wdCkge1xuICAgICAgICAgICAgb3B0aW9ucy5iZWZvcmVBdHRlbXB0KGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgQXR0ZW1wdCBhYm9ydGVkYCk7XG4gICAgICAgICAgICBlcnIuY29kZSA9ICdBVFRFTVBUX0FCT1JURUQnO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSBhc3luYyAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVFcnJvcikge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9wdGlvbnMuaGFuZGxlRXJyb3IoZXJyLCBjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZXh0LmFib3J0ZWQgfHwgKGNvbnRleHQuYXR0ZW1wdHNSZW1haW5pbmcgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgYXJlIGFib3V0IHRvIHRyeSBhZ2FpbiBzbyBpbmNyZW1lbnQgYXR0ZW1wdCBudW1iZXJcbiAgICAgICAgICAgIGNvbnRleHQuYXR0ZW1wdE51bSsrO1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBjYWxjdWxhdGVEZWxheShjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlQXR0ZW1wdCgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY29udGV4dC5hdHRlbXB0c1JlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQuYXR0ZW1wdHNSZW1haW5pbmctLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhhbmRsZVRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGNhbGxpbmcgaGFuZGxlVGltZW91dCB0aHJvd3MgYW4gZXJyb3IgdGhhdCBpcyBub3Qgd3JhcHBlZCBpbiBhIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gY2F0Y2ggdGhlIGVycm9yIGFuZCByZWplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3B0aW9ucy5oYW5kbGVUaW1lb3V0KGNvbnRleHQsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBSZXRyeSB0aW1lb3V0IChhdHRlbXB0TnVtOiAke2NvbnRleHQuYXR0ZW1wdE51bX0sIHRpbWVvdXQ6ICR7b3B0aW9ucy50aW1lb3V0fSlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gJ0FUVEVNUFRfVElNRU9VVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdEZ1bmMoY29udGV4dCwgb3B0aW9ucykudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGxpbmcgcmVzb2x2ZSB3aXRoIGEgUHJvbWlzZSB0aGF0IHJlamVjdHMgaGVyZSB3aWxsIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uLiBDYWxsaW5nIGByZWplY3RgIHdpdGggZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IHJlc3VsdCBpbiBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIHRpbWVvdXQgcHJvdmlkZWQgc28gd2FpdCBpbmRlZmluaXRlbHkgZm9yIHRoZSByZXR1cm5lZCBwcm9taXNlXG4gICAgICAgICAgICAvLyB0byBiZSByZXNvbHZlZC5cbiAgICAgICAgICAgIHJldHVybiBhdHRlbXB0RnVuYyhjb250ZXh0LCBvcHRpb25zKS5jYXRjaChvbkVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbml0aWFsRGVsYXkgPSBvcHRpb25zLmNhbGN1bGF0ZURlbGF5XG4gICAgICAgID8gb3B0aW9ucy5jYWxjdWxhdGVEZWxheShjb250ZXh0LCBvcHRpb25zKVxuICAgICAgICA6IG9wdGlvbnMuaW5pdGlhbERlbGF5O1xuICAgIGlmIChpbml0aWFsRGVsYXkpIHtcbiAgICAgICAgYXdhaXQgc2xlZXAoaW5pdGlhbERlbGF5KTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuYXR0ZW1wdE51bSA8IDEgJiYgb3B0aW9ucy5pbml0aWFsSml0dGVyKSB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gY2FsY3VsYXRlRGVsYXkoY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoZGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYWtlQXR0ZW1wdCgpO1xufVxuIl0sIm5hbWVzIjpbImFwcGx5RGVmYXVsdHMiLCJvcHRpb25zIiwiZGVsYXkiLCJ1bmRlZmluZWQiLCJpbml0aWFsRGVsYXkiLCJtaW5EZWxheSIsIm1heERlbGF5IiwiZmFjdG9yIiwibWF4QXR0ZW1wdHMiLCJ0aW1lb3V0Iiwiaml0dGVyIiwiaW5pdGlhbEppdHRlciIsImhhbmRsZUVycm9yIiwiaGFuZGxlVGltZW91dCIsImJlZm9yZUF0dGVtcHQiLCJjYWxjdWxhdGVEZWxheSIsInNsZWVwIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZGVmYXVsdENhbGN1bGF0ZURlbGF5IiwiY29udGV4dCIsIk1hdGgiLCJwb3ciLCJhdHRlbXB0TnVtIiwibWluIiwiY2VpbCIsIm1heCIsImZsb29yIiwicmFuZG9tIiwicm91bmQiLCJyZXRyeSIsImF0dGVtcHRGdW5jIiwiYXR0ZW1wdE9wdGlvbnMiLCJwcm9wIiwidmFsdWUiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiYXR0ZW1wdHNSZW1haW5pbmciLCJhYm9ydGVkIiwiYWJvcnQiLCJtYWtlQXR0ZW1wdCIsImVyciIsImNvZGUiLCJvbkVycm9yIiwicmVqZWN0IiwidGltZXIiLCJlIiwidGhlbiIsInJlc3VsdCIsImNsZWFyVGltZW91dCIsImNhdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@lifeomic/attempt/dist/es6/src/index.js\n");

/***/ })

};
;