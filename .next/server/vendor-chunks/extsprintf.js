/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/extsprintf";
exports.ids = ["vendor-chunks/extsprintf"];
exports.modules = {

/***/ "(rsc)/./node_modules/extsprintf/lib/extsprintf.js":
/*!***************************************************!*\
  !*** ./node_modules/extsprintf/lib/extsprintf.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * extsprintf.js: extended POSIX-style sprintf\n */ var mod_assert = __webpack_require__(/*! assert */ \"assert\");\nvar mod_util = __webpack_require__(/*! util */ \"util\");\n/*\n * Public interface\n */ exports.sprintf = jsSprintf;\nexports.printf = jsPrintf;\nexports.fprintf = jsFprintf;\n/*\n * Stripped down version of s[n]printf(3c).  We make a best effort to throw an\n * exception when given a format string we don't understand, rather than\n * ignoring it, so that we won't break existing programs if/when we go implement\n * the rest of this.\n *\n * This implementation currently supports specifying\n *\t- field alignment ('-' flag),\n * \t- zero-pad ('0' flag)\n *\t- always show numeric sign ('+' flag),\n *\t- field width\n *\t- conversions for strings, decimal integers, and floats (numbers).\n *\t- argument size specifiers.  These are all accepted but ignored, since\n *\t  Javascript has no notion of the physical size of an argument.\n *\n * Everything else is currently unsupported, most notably precision, unsigned\n * numbers, non-decimal numbers, and characters.\n */ function jsSprintf(fmt) {\n    var regex = [\n        \"([^%]*)\",\n        /* normal text */ \"%\",\n        /* start of format */ \"(['\\\\-+ #0]*?)\",\n        /* flags (optional) */ \"([1-9]\\\\d*)?\",\n        /* width (optional) */ \"(\\\\.([1-9]\\\\d*))?\",\n        /* precision (optional) */ \"[lhjztL]*?\",\n        /* length mods (ignored) */ \"([diouxXfFeEgGaAcCsSp%jr])\" /* conversion */ \n    ].join(\"\");\n    var re = new RegExp(regex);\n    var args = Array.prototype.slice.call(arguments, 1);\n    var flags, width, precision, conversion;\n    var left, pad, sign, arg, match;\n    var ret = \"\";\n    var argn = 1;\n    mod_assert.equal(\"string\", typeof fmt);\n    while((match = re.exec(fmt)) !== null){\n        ret += match[1];\n        fmt = fmt.substring(match[0].length);\n        flags = match[2] || \"\";\n        width = match[3] || 0;\n        precision = match[4] || \"\";\n        conversion = match[6];\n        left = false;\n        sign = false;\n        pad = \" \";\n        if (conversion == \"%\") {\n            ret += \"%\";\n            continue;\n        }\n        if (args.length === 0) throw new Error(\"too few args to sprintf\");\n        arg = args.shift();\n        argn++;\n        if (flags.match(/[\\' #]/)) throw new Error(\"unsupported flags: \" + flags);\n        if (precision.length > 0) throw new Error(\"non-zero precision not supported\");\n        if (flags.match(/-/)) left = true;\n        if (flags.match(/0/)) pad = \"0\";\n        if (flags.match(/\\+/)) sign = true;\n        switch(conversion){\n            case \"s\":\n                if (arg === undefined || arg === null) throw new Error(\"argument \" + argn + \": attempted to print undefined or null \" + \"as a string\");\n                ret += doPad(pad, width, left, arg.toString());\n                break;\n            case \"d\":\n                arg = Math.floor(arg);\n            /*jsl:fallthru*/ case \"f\":\n                sign = sign && arg > 0 ? \"+\" : \"\";\n                ret += sign + doPad(pad, width, left, arg.toString());\n                break;\n            case \"x\":\n                ret += doPad(pad, width, left, arg.toString(16));\n                break;\n            case \"j\":\n                /* non-standard */ if (width === 0) width = 10;\n                ret += mod_util.inspect(arg, false, width);\n                break;\n            case \"r\":\n                /* non-standard */ ret += dumpException(arg);\n                break;\n            default:\n                throw new Error(\"unsupported conversion: \" + conversion);\n        }\n    }\n    ret += fmt;\n    return ret;\n}\nfunction jsPrintf() {\n    var args = Array.prototype.slice.call(arguments);\n    args.unshift(process.stdout);\n    jsFprintf.apply(null, args);\n}\nfunction jsFprintf(stream) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return stream.write(jsSprintf.apply(this, args));\n}\nfunction doPad(chr, width, left, str) {\n    var ret = str;\n    while(ret.length < width){\n        if (left) ret += chr;\n        else ret = chr + ret;\n    }\n    return ret;\n}\n/*\n * This function dumps long stack traces for exceptions having a cause() method.\n * See node-verror for an example.\n */ function dumpException(ex) {\n    var ret;\n    if (!(ex instanceof Error)) throw new Error(jsSprintf(\"invalid type for %%r: %j\", ex));\n    /* Note that V8 prepends \"ex.stack\" with ex.toString(). */ ret = \"EXCEPTION: \" + ex.constructor.name + \": \" + ex.stack;\n    if (ex.cause && typeof ex.cause === \"function\") {\n        var cex = ex.cause();\n        if (cex) {\n            ret += \"\\nCaused by: \" + dumpException(cex);\n        }\n    }\n    return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXh0c3ByaW50Zi9saWIvZXh0c3ByaW50Zi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVELElBQUlBLGFBQWFDLG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBRXZCOztDQUVDLEdBQ0RFLGVBQWUsR0FBR0U7QUFDbEJGLGNBQWMsR0FBR0k7QUFDakJKLGVBQWUsR0FBR007QUFFbEI7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ0QsU0FBU0osVUFBVUssR0FBRztJQUVyQixJQUFJQyxRQUFRO1FBQ1I7UUFBYyxlQUFlLEdBQzdCO1FBQVEsbUJBQW1CLEdBQzNCO1FBQXFCLG9CQUFvQixHQUN6QztRQUFrQixvQkFBb0IsR0FDdEM7UUFBc0Isd0JBQXdCLEdBQzlDO1FBQWdCLHlCQUF5QixHQUN6Qyw2QkFBNkIsY0FBYztLQUM5QyxDQUFDQyxJQUFJLENBQUM7SUFFUCxJQUFJQyxLQUFLLElBQUlDLE9BQU9IO0lBQ3BCLElBQUlJLE9BQU9DLE1BQU1DLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUNDLFdBQVc7SUFDakQsSUFBSUMsT0FBT0MsT0FBT0MsV0FBV0M7SUFDN0IsSUFBSUMsTUFBTUMsS0FBS0MsTUFBTUMsS0FBS0M7SUFDMUIsSUFBSUMsTUFBTTtJQUNWLElBQUlDLE9BQU87SUFFWC9CLFdBQVdnQyxLQUFLLENBQUMsVUFBVSxPQUFRdEI7SUFFbkMsTUFBTyxDQUFDbUIsUUFBUWhCLEdBQUdvQixJQUFJLENBQUN2QixJQUFHLE1BQU8sS0FBTTtRQUN2Q29CLE9BQU9ELEtBQUssQ0FBQyxFQUFFO1FBQ2ZuQixNQUFNQSxJQUFJd0IsU0FBUyxDQUFDTCxLQUFLLENBQUMsRUFBRSxDQUFDTSxNQUFNO1FBRW5DZCxRQUFRUSxLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ3BCUCxRQUFRTyxLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ3BCTixZQUFZTSxLQUFLLENBQUMsRUFBRSxJ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QmMsY0FBY2M7UUFDeEM7SUFDRDtJQUVBLE9BQVE1QjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWF0b29scy1uZXh0Ly4vbm9kZV9tb2R1bGVzL2V4dHNwcmludGYvbGliL2V4dHNwcmludGYuanM/ODM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogZXh0c3ByaW50Zi5qczogZXh0ZW5kZWQgUE9TSVgtc3R5bGUgc3ByaW50ZlxuICovXG5cbnZhciBtb2RfYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgbW9kX3V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qXG4gKiBQdWJsaWMgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydHMuc3ByaW50ZiA9IGpzU3ByaW50ZjtcbmV4cG9ydHMucHJpbnRmID0ganNQcmludGY7XG5leHBvcnRzLmZwcmludGYgPSBqc0ZwcmludGY7XG5cbi8qXG4gKiBTdHJpcHBlZCBkb3duIHZlcnNpb24gb2Ygc1tuXXByaW50ZigzYykuICBXZSBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdGhyb3cgYW5cbiAqIGV4Y2VwdGlvbiB3aGVuIGdpdmVuIGEgZm9ybWF0IHN0cmluZyB3ZSBkb24ndCB1bmRlcnN0YW5kLCByYXRoZXIgdGhhblxuICogaWdub3JpbmcgaXQsIHNvIHRoYXQgd2Ugd29uJ3QgYnJlYWsgZXhpc3RpbmcgcHJvZ3JhbXMgaWYvd2hlbiB3ZSBnbyBpbXBsZW1lbnRcbiAqIHRoZSByZXN0IG9mIHRoaXMuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjdXJyZW50bHkgc3VwcG9ydHMgc3BlY2lmeWluZ1xuICpcdC0gZmllbGQgYWxpZ25tZW50ICgnLScgZmxhZyksXG4gKiBcdC0gemVyby1wYWQgKCcwJyBmbGFnKVxuICpcdC0gYWx3YXlzIHNob3cgbnVtZXJpYyBzaWduICgnKycgZmxhZyksXG4gKlx0LSBmaWVsZCB3aWR0aFxuICpcdC0gY29udmVyc2lvbnMgZm9yIHN0cmluZ3MsIGRlY2ltYWwgaW50ZWdlcnMsIGFuZCBmbG9hdHMgKG51bWJlcnMpLlxuICpcdC0gYXJndW1lbnQgc2l6ZSBzcGVjaWZpZXJzLiAgVGhlc2UgYXJlIGFsbCBhY2NlcHRlZCBidXQgaWdub3JlZCwgc2luY2VcbiAqXHQgIEphdmFzY3JpcHQgaGFzIG5vIG5vdGlvbiBvZiB0aGUgcGh5c2ljYWwgc2l6ZSBvZiBhbiBhcmd1bWVudC5cbiAqXG4gKiBFdmVyeXRoaW5nIGVsc2UgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLCBtb3N0IG5vdGFibHkgcHJlY2lzaW9uLCB1bnNpZ25lZFxuICogbnVtYmVycywgbm9uLWRlY2ltYWwgbnVtYmVycywgYW5kIGNoYXJhY3RlcnMuXG4gKi9cbmZ1bmN0aW9uIGpzU3ByaW50ZihmbXQpXG57XG5cdHZhciByZWdleCA9IFtcblx0ICAgICcoW14lXSopJyxcdFx0XHRcdC8qIG5vcm1hbCB0ZXh0ICovXG5cdCAgICAnJScsXHRcdFx0XHQvKiBzdGFydCBvZiBmb3JtYXQgKi9cblx0ICAgICcoW1xcJ1xcXFwtKyAjMF0qPyknLFx0XHRcdC8qIGZsYWdzIChvcHRpb25hbCkgKi9cblx0ICAgICcoWzEtOV1cXFxcZCopPycsXHRcdFx0Lyogd2lkdGggKG9wdGlvbmFsKSAqL1xuXHQgICAgJyhcXFxcLihbMS05XVxcXFxkKikpPycsXHRcdC8qIHByZWNpc2lvbiAob3B0aW9uYWwpICovXG5cdCAgICAnW2xoanp0TF0qPycsXHRcdFx0LyogbGVuZ3RoIG1vZHMgKGlnbm9yZWQpICovXG5cdCAgICAnKFtkaW91eFhmRmVFZ0dhQWNDc1NwJWpyXSknXHQvKiBjb252ZXJzaW9uICovXG5cdF0uam9pbignJyk7XG5cblx0dmFyIHJlID0gbmV3IFJlZ0V4cChyZWdleCk7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0dmFyIGZsYWdzLCB3aWR0aCwgcHJlY2lzaW9uLCBjb252ZXJzaW9uO1xuXHR2YXIgbGVmdCwgcGFkLCBzaWduLCBhcmcsIG1hdGNoO1xuXHR2YXIgcmV0ID0gJyc7XG5cdHZhciBhcmduID0gMTtcblxuXHRtb2RfYXNzZXJ0LmVxdWFsKCdzdHJpbmcnLCB0eXBlb2YgKGZtdCkpO1xuXG5cdHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGZtdCkpICE9PSBudWxsKSB7XG5cdFx0cmV0ICs9IG1hdGNoWzFdO1xuXHRcdGZtdCA9IGZtdC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcblxuXHRcdGZsYWdzID0gbWF0Y2hbMl0gfHwgJyc7XG5cdFx0d2lkdGggPSBtYXRjaFszXSB8fCAwO1xuXHRcdHByZWNpc2lvbiA9IG1hdGNoWzRdIHx8ICcnO1xuXHRcdGNvbnZlcnNpb24gPSBtYXRjaFs2XTtcblx0XHRsZWZ0ID0gZmFsc2U7XG5cdFx0c2lnbiA9IGZhbHNlO1xuXHRcdHBhZCA9ICcgJztcblxuXHRcdGlmIChjb252ZXJzaW9uID09ICclJykge1xuXHRcdFx0cmV0ICs9ICclJztcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmIChhcmdzLmxlbmd0aCA9PT0gMClcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ3RvbyBmZXcgYXJncyB0byBzcHJpbnRmJykpO1xuXG5cdFx0YXJnID0gYXJncy5zaGlmdCgpO1xuXHRcdGFyZ24rKztcblxuXHRcdGlmIChmbGFncy5tYXRjaCgvW1xcJyAjXS8pKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcihcblx0XHRcdCAgICAndW5zdXBwb3J0ZWQgZmxhZ3M6ICcgKyBmbGFncykpO1xuXG5cdFx0aWYgKHByZWNpc2lvbi5sZW5ndGggPiAwKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcihcblx0XHRcdCAgICAnbm9uLXplcm8gcHJlY2lzaW9uIG5vdCBzdXBwb3J0ZWQnKSk7XG5cblx0XHRpZiAoZmxhZ3MubWF0Y2goLy0vKSlcblx0XHRcdGxlZnQgPSB0cnVlO1xuXG5cdFx0aWYgKGZsYWdzLm1hdGNoKC8wLykpXG5cdFx0XHRwYWQgPSAnMCc7XG5cblx0XHRpZiAoZmxhZ3MubWF0Y2goL1xcKy8pKVxuXHRcdFx0c2lnbiA9IHRydWU7XG5cblx0XHRzd2l0Y2ggKGNvbnZlcnNpb24pIHtcblx0XHRjYXNlICdzJzpcblx0XHRcdGlmIChhcmcgPT09IHVuZGVmaW5lZCB8fCBhcmcgPT09IG51bGwpXG5cdFx0XHRcdHRocm93IChuZXcgRXJyb3IoJ2FyZ3VtZW50ICcgKyBhcmduICtcblx0XHRcdFx0ICAgICc6IGF0dGVtcHRlZCB0byBwcmludCB1bmRlZmluZWQgb3IgbnVsbCAnICtcblx0XHRcdFx0ICAgICdhcyBhIHN0cmluZycpKTtcblx0XHRcdHJldCArPSBkb1BhZChwYWQsIHdpZHRoLCBsZWZ0LCBhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2QnOlxuXHRcdFx0YXJnID0gTWF0aC5mbG9vcihhcmcpO1xuXHRcdFx0Lypqc2w6ZmFsbHRocnUqL1xuXHRcdGNhc2UgJ2YnOlxuXHRcdFx0c2lnbiA9IHNpZ24gJiYgYXJnID4gMCA/ICcrJyA6ICcnO1xuXHRcdFx0cmV0ICs9IHNpZ24gKyBkb1BhZChwYWQsIHdpZHRoLCBsZWZ0LFxuXHRcdFx0ICAgIGFyZy50b1N0cmluZygpKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAneCc6XG5cdFx0XHRyZXQgKz0gZG9QYWQocGFkLCB3aWR0aCwgbGVmdCwgYXJnLnRvU3RyaW5nKDE2KSk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2onOiAvKiBub24tc3RhbmRhcmQgKi9cblx0XHRcdGlmICh3aWR0aCA9PT0gMClcblx0XHRcdFx0d2lkdGggPSAxMDtcblx0XHRcdHJldCArPSBtb2RfdXRpbC5pbnNwZWN0KGFyZywgZmFsc2UsIHdpZHRoKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAncic6IC8qIG5vbi1zdGFuZGFyZCAqL1xuXHRcdFx0cmV0ICs9IGR1bXBFeGNlcHRpb24oYXJnKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIGNvbnZlcnNpb246ICcgK1xuXHRcdFx0ICAgIGNvbnZlcnNpb24pKTtcblx0XHR9XG5cdH1cblxuXHRyZXQgKz0gZm10O1xuXHRyZXR1cm4gKHJldCk7XG59XG5cbmZ1bmN0aW9uIGpzUHJpbnRmKCkge1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdGFyZ3MudW5zaGlmdChwcm9jZXNzLnN0ZG91dCk7XG5cdGpzRnByaW50Zi5hcHBseShudWxsLCBhcmdzKTtcbn1cblxuZnVuY3Rpb24ganNGcHJpbnRmKHN0cmVhbSkge1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdHJldHVybiAoc3RyZWFtLndyaXRlKGpzU3ByaW50Zi5hcHBseSh0aGlzLCBhcmdzKSkpO1xufVxuXG5mdW5jdGlvbiBkb1BhZChjaHIsIHdpZHRoLCBsZWZ0LCBzdHIpXG57XG5cdHZhciByZXQgPSBzdHI7XG5cblx0d2hpbGUgKHJldC5sZW5ndGggPCB3aWR0aCkge1xuXHRcdGlmIChsZWZ0KVxuXHRcdFx0cmV0ICs9IGNocjtcblx0XHRlbHNlXG5cdFx0XHRyZXQgPSBjaHIgKyByZXQ7XG5cdH1cblxuXHRyZXR1cm4gKHJldCk7XG59XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIGR1bXBzIGxvbmcgc3RhY2sgdHJhY2VzIGZvciBleGNlcHRpb25zIGhhdmluZyBhIGNhdXNlKCkgbWV0aG9kLlxuICogU2VlIG5vZGUtdmVycm9yIGZvciBhbiBleGFtcGxlLlxuICovXG5mdW5jdGlvbiBkdW1wRXhjZXB0aW9uKGV4KVxue1xuXHR2YXIgcmV0O1xuXG5cdGlmICghKGV4IGluc3RhbmNlb2YgRXJyb3IpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoanNTcHJpbnRmKCdpbnZhbGlkIHR5cGUgZm9yICUlcjogJWonLCBleCkpKTtcblxuXHQvKiBOb3RlIHRoYXQgVjggcHJlcGVuZHMgXCJleC5zdGFja1wiIHdpdGggZXgudG9TdHJpbmcoKS4gKi9cblx0cmV0ID0gJ0VYQ0VQVElPTjogJyArIGV4LmNvbnN0cnVjdG9yLm5hbWUgKyAnOiAnICsgZXguc3RhY2s7XG5cblx0aWYgKGV4LmNhdXNlICYmIHR5cGVvZiAoZXguY2F1c2UpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGNleCA9IGV4LmNhdXNlKCk7XG5cdFx0aWYgKGNleCkge1xuXHRcdFx0cmV0ICs9ICdcXG5DYXVzZWQgYnk6ICcgKyBkdW1wRXhjZXB0aW9uKGNleCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIChyZXQpO1xufVxuIl0sIm5hbWVzIjpbIm1vZF9hc3NlcnQiLCJyZXF1aXJlIiwibW9kX3V0aWwiLCJleHBvcnRzIiwic3ByaW50ZiIsImpzU3ByaW50ZiIsInByaW50ZiIsImpzUHJpbnRmIiwiZnByaW50ZiIsImpzRnByaW50ZiIsImZtdCIsInJlZ2V4Iiwiam9pbiIsInJlIiwiUmVnRXhwIiwiYXJncyIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiYXJndW1lbnRzIiwiZmxhZ3MiLCJ3aWR0aCIsInByZWNpc2lvbiIsImNvbnZlcnNpb24iLCJsZWZ0IiwicGFkIiwic2lnbiIsImFyZyIsIm1hdGNoIiwicmV0IiwiYXJnbiIsImVxdWFsIiwiZXhlYyIsInN1YnN0cmluZyIsImxlbmd0aCIsIkVycm9yIiwic2hpZnQiLCJ1bmRlZmluZWQiLCJkb1BhZCIsInRvU3RyaW5nIiwiTWF0aCIsImZsb29yIiwiaW5zcGVjdCIsImR1bXBFeGNlcHRpb24iLCJ1bnNoaWZ0IiwicHJvY2VzcyIsInN0ZG91dCIsImFwcGx5Iiwic3RyZWFtIiwid3JpdGUiLCJjaHIiLCJzdHIiLCJleCIsImNvbnN0cnVjdG9yIiwibmFtZSIsInN0YWNrIiwiY2F1c2UiLCJjZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/extsprintf/lib/extsprintf.js\n");

/***/ })

};
;